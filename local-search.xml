<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>热更新-动态路由</title>
    <link href="/2025/06/08/%E7%83%AD%E6%9B%B4%E6%96%B0-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <url>/2025/06/08/%E7%83%AD%E6%9B%B4%E6%96%B0-%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在传统微服务体系中，热更新是一个非常重要的功能，可以在网关运行，不重启的情况下，动态修改配置并生效。我们可以把路由分为三种模式</p><ol><li>nginx&#x2F;openresty支持的静态路由，本质是修改nginx.conf，重启nginx生效</li><li>服务自动发现</li><li>热更新</li></ol><p>热更新最重要的是可以动态的更新upstream，Tengine提供的第三方模块<code>nginxngx_http_dyups_module</code>允许在运行时通过 HTTP 接口添加、删除或修改 upstream 配置，无需重启 Nginx。</p><h2 id="1、ngx-http-dyups-module模块"><a href="#1、ngx-http-dyups-module模块" class="headerlink" title="1、ngx_http_dyups_module模块"></a>1、ngx_http_dyups_module模块</h2><ul><li><code>ngx_http_dyups_module</code> 最初由阿里巴巴基于 Tengine 分支开发，目标是在不重启或重载 Nginx&#x2F;Tengine 进程的情况下，实现对 <code>upstream</code> 集群的动态管理（增删、更新、查询）。</li><li>传统 Nginx 要更新 <code>upstream</code> 配置，需要修改配置文件后执行 <code>nginx -s reload</code>，过程中会有瞬间连接中断风险，而 dyups 模块则提供了一个 “在线” 接口，能够在 HTTP 运行时通过 RESTful 或 Lua API 对 <code>upstream</code> 进行增删改查</li></ul><h3 id="1-1、主要数据结构与共享内存设计"><a href="#1-1、主要数据结构与共享内存设计" class="headerlink" title="1.1、主要数据结构与共享内存设计"></a>1.1、主要数据结构与共享内存设计</h3><p>​<strong>全局上下文：<code>ngx_dyups_global_ctx</code></strong></p><ul><li>在初始化（<code>init_module</code>）阶段，模块通过 <code>ngx_shared_memory_add(&quot;dyups_shm_zone&quot;, size, &amp;ngx_http_dyups_module)</code> 分配一块共享内存。该内存段映射到主进程和所有 Worker，共同维护以下重要字段：<ul><li><code>shpool</code>（类型为 <code>ngx_slab_pool_t *</code>）：专用于分配共享内存中的消息节点和字符串副本；</li><li><code>shctx</code>（类型为自定义结构，通常称 <code>ngx_dyups_shctx_t *</code>）：包含消息队列头指针、尾指针、当前版本号 <code>version</code>、消息计数 <code>msg_count</code>、以及存储 <code>Worker</code> 状态的数组 <code>status[]</code> 等。</li></ul></li></ul><p>​<strong>消息节点：<code>ngx_dyups_msg_t</code></strong></p><ul><li><p>每条对 <code>upstream</code> 的增删改查动作最终会被封装成一个 <code>ngx_dyups_msg_t</code> 节点，写入共享内存中的链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span>        <span class="hljs-built_in">queue</span>;    <span class="hljs-comment">// 链表节点</span><br>    <span class="hljs-type">ngx_uint_t</span>         type;     <span class="hljs-comment">// 操作类型：ADD / DELETE / UPDATE</span><br>    <span class="hljs-type">ngx_str_t</span>          name;     <span class="hljs-comment">// 上游名称</span><br>    <span class="hljs-type">ngx_str_t</span>          content;  <span class="hljs-comment">// 包含实际 server 列表的字符串</span><br>    <span class="hljs-type">pid_t</span>             pid[NGX_MAX_WORKERS];  <span class="hljs-comment">// 标记哪些 Worker 已处理</span><br>    <span class="hljs-type">ngx_uint_t</span>        count;    <span class="hljs-comment">// 已处理 Worker 数目</span><br>&#125; <span class="hljs-type">ngx_dyups_msg_t</span>;<br></code></pre></td></tr></table></figure></li><li><p><code>pid[]</code> 用来记录各 Worker 进程对该消息的处理状态；当 <code>count</code> 达到当前 <code>worker_processes</code> 数量时，表示所有 Worker 均已读取该消息，无需再转发或保留。</p></li></ul><p>​<strong>Worker 状态数组：<code>sh-&gt;status[]</code></strong></p><ul><li><p><code>shctx-&gt;status</code> 是一个长度等于 <code>worker_processes</code> 的数组，每个元素为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">pid_t</span>    pid;    <span class="hljs-comment">// Worker 进程号</span><br>    <span class="hljs-type">time_t</span>   time;   <span class="hljs-comment">// 最后一次心跳时间戳</span><br>&#125; <span class="hljs-type">ngx_dyups_status_t</span>;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>init_process</code> 阶段，每个 Worker 会在共享内存中注册自己的 <code>pid</code>，并设置第一次的 <code>time = now</code>。这一信息用于：</p><ol><li>标记哪些 Worker 仍处于活跃状态；</li><li>防止由于某个 Worker 异常退出导致共享消息长时间无法累积至 <code>count == worker_processes</code> 而悬挂。</li></ol></li></ul><p>**共享内存分配粒度**</p><ul><li>共享内存池由 <code>ngx_slab_pool_t</code> 管理，所有对消息节点和动态存储 <code>upstream</code> 字符串的分配都来自该 Slab。这样可以避免不同进程使用各自的堆内存，确保跨进程可见。</li><li>默认 <code>dyups_shm_zone_size 2M</code> 时，可能一次只能发送有限大小的 <code>upstream</code> 信息；对于包含大量 <code>server</code> 的集群，需要调大该参数以防止分配失败。</li></ul><h3 id="1-2、动态增删改查"><a href="#1-2、动态增删改查" class="headerlink" title="1.2、动态增删改查"></a>1.2、动态增删改查</h3><p>本节梳理一次典型的 “更新（Add&#x2F;Update）” 操作流程，删除操作类似，但在正式更新时会调用 <code>ngx_dyups_delete_upstream</code>。</p><p><strong>1、 外部 API 触发与初步检查</strong></p><ol><li>当客户端通过 <code>curl -d &quot;server X:Y;&quot; http://host/dyups/upstream/&lt;name&gt;</code> 发送更新请求时，进入 Nginx 的某个 Worker 并调用 <code>ngx_http_dyups_update_upstream(ngx_str_t *name, ngx_buf_t *buf, ngx_str_t *rv)</code>。</li><li>函数开头会检查全局 <code>ngx_http_dyups_api_enable</code> 标志；若未启用，则直接返回 <code>NGX_HTTP_NOT_ALLOWED (405)</code>，并在 <code>rv</code> 中设置 <code>&quot;API disabled&quot;</code> 提示。</li></ol><p><strong>2、 获取共享内存锁</strong></p><ol><li>根据主配置 <code>dmcf-&gt;trylock</code> 判断锁模式：<ul><li>若 <code>trylock == 0</code>（阻塞模式），调用 <code>ngx_shmtx_lock(&amp;shpool-&gt;mutex)</code>，若有其它 Worker 持锁，则本 Worker 阻塞，直到锁可用；</li><li>若 <code>trylock == 1</code>（非阻塞模式），调用 <code>ngx_shmtx_trylock(&amp;shpool-&gt;mutex)</code>，若抢锁失败，则立即设置 <code>rv=&quot;wait and try again&quot;</code> 并返回 <code>NGX_HTTP_CONFLICT (409)</code>，告知客户端稍后重试。</li></ul></li><li>上锁成功后，才能安全访问 <code>shctx-&gt;msg_queue</code> 以及共享 <code>upstream</code> 数据。</li></ol><p><strong>3、 读取并清理历史消息</strong></p><ol><li>调用 <code>ngx_http_dyups_read_msg_locked(timer)</code>（需在持锁状态下执行），先扫描共享内存中 <code>shctx-&gt;msg_queue</code> 列表：<ul><li>如果某个 <code>msg-&gt;count == total_worker</code>，则说明该消息已被所有 Worker 处理，可安全移出队列并调用 <code>ngx_dyups_destroy_msg</code> 释放对应共享内存；</li><li>否则，对于尚未被本 Worker 处理的消息节点（通过检查 <code>pid[]</code> 数组判断），调用相应内部函数（如 <code>ngx_dyups_do_update</code> 或 <code>ngx_dyups_delete_upstream</code>）在本地内存执行对应操作，并将本 Worker PID 加入 <code>pid[]</code>，令 <code>msg-&gt;count++</code>。</li></ul></li><li>该步骤的目的是：<strong>先把其他 Worker 上次发送的更新都在本进程内同步完成</strong>，保证不会在后续操作中丢失或冲突。</li></ol><p><strong>4、 沙箱验证（<code>ngx_dyups_sandbox_update</code>）</strong></p><ol><li>读取完历史消息后，函数调用 <code>status = ngx_dyups_sandbox_update(buf, rv)</code>：<ul><li>该函数会在内存中临时创建一个 “伪” <code>ngx_http_upstream_srv_conf_t</code> 结构，解析并检查 <code>buf</code> 中包含的 <code>server ...;</code> 列表；</li><li>如果语法错误（例如缺少分号、IP:端口格式不对）或参数非法（如 <code>weight=0</code>），则 <code>status != NGX_HTTP_OK</code>，并在 <code>rv</code> 中返回相应错误信息，跳转至 <code>finish</code> 标签，释放锁并返回错误。</li></ul></li><li>通过沙箱验证意味着新配置符合 Nginx 语法要求且参数合法，但尚未正式写入到主内存结构。</li></ol><p><strong>5、 正式更新（<code>ngx_dyups_do_update</code>）</strong></p><ol><li>执行 <code>status = ngx_dyups_do_update(name, buf, rv)</code>：<ul><li>在本 Worker 进程的 <code>upstream_conf_hash</code> 中，查找是否已存在名为 <code>name</code> 的 <code>upstream</code>；若不存在则创建新的 <code>ngx_http_upstream_srv_conf_t</code> 对象；</li><li>按照沙箱中的解析结果，构建或更新一个 <code>ngx_http_upstream_server_t</code> 链表，其中包含每个后端服务器节点的 IP、权重、最大连接数、失败重试等参数；</li><li>对比新旧列表，执行 “新增”、“修改”、“删除” 三类操作，替换原有数据结构；</li><li>调用原生 Nginx 的 <code>ngx_http_upstream_init_round_robin</code>、<code>init_chash_peer</code> 等函数，重建负载均衡相关状态，保证后续请求调度能使用最新集群。</li></ul></li><li>如果 <code>ngx_dyups_do_update</code> 返回非 <code>NGX_HTTP_OK</code>，说明更新过程中出现内存分配失败或其他异常，此时会跳到 <code>finish</code>，释放锁并返回错误码。</li></ol><p><strong>6、 消息广播到其他 Worker（<code>ngx_http_dyups_send_msg</code>）</strong></p><ol><li>若正式更新成功（<code>status == NGX_HTTP_OK</code>），则调用 <code>ngx_http_dyups_send_msg(name, buf, NGX_DYUPS_ADD)</code>：<ul><li>通过 <code>ngx_slab_alloc_locked</code> 从 <code>shpool</code> 分配一个 <code>ngx_dyups_msg_t</code> 大小的内存；</li><li>将 <code>name</code>、更新内容 <code>buf</code>（通常是以字符串形式保存）、<code>type = NGX_DYUPS_ADD</code>、<code>count = 1</code>（本 Worker 自己先算一次）以及 <code>pid[0] = ngx_pid</code> 填入消息结构；</li><li>将新消息插入 <code>shctx-&gt;msg_queue</code> 链表尾部。</li></ul></li><li>如果写入共享内存失败（如剩余空间不足），则 <code>ngx_http_dyups_send_msg</code> 返回非零，调用者将 <code>rv=&quot;alert: update success but not sync to other process&quot;</code>，并最终返回 <code>NGX_HTTP_INTERNAL_SERVER_ERROR (500)</code>，提醒运维重启或人工介入。</li></ol><p><strong>7、 释放共享内存锁并返回</strong></p><ol><li>不论上述哪个环节出错或成功，都会执行 <code>finish:</code> 标签中的 <code>ngx_shmtx_unlock(&amp;shpool-&gt;mutex)</code>，释放独占锁。</li><li>最终返回值 <code>status</code> 可能是：<ul><li><code>NGX_HTTP_OK (200)</code>：更新成功且消息已写入共享内存；</li><li><code>NGX_HTTP_BAD_REQUEST (400)</code>：沙箱测试失败；</li><li><code>NGX_HTTP_CONFLICT (409)</code>：非阻塞锁未能获得；</li><li><code>NGX_HTTP_INTERNAL_SERVER_ERROR (500)</code>：正式更新成功但无法写入共享内存；</li><li><code>NGX_HTTP_NOT_ALLOWED (405)</code>：未启用 dyups API。</li></ul></li></ol><h3 id="1-3、进程间同步机制（消息队列与定时器）"><a href="#1-3、进程间同步机制（消息队列与定时器）" class="headerlink" title="1.3、进程间同步机制（消息队列与定时器）"></a>1.3、进程间同步机制（消息队列与定时器）</h3><p>1、<strong>定时器驱动：<code>ngx_add_timer(&amp;msg_timer, read_msg_timeout)</code></strong></p><ul><li>在每个 Worker 的 <code>init_process</code> 阶段，模块会调用 <code>ngx_add_timer(&amp;ngx_dyups_global_ctx.msg_timer, read_msg_timeout)</code>，设置一个定时事件。</li><li>定时器回调函数是 <code>ngx_http_dyups_read_msg</code>，其内部会先判断当前时间与 <code>ev-&gt;timer.key</code> 是否过期，若到期就调用 <code>ngx_http_dyups_read_msg_locked</code>。</li><li>该定时器默认以 <code>dyups_read_msg_timeout 1s</code> 周期触发，但可根据场景调整（如改为 <code>500ms</code> 或 <code>2s</code>）。</li></ul><p>2、<strong>持锁读取消息：<code>ngx_http_dyups_read_msg_locked</code></strong></p><ul><li>该函数会首先调用 <code>ngx_shmtx_lock(&amp;shpool-&gt;mutex)</code>；若有其它 Worker 正在更新，会阻塞直到锁空闲；若设置了 <code>dyups_trylock on;</code>，读取方仍是阻塞获取锁，无法立即跳过。</li><li>遍历 <code>shctx-&gt;msg_queue</code>：<ol><li>若 <code>msg-&gt;count == total_worker</code>，说明所有 Worker 都已处理完毕，调用 <code>ngx_queue_remove</code> 将该消息从链表中移除，并调用 <code>ngx_dyups_destroy_msg</code> 释放内存；</li><li>否则，检查 <code>msg-&gt;pid[]</code> 数组，如果当前 Worker PID 尚未出现，则根据 <code>msg-&gt;type</code>（<code>ADD</code>&#x2F;<code>DELETE</code>）执行对应操作（调用 <code>ngx_dyups_do_update</code> 或 <code>ngx_dyups_delete_upstream</code>），然后将本 PID 写入 <code>pid[]</code>，令 <code>msg-&gt;count++</code>；否则跳过。</li></ol></li><li>处理完所有消息后，调用 <code>ngx_shmtx_unlock(&amp;shpool-&gt;mutex)</code>，并重置或延迟下一次定时器（<code>ngx_add_timer(ev, read_msg_timeout)</code>）。</li></ul><p>3、<strong>Worker 状态更新：<code>shctx-&gt;status[]</code></strong></p><ul><li>在 <code>ngx_http_dyups_read_msg_locked</code> 开头，Worker 会先尝试在 <code>shctx-&gt;status[]</code> 中找到或注册自己的 <code>pid</code>，并更新对应 <code>time = now</code>。</li><li>若某些 <code>status[].pid</code> 长时间无 “心跳” 更新（超时），模块会认为对应 Worker 已崩溃或退出，并在后续清理过程中剔除它对消息的未处理计数，以避免死消息永久挂起。</li></ul><h3 id="1-4、锁机制与并发控制（阻塞与非阻塞模式）"><a href="#1-4、锁机制与并发控制（阻塞与非阻塞模式）" class="headerlink" title="1.4、锁机制与并发控制（阻塞与非阻塞模式）"></a>1.4、锁机制与并发控制（阻塞与非阻塞模式）</h3><p>​<strong>锁保护范围</strong></p><ul><li>每次写入或读取共享内存时，都必须先调用 <code>ngx_shmtx_lock(&amp;shpool-&gt;mutex)</code>；在写操作（如 <code>ngx_http_dyups_update_upstream</code>）中，整个流程包括读取旧消息、沙箱验证、正式更新、消息写入共享内存，全部在同一把锁内完成，保证对共享内存的原子性与一致性。</li></ul><p>​<strong>阻塞锁（默认模式）</strong></p><ul><li>当一个 Worker 开始更新时，其它尝试更新或读取消息的 Worker 都会在 <code>ngx_shmtx_lock</code> 处阻塞；在长时间更新（如包含大量节点的 <code>upstream</code>）期间，可能导致多个 Worker 长时间处于挂起状态，无法处理新来的业务请求。 </li><li>这种场景在后文性能章节还会详细分析。</li></ul><p>​<strong>非阻塞锁（<code>dyups_trylock on</code>）</strong></p><ul><li>若设置 <code>dyups_trylock on;</code>，写操作中改用 <code>ngx_shmtx_trylock</code>，若锁被占用则立即返回 <code>NGX_HTTP_CONFLICT (409)</code>，上层接口告知客户端 “wait and try again”，无需 Worker 长时间阻塞。</li><li>但 <strong>定时器读取消息</strong> 的路径仍是阻塞式 <code>ngx_shmtx_lock</code>，若锁被占用则轮询线程仍要等到锁空闲才能继续同步，可能短暂挂起业务。</li></ul><p>​<strong>锁粒度优化思考</strong></p><ul><li>将锁粒度最小化：沙箱验证、实际更新、消息写入间尽量迅速；</li><li>调整 <code>dyups_read_msg_timeout</code> 周期：过小会频繁抢锁，过大则延迟配置同步；</li><li>在高并发场景下，优先使用 <code>trylock on</code>，让更新请求自行重试，而不是让 Worker 一直挂起。</li></ul><h3 id="1-5、源码分析"><a href="#1-5、源码分析" class="headerlink" title="1.5、源码分析"></a>1.5、源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_dyups_interface_handler()<br> └── ngx_http_dyups_interface_read_body()<br>      └── ngx_http_dyups_body_handler()<br>           └── ngx_dyups_update_upstream()<br>                └── ngx_dyups_do_update()<br>                     └── ngx_dyups_add_server()<br></code></pre></td></tr></table></figure><p>1、注册location的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">&#123; ngx_string(<span class="hljs-string">&quot;dyups_interface&quot;</span>),<br>     NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,<br>     ngx_http_dyups_interface,<br>     <span class="hljs-number">0</span>,<br>     <span class="hljs-number">0</span>,<br>     <span class="hljs-literal">NULL</span> &#125;,<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<br><span class="hljs-title function_">ngx_http_dyups_interface</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">ngx_command_t</span> *cmd, <span class="hljs-type">void</span> *conf)</span><br>&#123;<br>    <span class="hljs-type">ngx_http_core_loc_conf_t</span>    *clcf;<br>    <span class="hljs-type">ngx_http_dyups_main_conf_t</span>  *dmcf;<br><br>    dmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_dyups_module);<br>    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);<br>    clcf-&gt;handler = ngx_http_dyups_interface_handler;<br>    dmcf-&gt;enable = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> NGX_CONF_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、更新upstream</p><p>这是最主要处理函数，主要做了5步</p><ul><li>获取共享内存锁（可选阻塞或非阻塞模式），以保证多个进程不会并发修改</li><li>从共享内存中读取之前未处理的消息，并根据需要在共享内存中进行更新或删除操作； </li><li>在“沙箱”中（sandbox）先行尝试本次上游配置更新，以验证新配置语法和结构是否正确；</li><li>如果沙箱测试通过，则按正式流程调用 <code>ngx_dyups_do_update</code> 实际更新上游链表；</li><li>在更新成功后，将本次更新操作写入共享内存，使其他 Worker&#x2F;进程能够同步到新的配置；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_dyups_update_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_str_t</span> *name, <span class="hljs-type">ngx_buf_t</span> *buf, <span class="hljs-type">ngx_str_t</span> *rv)</span><br>&#123;<br>    <span class="hljs-type">ngx_int_t</span>                    status;          <br>    <span class="hljs-type">ngx_event_t</span>                 *timer;          <br>    <span class="hljs-type">ngx_slab_pool_t</span>             *shpool;     <br>    <span class="hljs-type">ngx_http_dyups_main_conf_t</span>  *dmcf;     <br>    <br>    dmcf = ngx_http_cycle_get_module_main_conf(ngx_cycle,<br>                                               ngx_http_dyups_module);<br> <br><br>     .......................<br>    <span class="hljs-comment">// 获取共享内存锁</span><br>     <span class="hljs-keyword">if</span> (!dmcf-&gt;trylock) &#123;<br>        ngx_shmtx_lock(&amp;shpool-&gt;mutex);           <span class="hljs-comment">// 阻塞方式获取锁</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!ngx_shmtx_trylock(&amp;shpool-&gt;mutex)) &#123; <span class="hljs-comment">// 非阻塞方式尝试获取锁</span><br>            ngx_str_set(rv, <span class="hljs-string">&quot;wait and try again\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> NGX_HTTP_CONFLICT;  <br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 读取共享内存中的消息</span><br>    ngx_http_dyups_read_msg_locked(timer);<br><br>    <span class="hljs-comment">// 在沙箱中测试更新</span><br>    status = ngx_dyups_sandbox_update(buf, rv);<br>   .......................<br>       <br>    <span class="hljs-comment">// 执行实际的上游更新操作</span><br>    status = ngx_dyups_do_update(name, buf, rv);<br>    <span class="hljs-keyword">if</span> (status == NGX_HTTP_OK) &#123;<br>        <span class="hljs-comment">// 同步更新消息到其他进程</span><br>        <span class="hljs-keyword">if</span> (ngx_http_dyups_send_msg(name, buf, NGX_DYUPS_ADD)) &#123;<br>            .......................<br>        &#125;<br>    &#125;<br>        .......................<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、ingress-nginx的热更新实现"><a href="#2、ingress-nginx的热更新实现" class="headerlink" title="2、ingress-nginx的热更新实现"></a>2、ingress-nginx的热更新实现</h2><p>对于一个功能，一定要多学习借鉴同层次产品的实现。ingress-nginx也实现了热更新，但是是通过lua层面实现的，有一篇文章总结的非常好 <a href="https://xiaorui.cc/archives/7342">https://xiaorui.cc/archives/7342</a></p><ol><li><strong>Lua 负载均衡</strong>：在 <code>balancer_by_lua_block</code> 中使用 <code>lua-resty-balancer</code>，在共享内存中根据算法选取可用后端。</li><li><strong>主动推送</strong>：当 Kubernetes 集群中 Ingress&#x2F;Service&#x2F;Endpoint 变更时，Control-Plane 通过 HTTP POST 将新的后端 JSON 发送到 OpenResty 内部接口 <code>/configuration/backends</code> 。</li><li><strong>写入共享内存</strong>：该 Lua 接口读取请求体，使用 <code>cjson.decode()</code> 解析 JSON，并将后端列表序列化后写入 <code>ngx.shared.dynamic_upstreams</code> 等 <code>lua_shared_dict</code> 。</li><li><strong>Worker 周期性拉取</strong>：尽管 Control-Plane 会主动推送，仍需在每个 Worker 的 <code>init_worker_by_lua_block</code> 中注册定时器，每隔 1 秒调用 <code>sync_backends</code> 与 <code>sync_backends_with_external_name</code>，从 Controller HTTP 接口拉取最新后端配置，保证所有新启动或错过推送的 Worker 都能补偿性地同步到共享内存 。</li><li><strong>请求时读取共享内存</strong>：在每个请求的 <code>balancer_by_lua_block</code> 阶段，Lua 脚本通过 <code>ngx.shared.dynamic_upstreams:get(service_name)</code> 读取最新后端列表，执行加权&#x2F;轮询等算法后调用 <code>ngx.balancer.set_current_peer(host, port)</code>，完成动态路由决策，而无需重载 NGINX。</li><li>这样，Ingress-NGINX 能在高可用场景下实现“推送+拉取+读取”三步闭环，既能及时响应变更，又能弥补短暂的推送失效，最大化减少重载带来的抖动和中断。</li></ol><h3 id="2-1、前置三步确认"><a href="#2-1、前置三步确认" class="headerlink" title="2.1、前置三步确认"></a>2.1、前置三步确认</h3><ol><li>Lua 负载均衡（lua-resty-balancer）</li></ol><ul><li><p>Ingress-NGINX 在 <code>nginx.tmpl</code> 中定义了若干 <code>lua_shared_dict</code>，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">lua_shared_dict</span> dynamic_upstreams <span class="hljs-number">5m</span>;<br></code></pre></td></tr></table></figure><p>用于存储后端服务地址与权重等信息，供 Lua 层访问</p></li><li><p>在具体的 <code>upstream</code> 块中，使用 <code>balancer_by_lua_block</code> 指令调用 Lua 脚本（如 <code>balancer.lua</code>）进行动态负载均衡：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> dynamic_upstream &#123;<br>    <span class="hljs-section">balancer_by_lua_block</span> &#123;<br>        <span class="hljs-attribute">local</span> balancer = require(<span class="hljs-string">&quot;lua_ingress&quot;</span>).balancer<br>        balancer(<span class="hljs-string">&quot;default-my-service&quot;</span>)  -- 传入服务名<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>lua-resty-balancer</code> 或自研脚本会读取 <code>ngx.shared.dynamic_upstreams</code> 中同名键对应的 JSON 字符串，<code>cjson.decode()</code> 转为 Lua 表后，根据配置选择后端</p></li></ul><ol start="2"><li>路由变更时主动推送</li></ol><ul><li><p>当 Kubernetes 集群中 Ingress 或 Service&#x2F;Endpoint 发生变更时，Ingress-NGINX Controller 会构建一个类似如下格式的 JSON：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;<br>  <span class="hljs-attr">&quot;default-my-service&quot;:</span> [<span class="hljs-string">&quot;10.0.0.5:80&quot;</span>, <span class="hljs-string">&quot;10.0.0.6:80&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>然后向本地 OpenResty 暴露的 <code>/configuration/backends</code> 接口发起 HTTP POST 请求 。</p></li><li><p>该接口在 Lua 层</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> ngx.var.request_uri == <span class="hljs-string">&quot;/configuration/backends&quot;</span> <span class="hljs-keyword">then</span><br>    handle_backends()<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>成功后返回 HTTP 200，完成一次“主动推送+写入共享内存”的操作 。</p></li></ul><ol start="3"><li>接口解析与存储</li></ol><ul><li><p><code>/configuration/backends</code> 接口对应的 Lua 实现在 <code>configuration.lua</code> 中，核心为 <code>handle_backends()</code> 函数：</p></li><li><p>这段代码主要实现以下功能：</p><ol><li>支持两种HTTP方法：<ul><li>GET：获取当前后端配置</li><li>POST：更新后端配置</li></ul></li><li>关键操作流程：<ul><li>读取请求体数据</li><li>将新配置存入共享内存</li><li>记录同步时间戳</li><li>处理各种错误情况</li></ul></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle_backends</span><span class="hljs-params">()</span></span><br>  <span class="hljs-comment">-- 处理GET请求：返回当前后端配置数据</span><br>  <span class="hljs-keyword">if</span> ngx.var.request_method == <span class="hljs-string">&quot;GET&quot;</span> <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_OK<br>    ngx.<span class="hljs-built_in">print</span>(_M.get_backends_data())<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 读取请求体中的后端配置数据</span><br>  <span class="hljs-keyword">local</span> backends = fetch_request_body()<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> backends <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;dynamic-configuration: unable to read valid request body&quot;</span>)<br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_BAD_REQUEST<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 将新的后端配置存入共享内存</span><br>  <span class="hljs-keyword">local</span> success, err = configuration_data:set(<span class="hljs-string">&quot;backends&quot;</span>, backends)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;dynamic-configuration: error updating configuration: &quot;</span> .. <span class="hljs-built_in">tostring</span>(err))<br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_BAD_REQUEST<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 更新同步时间戳</span><br>  ngx.update_time()  <span class="hljs-comment">-- 确保获取当前精确时间</span><br>  <span class="hljs-keyword">local</span> raw_backends_last_synced_at = ngx.<span class="hljs-built_in">time</span>()<br>  <br>  <span class="hljs-comment">-- 记录最后同步时间到共享内存</span><br>  success, err = configuration_data:set(<span class="hljs-string">&quot;raw_backends_last_synced_at&quot;</span>, raw_backends_last_synced_at)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> success <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;dynamic-configuration: error updating when backends sync, &quot;</span> ..<br>                     <span class="hljs-string">&quot;new upstream peers waiting for force syncing: &quot;</span> .. <span class="hljs-built_in">tostring</span>(err))<br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_BAD_REQUEST<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 返回创建成功的状态码</span><br>  ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_CREATED<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>如果需要同步 <code>ExternalName</code> 服务，则 Controller 还会调用 <code>/configuration/backends/external</code> 接口，Lua 在 <code>sync_backends_with_external_name()</code> 中提取域名并进行 DNS 解析，写入同一共享内存 。</p></li></ul><hr><h3 id="2-2、第4步：Worker-周期性拉取"><a href="#2-2、第4步：Worker-周期性拉取" class="headerlink" title="2.2、第4步：Worker 周期性拉取"></a>2.2、第4步：Worker 周期性拉取</h3><p><code>sync_backends</code> &amp; <code>sync_backends_with_external_name</code></p><p>尽管 Controller 会主动推送，但需要在每个 Worker 内注册定时器，周期性（一般为 1 秒）拉取最新配置，原因如下：</p><p>4.1、 设计初衷</p><ol><li><strong>Worker 冷启动补偿</strong><ul><li>新创建的 Worker 并未能经历之前 Controller 的推送；如果不主动拉取，就只能在下一次有变更时才有机会拿到配置，造成“冷启动白屏”或“脏数据路由”现象 。</li></ul></li><li><strong>网络或推送失败补偿</strong><ul><li>Controller 在推送时可能因网络抖动、Lua 解析错误等意外导致部分 Worker 未能及时更新共享内存；定时拉取能在网络恢复后及时获取正确数据，保证“最终一致性” 。</li></ul></li><li><strong>并发推送竞态场景</strong><ul><li>当多个 Controller 同时推送不同版本的后端列表时，某些 Worker 可能接收 A 版本但错过 B 版本推送；定时拉取确保 Worker 能以“最新可用版本”为准，避免短暂竞态导致长时间漂移 。</li></ul></li></ol><p>4.2、 定时器注册</p><p>1、初始化时启动定时器，ngx.timer.at只会执行一次，ngx.timer.every会重复执行</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.init_worker</span><span class="hljs-params">()</span></span><br>  <span class="hljs-comment">-- 当worker进程启动时，立即同步非ExternalName类型的后端服务</span><br>  <span class="hljs-comment">-- 这些后端不需要DNS解析，可以直接处理</span><br>  sync_backends()<br>  <br>  <span class="hljs-comment">-- 对于需要DNS解析的ExternalName类型后端服务，</span><br>  <span class="hljs-comment">-- 需要通过定时器异步处理（因为init_worker阶段无法使用socket）</span><br>  <span class="hljs-keyword">local</span> ok, err = ngx.timer.at(<span class="hljs-number">0</span>, sync_backends_with_external_name)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;failed to create timer: &quot;</span>, err)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 设置定期同步普通后端服务的定时器</span><br>  <span class="hljs-comment">-- 同步间隔为BACKENDS_SYNC_INTERVAL（默认为1秒）</span><br>  ok, err = ngx.timer.every(BACKENDS_SYNC_INTERVAL, sync_backends)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;error when setting up timer.every for sync_backends: &quot;</span>, err)<br>  <span class="hljs-keyword">end</span><br>  <br>  <span class="hljs-comment">-- 设置定期同步ExternalName后端服务的定时器</span><br>  <span class="hljs-comment">-- 使用相同的同步间隔</span><br>  ok, err = ngx.timer.every(BACKENDS_SYNC_INTERVAL, sync_backends_with_external_name)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;error when setting up timer.every for sync_backends_with_external_name: &quot;</span>,<br>            err)<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>2、<code>sync_backends_with_external_name</code></p><ul><li><strong>作用</strong>：专门同步类型为 <code>ExternalName</code> 的 Kubernetes Service，先读取接口返回的数据，获取域名列表，再进行 DNS 解析后更新共享内存。</li><li><strong>流程</strong>：<ol><li>HTTP GET <code>/configuration/backends/external</code> 获取映射。（Controller 提供的接口）</li><li>对每个域名调用 <code>ngx.socket.dns.toip(domain)</code> 获取 IP 列表。</li><li>调用 <code>sync_backend()</code>（详见下文）将解析后的 IP 地址写入共享内存。</li></ol></li><li><strong>使用频率</strong>：定时器注册后每秒执行一次 。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sync_backends_with_external_name</span><span class="hljs-params">()</span></span><br>  <span class="hljs-keyword">for</span> _, backend_with_external_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(backends_with_external_name) <span class="hljs-keyword">do</span><br>    sync_backend(backend_with_external_name)<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sync_backend</span><span class="hljs-params">(backend)</span></span><br>  <span class="hljs-comment">-- 检查是否为ExternalName类型的后端服务</span><br>  <span class="hljs-comment">-- 如果是则解析外部名称获取实际IP地址</span><br>  <span class="hljs-keyword">if</span> is_backend_with_external_name(backend) <span class="hljs-keyword">then</span><br>    backend = resolve_external_names(backend)<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 检查后端端点是否为空</span><br>  <span class="hljs-comment">-- 如果为空则清除该后端的负载均衡器缓存</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> backend.endpoints <span class="hljs-keyword">or</span> #backend.endpoints == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    balancers[backend.name] = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 格式化IPv6地址，确保被方括号包围</span><br>  backend.endpoints = format_ipv6_endpoints(backend.endpoints)<br><br>  <span class="hljs-comment">-- 根据后端配置获取对应的负载均衡算法实现</span><br>  <span class="hljs-keyword">local</span> implementation = get_implementation(backend)<br>  <span class="hljs-comment">-- 从缓存中获取该后端的负载均衡器实例</span><br>  <span class="hljs-keyword">local</span> balancer = balancers[backend.name]<br><br>  <span class="hljs-comment">-- 如果负载均衡器不存在，则创建新实例</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancer <span class="hljs-keyword">then</span><br>    balancers[backend.name] = implementation:new(backend)<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 检查负载均衡算法是否发生变化</span><br>  <span class="hljs-comment">-- 通过比较元表判断当前实例是否属于新的实现类</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">getmetatable</span>(balancer) ~= implementation <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.INFO,<br>        <span class="hljs-built_in">string</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;LB algorithm changed from %s to %s, resetting the instance&quot;</span>,<br>                      balancer.name, implementation.name))<br>    <span class="hljs-comment">-- 算法变化时创建新的负载均衡器实例</span><br>    balancers[backend.name] = implementation:new(backend)<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 如果负载均衡器已存在且算法未变化，则同步更新后端配置</span><br>  balancer:sync(backend)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>3、<code>sync_backends</code></p><ul><li><strong>作用</strong>：获取 Controller 暴露的普通 Service 后端配置（<code>Endpoints</code>），同步到共享内存（<code>lua_shared_dict dynamic_upstreams</code>）。</li><li><strong>数据来源</strong>：HTTP GET 请求 <code>/configuration/backends</code> 接口。（Controller 提供的接口）</li><li><strong>使用频率</strong>：由 <code>init_worker_by_lua_block</code> 注册的定时器每秒执行一次，确保实时同步。</li><li><strong>不处理</strong>：对于类型为 <code>ExternalName</code> 的服务不会同步（将由 <code>sync_backends_with_external_name</code> 处理）</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sync_backends</span><span class="hljs-params">()</span></span><br>  <span class="hljs-comment">-- 获取后端配置最后同步时间</span><br>  <span class="hljs-keyword">local</span> raw_backends_last_synced_at = configuration.get_raw_backends_last_synced_at()<br>  <span class="hljs-comment">-- 如果配置未更新则直接返回</span><br>  <span class="hljs-keyword">if</span> raw_backends_last_synced_at &lt;= backends_last_synced_at <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 获取后端配置数据</span><br>  <span class="hljs-keyword">local</span> backends_data = configuration.get_backends_data()<br>  <span class="hljs-comment">-- 如果没有配置数据则清空balancers缓存</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> backends_data <span class="hljs-keyword">then</span><br>    balancers = &#123;&#125;<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 解析JSON格式的后端配置</span><br>  <span class="hljs-keyword">local</span> new_backends, err = cjson.decode(backends_data)<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> new_backends <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;could not parse backends data: &quot;</span>, err)<br>    <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 创建需要保留的后端名称集合</span><br>  <span class="hljs-keyword">local</span> balancers_to_keep = &#123;&#125;<br>  <span class="hljs-comment">-- 遍历所有新后端配置</span><br>  <span class="hljs-keyword">for</span> _, new_backend <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(new_backends) <span class="hljs-keyword">do</span><br>    <span class="hljs-comment">-- 如果是ExternalName类型的服务</span><br>    <span class="hljs-keyword">if</span> is_backend_with_external_name(new_backend) <span class="hljs-keyword">then</span><br>      <span class="hljs-comment">-- 深拷贝配置并存入外部名称后端集合</span><br>      <span class="hljs-keyword">local</span> backend_with_external_name = util.deepcopy(new_backend)<br>      backends_with_external_name[backend_with_external_name.name] = backend_with_external_name<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-comment">-- 同步普通后端配置</span><br>      sync_backend(new_backend)<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">-- 标记该后端需要保留</span><br>    balancers_to_keep[new_backend.name] = <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-comment">-- 清理不再存在的后端配置</span><br>  <span class="hljs-keyword">for</span> backend_name, _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(balancers) <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancers_to_keep[backend_name] <span class="hljs-keyword">then</span><br>      balancers[backend_name] = <span class="hljs-literal">nil</span><br>      backends_with_external_name[backend_name] = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-comment">-- 更新最后同步时间</span><br>  backends_last_synced_at = raw_backends_last_synced_at<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li><code>ngx.timer.at(0, _M.sync_backends)</code> 表示在 Worker 启动后<strong>立即</strong>执行一次 <code>sync_backends</code>；</li><li>在 <code>sync_backends</code> 与 <code>sync_backends_with_external_name</code> 的末尾，重新调用 <code>ngx.timer.at(1, ...)</code> 注册下一次 1 秒延迟的定时任务；</li><li>这样每个 Worker 都会每秒主动拉取一次后端配置，无论 Controller 推送是否成功，均能在最多 1 秒内同步到最新状态 。</li></ul><hr><h3 id="2-3、第5步：请求阶段读取共享内存并路由"><a href="#2-3、第5步：请求阶段读取共享内存并路由" class="headerlink" title="2.3、第5步：请求阶段读取共享内存并路由"></a>2.3、第5步：请求阶段读取共享内存并路由</h3><p>在完成“主动推送”与“定时拉取”后，共享内存 <code>ngx.shared.dynamic_upstreams</code> 中始终保存最新的后端列表。下一步，在 HTTP 请求到达时，Lua 负责从共享内存读取并选取后端。完整请求流程</p><ol><li><strong>DNS&#x2F;HTTP 解析</strong>：客户端请求到达 NodePort&#x2F;LoadBalancer，转发到 NGINX Worker 进程；</li><li>**匹配 <code>location</code>**：Nginx 根据配置匹配到使用 <code>proxy_pass http://dynamic_upstream;</code> 的 <code>location /</code>；</li><li>**执行 <code>balancer_by_lua_block</code>**：Nginx 在进入 upstream 阶段前执行 Lua 脚本，Lua 从 <code>ngx.shared.dynamic_upstreams</code> 中读取当前后端列表并选取一个后端；</li><li><strong>设置上游 Peer</strong>：Lua 调用 <code>ngx.balancer.set_current_peer(host, port)</code>，指定本次请求的上游地址；</li><li><strong>转发给上游</strong>：Nginx 将请求转发至以上步骤得出的 IP:Port，完成路由。</li></ol><p>这一路径实现了“读取-选取-转发”的动态更新，无需 <code>nginx -s reload</code>，大幅提升了路由变更后的可用性与稳定性。</p><hr><h3 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h3><ol><li><strong>主动推送</strong>：Control-Plane 在后端变更时将 JSON 配置推送至 Lua 接口，写入共享内存。</li><li><strong>定时拉取</strong>：为了保证新 Worker 与部分推送失败的补偿，每个 Worker 在 <code>init_worker_by_lua_block</code> 中注册定时器，每秒调用 <code>sync_backends</code> 和 <code>sync_backends_with_external_name</code>，从 Controller 接口再次拉取配置并更新共享内存。</li><li><strong>请求时读取</strong>：在 <code>balancer_by_lua_block</code> 阶段，Lua 脚本从共享内存读取最新后端列表，执行负载均衡算法（<code>lua-resty-balancer</code>）并调用 <code>ngx.balancer.set_current_peer()</code>，实现动态路由。</li></ol><p>通过上述 “主动推送 + 周期性拉取 + 请求时读取” 的三步闭环，Ingress-NGINX 能在不重启 NGINX 的前提下，实现后端服务的动态热更新，兼顾了 <strong>低延迟</strong>、<strong>高可用</strong> 与 <strong>一致性</strong>。</p><h2 id="3、扩展实现"><a href="#3、扩展实现" class="headerlink" title="3、扩展实现"></a>3、扩展实现</h2><p>对于自己实现网关，由于业务的复杂性，lua层面实现明显不符合需求。之前分析过服务自动发现的设计，2个功能都是在运行期更新路由信息，实际很多逻辑是重叠的。我们从一个经典的部署场景切入</p><p>1个网关集群，包含2台网关</p><p>1个zookeeper集群</p><h3 id="3-1、整体架构"><a href="#3-1、整体架构" class="headerlink" title="3.1、整体架构"></a>3.1、整体架构</h3><p>很明显，2台为网关的配置需要一致，整体需要考虑集群和多进程的更新</p><p>1、客户端调用A网关，变更dyups的配置，A网关更新后，同步到zk。 然后B网关定时感知到变更，然后进行更新。</p><p>2、单独抽一个0号进程，专注于配置更新，而work专注于业务请求的处理。</p><p>3、通过共享内存进行数据的共享，进行变更</p><h3 id="3-2、具体设计"><a href="#3-2、具体设计" class="headerlink" title="3.2、具体设计"></a>3.2、具体设计</h3><p>主要的链路分为2种</p><ul><li>客户端调用    -&gt;   解析客户端body    -&gt;     修改路由信息（内存+配置文件）    -&gt;      同步到zookeeper</li><li>定时器感知zookeeper路由信息变更     -&gt;     获取变更的部分    -&gt;     修改路由信息（内存+配置文件）</li></ul><p>网关集群对数据的一致性保证，与nginx的多进程对数据的一致性保证，其实非常相似。</p><p>1、与服务自动发现一致，复用0号进程，使用0号进程监听特定端口，客户端可以调用该端口，进程配置更新</p><p>2、0号进程处理客户端的变更请求，更新本地文件、共享内存的版本号、配置数据写入共享内存</p><p>3、0号进程更新完数据后，将数据更新到zk，同时也要更新zk的版本号  </p><p>4、0号进程开启定时器，比对zk的版本号与共享内存的版本号是否一致，不一致则进行变更</p><p>5、0号进程获取zk最新的数据，更新本地文件、共享内存的版本号、配置数据写入共享内存</p><p>6、work进程开启定时器，比对共享内存的版本号与本地内存中的版本号，不一致则进程更新</p><h3 id="3-3、需要考虑的问题"><a href="#3-3、需要考虑的问题" class="headerlink" title="3.3、需要考虑的问题"></a>3.3、需要考虑的问题</h3><p>涉及到多台网关就需要考虑竞争关系，还好nginx是多进程，考虑过很多类似的问题，2者的情况类似</p><p>1、2台网关同时主动式更新</p><p>假设配置的版本号为10，A网关被主动式调用，版本号为11，配置写到zk，此时修改zk的版本号为11</p><p>接着，B网关也被主动式调用，版本号也改为11，此时也要写到zk，这时就会存在问题，配置被覆盖了</p><p>所以实际网关在写配置到zk时，需要先获取一下版本号，是否相等，如果相等说明没有其他网关更新，然后再加一，更新到zk</p><p>2、多进程更新</p><p>事实上，只有0号进程会修改配置，work只是读而已，所以不存在竞争关系。但是0号进程也会有问题，因为他不仅要从zk读取数据（其他网关的变更），他也会被主动式调用，修改数据，所以存在竞争关系，其实又回到了第1个问题。</p><p>其实就是模仿ngx_dyups_update_upstream的逻辑，修改数据之前，先获取一下zk的版本号，确认当前拿到的是最新的数据，然后再进行主动式的更新。</p><p>如果zk的数据已经变更，那本次主动式调用，需要返回失败。同时要提示客户端，需要先拿到最新的数据，才能进程主动式调用更新。</p><h2 id="4、主动式调用"><a href="#4、主动式调用" class="headerlink" title="4、主动式调用"></a>4、主动式调用</h2><p>upstream只是一个很基础的路由属性，实际上复杂的业务需要很多属性，比如uri，uri+upstream，可以组成一个路由的基本单元，即客户端请求到业务服务端的映射。当然还有权重、负载策略、失败重试等等属性，有些属性是nginx本身具有的，有些属性需要嵌入ngixn模块开发，或者重新实现模块实现。但总的思想是，虚拟一个路由对象，然后进行动态路由更新。</p><p>相比于ngx_dyups_update_upstream，也只是属性的不一样而已，所以按照同样的方式实现，其实就可以。当然实际实现起来，是有一些难度的。</p><p>编写一个完整的http模块，接收post请求，解析json的body，组装为特定数据格式，在检查过配置的正确性后，分别调用多个路由模块的更新，实现共享内存内存更新，然后更新配置文件。而实际的work通过定时器从共享内存更新最新的路由信息。</p><h2 id="5、资料"><a href="#5、资料" class="headerlink" title="5、资料"></a>5、资料</h2><p>参考：</p><p>官方文档：<a href="https://www.bookstack.cn/read/nginx-official-doc/5.md">https://www.bookstack.cn/read/nginx-official-doc/5.md</a></p><p>GitHub仓库：<a href="https://github.com/yzprofile/ngx_http_dyups_module">https://github.com/yzprofile/ngx_http_dyups_module</a></p><p>openresty的balancer库：**<a href="https://github.com/openresty/lua-resty-balancer">lua-resty-balancer</a>**</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>work</tag>
      
      <tag>zookeeper</tag>
      
      <tag>dyups</tag>
      
      <tag>manage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openresty-域名解析</title>
    <link href="/2025/05/26/nginx%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/"/>
    <url>/2025/05/26/nginx%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1、NGINX-支持的域名解析方式"><a href="#1、NGINX-支持的域名解析方式" class="headerlink" title="1、NGINX 支持的域名解析方式"></a>1、NGINX 支持的域名解析方式</h1><ul><li><strong>静态解析</strong>：启动&#x2F;重载时仅调用系统解析库（<code>getaddrinfo()</code>），将域名映射为 IP 列表后缓存，后续不再更新。</li><li><strong>变量驱动的动态解析</strong>：在 <code>proxy_pass</code> 等指令中使用 <code>$variable</code>，结合 <code>resolver</code>，使 NGINX 在每次请求阶段异步更新域名解析结果。</li><li>**异步 <code>resolver</code> + <code>resolve</code>**：开源版 NGINX ≥ 1.27.3，可在 <code>upstream、server</code> 中添加 <code>resolve</code> 参数，并配合 <code>resolver valid=…</code> 指令定期重查 DNS。</li></ul><hr><h2 id="1-1、静态解析"><a href="#1-1、静态解析" class="headerlink" title="1.1、静态解析"></a>1.1、静态解析</h2><ul><li><p>NGINX 在启动或执行配置重载时，调用标准 C 库函数（如 <code>getaddrinfo()</code>&#x2F;<code>gethostbyname()</code>），根据操作系统的 <code>/etc/resolv.conf</code> 配置一次性解析域名，生成一组 IP 列表，并缓存于内存中。</p></li><li><p>解析只发生在启动&#x2F;重载时，不会再次触发，无视 DNS 记录的 TTL，也不会主动更新。</p></li><li><p>底层实现示例，在 <code>ngx_inet_resolve_host</code> 中使用：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">hints.ai_family  = AF_UNSPEC;<br>hints.ai_socktype = SOCK_STREAM;<br>getaddrinfo(host, <span class="hljs-keyword">NULL</span>, <span class="hljs-variable">&amp;hints</span>, <span class="hljs-variable">&amp;res</span>);<br></code></pre></td></tr></table></figure><p>缺点是该调用会阻塞 worker 进程，故仅在启动时执行 。</p></li></ul><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backends &#123;<br>    <span class="hljs-attribute">server</span> backends.example.com:<span class="hljs-number">8080</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backends;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>以上配置下，NGINX 启动时会解析 <code>backends.example.com</code> 为一组 IP，例如 <code>[10.0.0.11, 10.0.0.10, 10.0.0.12]</code>，并在内存中固化，使用轮询算法分发请求。</li><li>若后端 IP 变更，需重启或 <code>reload</code> NGINX 才能获取新地址。</li></ul><hr><h2 id="1-2、变量驱动的动态解析"><a href="#1-2、变量驱动的动态解析" class="headerlink" title="1.2、变量驱动的动态解析"></a>1.2、变量驱动的动态解析</h2><ul><li>当在 <code>proxy_pass</code>、<code>fastcgi_pass</code> 等指令中使用变量（如 <code>$backend</code>）定义上游域名时，NGINX 不会在启动时固化地址，而会在<strong>每次请求</strong>阶段，调用已配置的异步 DNS <code>resolver</code> 来解析变量所指定的域名 。</li><li>解析过程全程非阻塞，基于 <code>resolver</code> 指令中指定的 DNS 服务器与 TTL（或 <code>valid</code> 覆盖值）进行缓存与重查。</li></ul><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">resolver</span> <span class="hljs-number">10.0.0.2</span> valid=<span class="hljs-number">10s</span>;  <span class="hljs-comment"># 指定 DNS 服务器并设置缓存有效期</span><br><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-comment"># 后端主机名赋值给变量</span><br>        <span class="hljs-attribute">set</span> <span class="hljs-variable">$backend</span> backends.example.com;<br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-comment"># 使用变量触发动态解析</span><br>            <span class="hljs-attribute">proxy_pass</span> http://<span class="hljs-variable">$backend</span>:8080;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每次请求时，若上次解析已超出 <code>10s</code>，NGINX 会异步查询 <code>10.0.0.2</code>，获取最新 IP 列表并更新连接目标。</li><li>该方式无需重启即可感知 DNS 变更，但会在高并发下增加解析开销。</li></ul><hr><h2 id="1-3、异步-resolver-resolve"><a href="#1-3、异步-resolver-resolve" class="headerlink" title="1.3、异步 resolver + resolve"></a>1.3、异步 resolver + resolve</h2><ul><li>自 NGINX 开源版 <strong>1.27.3</strong> 起，官方正式合入 “Upstream: re‑resolvable servers” 功能，允许在 <code>upstream … server</code> 指令后添加 <code>resolve</code> 参数。</li><li>配合同级作用域的 <code>resolver address … valid=…</code>，NGINX 以异步方式定期（依据 DNS TTL 或 <code>valid</code> 覆盖值）对带 <code>resolve</code> 的域名重新发起查询，更新后端服务器列表 <a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?utm_source=chatgpt.com">nginx.org</a><a href="https://blog.nginx.org/blog/dynamic-dns-resolution-open-sourced-in-nginx?utm_source=chatgpt.com">NGINX社区博客</a>。</li><li>解析由 NGINX 自身的事件驱动模块完成，无任何阻塞。</li></ul><p>配置示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-comment"># 1. 指定 DNS 服务器与自定义缓存过期时间</span><br>    <span class="hljs-attribute">resolver</span> <span class="hljs-number">8.8.8.8</span> <span class="hljs-number">8.8.4.4</span> valid=<span class="hljs-number">30s</span> ipv6=<span class="hljs-literal">off</span>;<br><br>    <span class="hljs-comment"># 2. 定义共享内存 zone，用于存储解析结果</span><br>    <span class="hljs-section">upstream</span> backend &#123;<br>        <span class="hljs-attribute">zone</span> backend <span class="hljs-number">64k</span>;<br>        <span class="hljs-attribute">server</span> backend.example.com:<span class="hljs-number">80</span> resolve;  <span class="hljs-comment"># resolve 启用动态重查</span><br>    &#125;<br><br>    <span class="hljs-comment"># 3. 正常使用 upstream</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://backend;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h4 id="当首次请求时，NGINX-背后异步解析-backend-example-com-并将结果缓存在-zone-中。"><a href="#当首次请求时，NGINX-背后异步解析-backend-example-com-并将结果缓存在-zone-中。" class="headerlink" title="当首次请求时，NGINX 背后异步解析 backend.example.com 并将结果缓存在 zone 中。"></a>当首次请求时，NGINX 背后异步解析 <code>backend.example.com</code> 并将结果缓存在 <code>zone</code> 中。</h4></li><li><p>随后每隔 <strong>30s</strong>（或实际 TTL）触发重查，自动增删 IP；若查询失败，仍保留旧列表，保证可用性。</p></li></ul><hr><h2 id="1-4、对比"><a href="#1-4、对比" class="headerlink" title="1.4、对比"></a>1.4、对比</h2><table><thead><tr><th>方式</th><th>首次解析时机</th><th>重查触发</th><th>阻塞风险</th><th>配置复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>静态解析</td><td>启动&#x2F;重载</td><td>无</td><td>中 (启动时)</td><td>最低</td><td>后端 IP 稳定、不频繁变更</td></tr><tr><td>变量动态解析</td><td>每次请求前</td><td>TTL&#x2F;<code>valid</code>到期</td><td>无</td><td>低</td><td>需快速感知变更，但能容忍开销</td></tr><tr><td>异步 <code>resolver</code> + <code>resolve</code></td><td>首次请求触发</td><td>TTL&#x2F;<code>valid</code>到期</td><td>无</td><td>中</td><td>追求配置简洁、低开销的动态解析</td></tr></tbody></table><ul><li><strong>静态解析</strong>：简洁但不灵活，适合 IP 长期不变场景。</li><li><strong>变量驱动</strong>：适合需要频繁变更的场景，但并发高时可能带来解析压力。</li><li><strong><code>resolve</code> 参数</strong>：在新版开源 NGINX 中最推荐的方案，既可自动更新，又无额外请求开销，配置优雅。</li></ul><h1 id="2、openresty的问题"><a href="#2、openresty的问题" class="headerlink" title="2、openresty的问题"></a>2、openresty的问题</h1><p>对于openresty而言，在lua层面连接对端使用的都是connect，但是connect时不支持静态解析，只支持resolver。详情可见此issue：<a href="https://github.com/openresty/lua-nginx-module/issues/2385">https://github.com/openresty/lua-nginx-module/issues/2385</a></p><p>总的来说：</p><ul><li>静态解析使用的是 <code>getaddrinfo()</code>，是 <strong>阻塞式系统调用</strong>；</li><li>OpenResty 的执行模型依赖于 <strong>Nginx 的事件驱动模型（epoll）</strong>；</li><li>一旦在 worker 阻塞了，就会影响所有请求的响应；</li><li>所以 <code>connect</code> 中只允许使用 <strong>非阻塞的异步 DNS 查询</strong>（通过 <code>resolver</code> 实现）；</li></ul><p>所以最后并没有在openresty原生支持hosts，但是可以使用官方的 <code>lua-resty-dns</code> <a href="https://github.com/openresty/lua-resty-dns%EF%BC%8C%E8%BF%99%E9%87%8C%E9%9D%A2%E6%94%AF%E6%8C%81%E4%BA%86hosts%E7%9A%84%E8%A7%A3%E6%9E%90%E3%80%82">https://github.com/openresty/lua-resty-dns，这里面支持了hosts的解析。</a></p><h1 id="3、nginx支持resolver-resolve源码解析"><a href="#3、nginx支持resolver-resolve源码解析" class="headerlink" title="3、nginx支持resolver + resolve源码解析"></a>3、nginx支持resolver + resolve源码解析</h1><p>此特性使得在 <code>upstream</code> 的 <code>server</code> 指令中指定主机名时，可以结合 <code>resolver</code> 指令，在<strong>运行时动态异步解析域名</strong>。这对于使用 DNS 实现服务发现非常关键。</p><h2 id="3-1-入口逻辑"><a href="#3-1-入口逻辑" class="headerlink" title="3.1 入口逻辑"></a>3.1 入口逻辑</h2><p>当 Nginx 收到客户端请求并准备建立与 upstream 的连接时，调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_upstream_init()<br> └── ngx_http_upstream_init_request()<br>      └── ngx_resolve_name()<br>           └── ngx_resolve_name_locked()<br>                └── ngx_resolver_send_query()<br>                     └── ngx_resolver_send_tcp_query() or <span class="hljs-title function_">ngx_resolver_send_udp_query</span><span class="hljs-params">()</span>  ←★ 这里发起DNS查询<br><br></code></pre></td></tr></table></figure><p>源码位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">src/http/ngx_http_upstream.c<br></code></pre></td></tr></table></figure><p>当配置中写入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">resolver</span> <span class="hljs-number">8.8.8.8</span>;<br><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> example.com resolve;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 在运行期遇到 <code>example.com</code> 时不会立即尝试连接，而是先通过 <code>ngx_resolve_name()</code> 调用 resolver 模块发起异步 DNS 查询。</p><h2 id="3-2-发送异步-DNS-查询"><a href="#3-2-发送异步-DNS-查询" class="headerlink" title="3.2 发送异步 DNS 查询"></a>3.2 发送异步 DNS 查询</h2><p>在 <code>ngx_resolver_send_udp_query()</code> 或 <code>ngx_resolver_send_tcp_query()</code> 中，根据 DNS 查询类型构建 DNS 请求包，然后发送：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_resolver_send_udp_query</span><span class="hljs-params">(<span class="hljs-type">ngx_resolver_t</span> *r,</span><br><span class="hljs-params">                             <span class="hljs-type">ngx_resolver_connection_t</span> *rec,</span><br><span class="hljs-params">                             u_char *query, u_short qlen)</span><br>&#123;<br>    n = ngx_send(rec-&gt;udp, query, qlen);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这一过程是<strong>非阻塞、异步</strong>的：UDP 发送成功后即返回，等待后续事件回调处理响应。</p><h2 id="3-3-异步回调处理"><a href="#3-3-异步回调处理" class="headerlink" title="3.3 异步回调处理"></a>3.3 异步回调处理</h2><p>DNS 响应包到达时，通过事件机制触发 <code>ngx_event_process_resolver()</code>，最终调用注册的回调函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ctx-&gt;handler = ngx_http_upstream_resolve_handler;<br></code></pre></td></tr></table></figure><p>回调函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_resolve_handler</span><span class="hljs-params">(<span class="hljs-type">ngx_resolver_ctx_t</span> *ctx)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (ctx-&gt;state) &#123;<br>        <span class="hljs-comment">// 解析失败处理</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 更新 upstream resolved 地址列表</span><br>        ur-&gt;addrs = ctx-&gt;addrs;<br>        ur-&gt;naddrs = ctx-&gt;naddrs;<br>    &#125;<br><br>    ngx_http_upstream_connect(r, u); <span class="hljs-comment">// 继续后续连接流程</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这一步的关键点是：<strong>在解析成功后，将域名解析出来的 IP 地址写入 <code>u-&gt;resolved</code> 结构体中</strong>，并调用 <code>ngx_http_upstream_connect()</code>，继续执行连接逻辑。</p><h2 id="3-4-缓存与失效机制"><a href="#3-4-缓存与失效机制" class="headerlink" title="3.4 缓存与失效机制"></a>3.4 缓存与失效机制</h2><p>解析出来的 IP 地址默认会<strong>缓存</strong>在内存中一段时间（默认是 30 秒，可以通过 <code>resolver valid=10s;</code> 控制）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">resolver</span> <span class="hljs-number">8.8.8.8</span> valid=<span class="hljs-number">10s</span>;<br></code></pre></td></tr></table></figure><p>缓存过期后，下一次请求会触发新的解析流程。</p><p>Nginx 的 resolver 模块还支持以下容错能力：</p><ul><li>解析失败后自动重试；</li><li>使用多个 DNS 服务器（配置多个 resolver）；</li><li>fallback 到 round-robin 策略；</li><li>upstream 失效探测结合负载均衡策略动态选择 backend；</li><li>与 <code>zone</code> 搭配支持共享内存中自动更新 IP。</li></ul><h1 id="4、upstream实现动态域名解析"><a href="#4、upstream实现动态域名解析" class="headerlink" title="4、upstream实现动态域名解析"></a>4、upstream实现动态域名解析</h1><p>事实上，有了第三节的功能，还没有实现真正的域名动态解析，<a href="https://github.com/nginx/nginx/pull/208">https://github.com/nginx/nginx/pull/208</a></p><p><strong>存在的问题：</strong></p><ol><li>DNS 解析结果未动态更新到 upstream peer 列表：即使配置了 <code>resolver</code> 和 <code>resolve</code>，NGINX 只会在启动时解析一次域名，之后不会根据 DNS 的变化更新 upstream 的服务器列表。</li><li>共享内存中未管理已解析的 IP 缓存：解析结果未被存储在共享内存中，导致多个 worker 进程之间无法共享解析结果，增加了不必要的 DNS 查询负载。</li><li>多 worker 之间未同步更新后的 peer 信息：由于缺乏共享机制，DNS 解析的更新无法在多个 worker 之间同步，可能导致请求被发送到已失效的 IP 地址。</li></ol><p><strong>PR #208 解决的问题</strong></p><p>该 PR 引入了以下改进，解决了上述问题：</p><ol><li>动态更新 upstream peer 列表：通过将 DNS 解析结果与 upstream 的服务器列表动态关联，使得当域名解析的 IP 地址发生变化时，upstream 的服务器列表也会相应更新。</li><li>在共享内存中管理解析结果：解析结果被存储在共享内存中，允许多个 worker 进程共享解析结果，减少了重复的 DNS 查询，提高了效率。</li><li>多 worker 之间同步更新：通过共享内存机制，确保所有 worker 进程都能及时获取最新的解析结果，避免了请求被发送到已失效的 IP 地址的问题。</li></ol><h2 id="4-1、源码分析"><a href="#4-1、源码分析" class="headerlink" title="4.1、源码分析"></a>4.1、源码分析</h2><p>o_o ….</p><h1 id="5、lua-resty-dns-client"><a href="#5、lua-resty-dns-client" class="headerlink" title="5、lua-resty-dns-client"></a>5、lua-resty-dns-client</h1><p><code>lua-resty-dns-client</code> 是一个基于 OpenResty 的 Lua DNS 客户端库，它在执行 DNS 查询前，会<strong>优先</strong>检查本地的 hosts 缓存，并仅在未命中时才发送真正的网络请求。为了兼顾性能与配置更新的灵活性，它将 hosts 文件的解析结果缓存在内存中，通过可配置的 TTL 控制重载频率。主要做了3个动作</p><p><strong>初始化阶段（init）</strong>：首次载入并解析 <code>/etc/hosts</code>，将所有条目存入内存缓存；</p><p><strong>解析阶段（resolve）</strong>：每次调用解析时，优先从 hosts 缓存中查找，未命中再发起网络 DNS 请求；</p><p><strong>结果缓存</strong>：对网络 DNS 查询到的结果也进行缓存，以便后续调用可以直接复用。</p><h2 id="5-1-初始化阶段：加载并缓存-hosts"><a href="#5-1-初始化阶段：加载并缓存-hosts" class="headerlink" title="5.1 初始化阶段：加载并缓存 hosts"></a>5.1 初始化阶段：加载并缓存 hosts</h2><p>在初始化阶段，<code>lua-resty-dns-client</code> 会通过 <code>_M.init(options)</code> 方法完成 DNS 客户端的配置和缓存初始化。此时，客户端会读取并解析指定的 hosts 文件（如 <code>/etc/hosts</code>），将所有主机名及其对应的 IP 地址（包括 IPv4 和 IPv6）存入内存缓存。对于 <code>localhost</code> 这样的特殊主机名，会强制写入标准的本地回环地址，确保解析的健壮性。缓存的 TTL（生存时间）通常设置为较长时间（如 10 年），以保证 hosts 文件中的静态解析长期有效。这样，后续的 DNS 查询可以直接从内存中获取 hosts 记录，无需每次都重新读取和解析文件，提高了性能。</p><p>在 [client.lua](vscode-file:&#x2F;&#x2F;vscode-app&#x2F;d:&#x2F;vscode&#x2F;Microsoft VS Code&#x2F;resources&#x2F;app&#x2F;out&#x2F;vs&#x2F;code&#x2F;electron-sandbox&#x2F;workbench&#x2F;workbench.html) 的 <code>_M.init</code> 函数中，初始化阶段主要做了如下事情：</p><ul><li><strong>参数处理与缓存初始化</strong><br>首先读取传入的 <code>options</code>，设置如 <code>staleTtl</code>、<code>cacheSize</code>、<code>noSynchronisation</code> 等参数，并用 <code>lrucache.new(cacheSize)</code> 初始化 LRU 缓存（<code>dnscache</code>），清空已定义主机表（<code>defined_hosts</code>）。</li><li><strong>hosts 文件解析与缓存</strong><br>通过 <code>options.hosts</code> 或默认路径 <code>utils.DEFAULT_HOSTS</code> 获取 hosts 文件路径，然后用 <code>utils.parseHosts(hostsfile)</code> 解析 hosts 文件，得到所有主机名和 IP 的映射表。<br>特别地，如果 hosts 文件中没有 <code>localhost</code>，则强制写入 <code>127.0.0.1</code> 和 <code>[::1]</code>，保证本地回环地址始终可用。</li><li><strong>写入缓存</strong><br>遍历 hosts 解析结果，将每个主机名的 IPv4&#x2F;IPv6 地址分别以 A&#x2F;AAAA 记录的形式写入缓存（<code>cacheinsert</code>），TTL 设置为 10 年。<br>同时，调用 <code>cachesetsuccess</code> 标记该主机名的成功解析类型，便于后续优先查找。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua">hosts, err = utils.parseHosts(hostsfile)<br>...<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> hosts.localhost <span class="hljs-keyword">then</span><br>  hosts.localhost = &#123; ipv4 = <span class="hljs-string">&quot;127.0.0.1&quot;</span>, ipv6 = <span class="hljs-string">&quot;[::1]&quot;</span> &#125;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">local</span> ttl = <span class="hljs-number">10</span>*<span class="hljs-number">365</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>  <span class="hljs-comment">-- use ttl of 10 years for hostfile entries</span><br><span class="hljs-keyword">for</span> name, address <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(hosts) <span class="hljs-keyword">do</span><br>  ...<br>  cacheinsert(&#123;&#123; name = name, address = address.ipv4, <span class="hljs-built_in">type</span> = _M.TYPE_A, ... &#125;&#125;)<br>  ...<br>  cacheinsert(&#123;&#123; name = name, address = address.ipv6, <span class="hljs-built_in">type</span> = _M.TYPE_AAAA, ... &#125;&#125;)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="5-2、解析阶段（resolve）"><a href="#5-2、解析阶段（resolve）" class="headerlink" title="5.2、解析阶段（resolve）"></a>5.2、解析阶段（resolve）</h2><p>每当有 DNS 解析请求到来时，客户端会优先在本地缓存（包括 hosts 记录和之前的 DNS 查询结果）中查找目标主机名。如果缓存命中，则直接返回结果，避免了不必要的网络请求。如果缓存未命中，或者缓存中的记录已经过期，则会根据配置的 nameserver 信息，发起真实的 DNS 网络查询。解析流程还支持多种 DNS 记录类型（如 A、AAAA、SRV、CNAME 等），并能根据配置的优先级顺序依次尝试解析。对于 CNAME 等别名记录，客户端会自动递归解析其指向的真实主机名，直到获得最终的 IP 地址。</p><p>DNS 解析的主入口是 <code>resolve</code> 函数，源码实现如下：</p><ul><li><strong>优先查 hosts 缓存</strong><br>首先调用 <code>cacheShortLookup(qname, qtype)</code> 检查 hosts 及短名缓存，如果命中且未过期，直接返回结果。如果命中但已过期，会标记为 stale 并继续后续流程。</li><li><strong>IP 地址直接返回</strong><br>如果 <code>qname</code> 本身就是 IP 地址（通过 <code>hostnameType</code> 判断），则直接调用 <code>check_ipv4</code> 或 <code>check_ipv6</code>，无需 DNS 查询。</li><li><strong>DNS 查询流程</strong><br>如果缓存未命中，则根据配置的类型顺序（如 A、AAAA、SRV、CNAME）和 search 域名策略，循环调用 <code>lookup</code> 进行 DNS 查询。<br><code>lookup</code> 会先查缓存，未命中时调用 <code>syncQuery</code> 或 <code>individualQuery</code> 发起真实 DNS 网络请求。<br>查询到 CNAME 记录时，会自动递归解析其指向的主机名，直到获得最终的 IP 结果。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> records = cacheShortLookup(qname, qtype)<br><span class="hljs-keyword">if</span> records <span class="hljs-keyword">then</span> ... <span class="hljs-keyword">return</span> records ... <span class="hljs-keyword">end</span><br>...<br><span class="hljs-keyword">for</span> try_name, try_type <span class="hljs-keyword">in</span> search_iter(qname, qtype) <span class="hljs-keyword">do</span><br>  ...<br>  records, err, try_list = lookup(try_name, opts, dnsCacheOnly, try_list, force_no_sync)<br>  ...<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="5-3、结果缓存"><a href="#5-3、结果缓存" class="headerlink" title="5.3、结果缓存"></a>5.3、结果缓存</h2><p>对于通过网络查询获得的 DNS 解析结果，<code>lua-resty-dns-client</code> 也会将其缓存在本地内存中。缓存的有效期由 DNS 响应中的 TTL 或客户端配置的 <code>validTtl</code> 参数决定。对于查询失败或空记录，也会按照 <code>badTtl</code> 或 <code>emptyTtl</code> 进行缓存，避免频繁的无效请求。缓存机制采用 LRU（最近最少使用）策略，确保高频访问的记录能长期保留，而低频或过期的记录会被自动淘汰。这样设计既提升了解析性能，又能保证缓存的实时性和准确性。</p><p>DNS 查询结果的缓存机制体现在如下几个方面：</p><ul><li><strong>缓存写入</strong><br>所有通过网络查询获得的 DNS 结果，都会通过 <code>cacheinsert</code> 写入 LRU 缓存。缓存的 TTL 由 DNS 响应、配置的 <code>validTtl</code>、<code>badTtl</code>、<code>emptyTtl</code> 等参数决定。</li><li><strong>缓存结构</strong><br>缓存项包含 <code>ttl</code>、<code>expire</code>、<code>expired</code>、<code>touch</code> 等元数据，便于判断是否过期和缓存淘汰。</li><li><strong>缓存命中与刷新</strong><br>查询时如果命中缓存但已过期，会立即返回 stale 数据，同时后台异步刷新（<code>asyncQuery</code>），保证高可用和实时性。</li><li><strong>错误与空记录缓存</strong><br>查询失败（如 NXDOMAIN）或空记录，也会按配置 TTL 缓存，避免频繁无效请求。</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cacheinsert</span><span class="hljs-params">(entry, qname, qtype)</span></span><br>  ...<br>  dnscache:set(key, entry, lru_ttl)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> entry.expired <span class="hljs-keyword">then</span><br>  add_status_to_try_list(try_list, <span class="hljs-string">&quot;stale&quot;</span>)<br>  asyncQuery(qname, r_opts, try_list)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>openresty</tag>
      
      <tag>dns</tag>
      
      <tag>hosts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在OpenResty中实现Redis Sentinel支持</title>
    <link href="/2025/05/17/%E7%BD%91%E5%85%B3%E6%94%AF%E6%8C%81redis%E5%93%A8%E5%85%B5/"/>
    <url>/2025/05/17/%E7%BD%91%E5%85%B3%E6%94%AF%E6%8C%81redis%E5%93%A8%E5%85%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="在OpenResty中实现Redis-Sentinel支持"><a href="#在OpenResty中实现Redis-Sentinel支持" class="headerlink" title="在OpenResty中实现Redis Sentinel支持"></a>在OpenResty中实现Redis Sentinel支持</h1><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>OpenResty 通过 <code>lua-resty-redis</code> 模块为 Nginx 提供了与 Redis 交互的能力，但该模块原生仅支持直连模式，不具备高可用场景下的故障转移能力。在复杂的生产环境中，单点 Redis 容易因节点故障导致服务中断，因此需要借助 Redis Sentinel 来实现监控、故障切换、通知和配置提供者等高可用特性Redis。Redis Sentinel 通过分布式的哨兵进程对主从实例进行心跳检测，一旦主节点失效，即可自动将某个从节点提升为新主，并通知客户端重新连接Redis。为了让 OpenResty 应用在 Redis 主节点故障时具备自动切换的能力，我们需要在 <code>lua-resty-redis</code> 之上实现对 Sentinel 模式的支持。</p><h2 id="2、Redis-Sentinel原理"><a href="#2、Redis-Sentinel原理" class="headerlink" title="2、Redis Sentinel原理"></a>2、Redis Sentinel原理</h2><p>Redis Sentinel 是一个负责监控、通知和自动故障切换的分布式系统组件，它通过多个 Sentinel 进程与主从实例协同工作，为 Redis 提供高可用性和自动故障恢复能力。在发生主节点故障时，多个 Sentinel 进程会共同判断并选举出新的主节点，同时向客户端动态发布最新的主节点地址，从而保证 Redis 服务的持续可用。</p><h3 id="2-1、redis基础架构"><a href="#2-1、redis基础架构" class="headerlink" title="2.1、redis基础架构"></a>2.1、redis基础架构</h3><p><strong>Sentinel 进程</strong></p><ul><li>订阅并发布 Sentinel 专用的 Pub&#x2F;Sub 频道，用于互通对各节点健康状况的判断</li><li>维护对所有监控对象（主节点和从节点）的状态信息，并与其他 Sentinel 交换，形成故障检测的共识</li><li>在故障切换时，参与 leader 选举，协调后续提升和重配置操作</li></ul><p><strong>Redis 主节点与从节点</strong></p><ul><li><strong>主节点（Master）</strong>：承担所有写操作，并将写命令通过复制协议同步到从节点</li><li><strong>从节点（Replica）</strong>：负责同步主节点的数据，可用于读请求；在主节点故障时，有资格被提升为新主节点</li></ul><p><strong>客户端（Clients）</strong></p><ul><li>客户端配置中指定所有 Sentinel 地址</li><li>启动或连接主节点失败后，向 Sentinel 查询当前主节点地址</li><li>通过获取的地址发送命令，故障发生时无需人工干预即可自动切换到新主节点</li></ul><h3 id="2-2、主观下线和客观下线"><a href="#2-2、主观下线和客观下线" class="headerlink" title="2.2、主观下线和客观下线"></a>2.2、主观下线和客观下线</h3><p> 一个 Sentinel 需要获得系统中多数（majority） Sentinel 的支持， 才能发起一次自动故障迁移， 并预留一个给定的配置纪元 （configuration Epoch ，一个配置纪元就是一个新主服务器配置的版本号）。也就是说在只有少数（minority） Sentinel 进程正常运作的情况下， Sentinel 是不能执行自动故障迁移的。</p><p>Redis 的 Sentinel 中关于下线（down）有两个不同的概念：</p><ul><li>主观下线 指的是单个 Sentinel 实例对服务器做出的下线判断。</li><li>客观下线 指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 <code>SENTINEL is-master-down-by-addr</code> 命令互相交流之后， 得出的服务器下线判断。 （一个 Sentinel 可以通过向另一个 Sentinel 发送 <code>SENTINEL is-master-down-by-addr</code> 命令来询问对方是否认为给定的服务器已下线。）</li></ul><p>如果一个服务器没有在 <code>master-down-after-milliseconds</code> 选项所指定的时间内， 对向它发送 <a href="http://doc.redisfans.com/connection/ping.html#ping"><em>PING</em></a> 命令的 Sentinel 返回一个有效回复（valid reply）， 那么 Sentinel 就会将这个服务器标记为主观下线。</p><p>服务器对 <a href="http://doc.redisfans.com/connection/ping.html#ping"><em>PING</em></a> 命令的有效回复可以是以下三种回复的其中一种：  </p><ul><li>返回 <code>+PONG</code> 。</li><li>返回 <code>-LOADING</code> 错误。</li><li>返回 <code>-MASTERDOWN</code> 错误。</li></ul><p>如果服务器返回除以上三种回复之外的其他回复， 又或者在指定时间内没有回复 <a href="http://doc.redisfans.com/connection/ping.html#ping"><em>PING</em></a> 命令， 那么 Sentinel 认为服务器返回的回复无效（non-valid）。</p><p>注意， 一个服务器必须在 <code>master-down-after-milliseconds</code> 毫秒内， 一直返回无效回复才会被 Sentinel 标记为主观下线。</p><p>举个例子， 如果 <code>master-down-after-milliseconds</code> 选项的值为 <code>30000</code> 毫秒（<code>30</code> 秒）， 那么只要服务器能在每 <code>29</code> 秒之内返回至少一次有效回复， 这个服务器就仍然会被认为是处于正常状态的。</p><p>从主观下线状态切换到客观下线状态并没有使用严格的法定人数算法（strong quorum algorithm）， 而是使用了流言协议： 如果 Sentinel 在给定的时间范围内， 从其他 Sentinel 那里接收到了足够数量的主服务器下线报告， 那么 Sentinel 就会将主服务器的状态从主观下线改变为客观下线。 如果之后其他 Sentinel 不再报告主服务器已下线， 那么客观下线状态就会被移除。</p><p>客观下线条件<strong>只适用于主服务器</strong>： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。</p><p>只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动<strong>故障迁移</strong>操作。</p><h3 id="2-3、故障迁移"><a href="#2-3、故障迁移" class="headerlink" title="2.3、故障迁移"></a>2.3、故障迁移</h3><ul><li><strong>判定主节点故障</strong><ul><li>当多个 Sentinel 达成共识，主节点进入“客观下线”（ODOWN）状态后，触发故障转移。</li></ul></li><li><strong>纪元（Epoch）自增与 Leader 选举</strong><ul><li>纪元自增：一旦进入 ODOWN 状态，Sentinel 会将全局配置中的 <code>current-epoch</code> 加一，用作本次故障迁移的版本号。</li><li>Leader 选举：Sentinel 向同伴发送带有新纪元的选票，谁获得多数票谁就成为 leader。若选举失败，则等待 <strong>2 × 故障迁移超时时间</strong> 后，重新发起选举（纪元可再次自增或保持，取决于实现）。</li></ul></li><li><strong>提升新主节点</strong><ul><li>UPGRADE：当 leader 当选后，会在标记为合格的从节点中挑选一台，向其发送 <code>SLAVEOF NO ONE</code>（或 <code>REPLICAOF NO ONE</code>）命令，将其升级为新主节点。</li><li>配置广播：leader 通过 Sentinel 专用的 Pub&#x2F;Sub 频道，将包含新主节点地址和纪元的配置信息广播给其它 Sentinel，确保所有进程都采用同一配置。</li></ul></li><li><strong>重连剩余从节点</strong><ul><li>重新复制：Leader 向原主节点的其余从节点依次发送 <code>SLAVEOF &lt;新主节点地址&gt;</code>，让它们连接并开始同步新主节点的数据<a href="https://redis.io/docs/latest/commands/failover/?utm_source=chatgpt.com">Redis</a>。</li><li>状态监控：Leader 持续监控这些从节点的复制状态，直至所有从节点都开始接收并应用来自新主的复制流。</li></ul></li><li><strong>终止故障迁移</strong><ul><li>结束迁移：当所有从节点完成重连与同步后，leader 宣布本次故障迁移完成，并退出选举状态。</li><li>配置持久化：Sentinel 会向所有被重配置的实例发送 <code>CONFIG REWRITE</code> 命令，将最新角色和配置信息持久化到磁盘，以应对 Sentinel 重启或网络分区等场景。</li></ul></li></ul><p><strong>新主节点选择规则详解</strong></p><ol><li><strong>排除不合格从节点</strong><ul><li>主观下线或断线：凡是被标记为 SDOWN、网络连接断开，或最后一次 PING 响应超过 5 秒的从节点，均不予考虑。</li><li>长时间未连接：与故障主节点断链时长超过 <code>down-after-milliseconds × 10</code> 的从节点，也会被淘汰，避免选到与主节点过度脱节的副本。</li></ul></li><li><strong>优先复制进度</strong><ul><li>复制偏移量：在剩余候选节点中，优先选择复制偏移量（<code>replication offset</code>）最大的从节点，以最大化最新数据可用性。</li></ul></li></ol><h3 id="2-4、发布与订阅信息"><a href="#2-4、发布与订阅信息" class="headerlink" title="2.4、发布与订阅信息"></a>2.4、发布与订阅信息</h3><p>Redis Sentinel 通过内置的 Pub&#x2F;Sub 通道向客户端推送包括实例状态变化、故障迁移各阶段、配置更新等在内的丰富事件；客户端则只能以 订阅者（Subscriber）的身份使用 <code>subscribe</code> 或 <code>psubscribe</code> 命令来接收这些事件，无法向 Sentinel 发送 <code>publish</code> 消息</p><p><strong>1、客户端如何订阅 Sentinel 事件</strong></p><p>连接 Sentinel</p><ul><li>客户端可以像连接普通 Redis 那样，通过 TCP 连接到任意一个 Sentinel 进程的默认端口 <code>6379</code>。</li><li>可以在配置中指定多个 Sentinel 地址，确保在某个 Sentinel 宕机时仍能继续接收事件。</li></ul><p>订阅命令</p><ul><li><code>subscribe &lt;channel&gt; [channel ...]</code>：直接订阅一个或多个指定频道，用于精准接收特定事件。</li><li><code>psubscribe &lt;pattern&gt; [pattern ...]</code>：以模式匹配方式订阅，可使用通配符（如 <code>*</code>）一次接收多个频道事件，推荐 <code>psubscribe *</code> 用于接收 Sentinel 支持的所有事件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">接收所有 Sentinel 事件</span><br>redis-cli -p 6379 PSUBSCRIBE &quot;*&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只接收主观下线和故障切换完成事件</span><br>redis-cli -p 6379 SUBSCRIBE &quot;+sdown&quot; &quot;+switch-master&quot;<br></code></pre></td></tr></table></figure><p>收到消息的格式</p><ul><li><p>对于 <strong>普通订阅</strong>（<code>SUBSCRIBE</code>），客户端收到格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1</span>) <span class="hljs-string">&quot;message&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;&lt;channel&gt;&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;&lt;payload&gt;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>对于 <strong>模式订阅</strong>（<code>PSUBSCRIBE</code>），客户端收到格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1</span>) <span class="hljs-string">&quot;pmessage&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;&lt;pattern&gt;&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;&lt;channel&gt;&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;&lt;payload&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>&lt;payload&gt;</code> 通常包含事件名之后的参数，如实例类型、实例名、IP、端口及其对应主节点信息等</p></li></ul><hr><p><strong>2、Sentinel 在哪些频道上发布事件</strong></p><p>在 Redis Sentinel 管理主从 Redis 实例的高可用过程中，Sentinel 会通过发布事件来通知订阅者（例如 OpenResty 或其他服务）关于 Redis 实例状态变化的情况。这些事件会发布在 <strong><code>__sentinel__:hello</code></strong> 或通配模式下的频道，订阅者通常会通过 <code>psubscribe *</code> 来捕捉所有相关事件。</p><p>常见订阅事件类型</p><p><strong>1、<code>+failover-state-reconf-slave</code></strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">pmessage<span class="hljs-meta">&amp;*&amp;+failover-state-reconf-slave</span><br></code></pre></td></tr></table></figure><ul><li>含义：Sentinel 进入故障转移流程，正在将一个 slave 配置为新的 slave。</li><li>用途：过程性事件，表示 failover 正在进行中。</li></ul><hr><p><strong>2、<code>+slave-reconf-sent</code></strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pmessage</span>&amp;*&amp;+slave-reconf-sent&amp;slave <span class="hljs-number">10.10.10.10</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><ul><li>含义：通知某个从节点正在被重新配置。</li><li>用途：也属于过程性事件，表示该从节点被通知去跟随新的主节点。</li></ul><hr><p><strong>3、 <code>+config-update-from</code></strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pmessage</span>&amp;*&amp;+config-update-from&amp;sentinel <span class="hljs-number">10.10.10.10</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><ul><li>含义：从某个 Sentinel 节点接收到新的配置。</li><li>用途：Sentinel 之间同步状态信息，通常用于调协主选举结果。</li></ul><hr><p><strong>4、 <code>+switch-master</code>（最关键事件）</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pmessage</span>&amp;*&amp;+switch-master&amp;mymaster <span class="hljs-number">10.10.10.10</span> <span class="hljs-number">6379</span> <span class="hljs-number">20.20.20.20</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><ul><li>含义：主从切换完成，<code>mymaster</code> 由旧主（IP、端口）切换到了新主（IP、端口）。</li><li>用途：这是客户端需要重点处理的事件，OpenResty 正是基于该事件提取出新的主节点地址，并更新配置。</li></ul><p>3、总结</p><p>本质上</p><blockquote><p><strong>客户端只需要订阅并处理 <code>+switch-master</code> 事件，这是 Sentinel 对外暴露的“主节点切换成功”的最终确认信号。</strong></p></blockquote><ul><li>客户端只在 <code>+switch-master</code> 时提取新的主 IP&#x2F;端口；</li><li>更新内存配置；</li><li>自动切换 Redis 客户端连接；</li><li>获取 slave 列表用于下一次故障转移备用</li></ul><h2 id="3、openresty实现Redis-Sentinel-支持"><a href="#3、openresty实现Redis-Sentinel-支持" class="headerlink" title="3、openresty实现Redis Sentinel 支持"></a>3、openresty实现Redis Sentinel 支持</h2><h3 id="3-1、单进程订阅Sentinel"><a href="#3-1、单进程订阅Sentinel" class="headerlink" title="3.1、单进程订阅Sentinel"></a>3.1、单进程订阅Sentinel</h3><p><strong>1、初始化连接和订阅（只在一个 worker 进程中执行）</strong></p><p> 核心逻辑：</p><ul><li>仅由 <strong>第一个 NGINX worker 进程</strong> 执行订阅（监听哨兵事件），防止多进程重复订阅。</li><li>启动定时器回调订阅函数，针对每一个哨兵实例启动一个 Lua thread：</li><li>在 订阅函数中：<ul><li>与哨兵建立连接并发出 <code>PSUBSCRIBE *</code> 命令。</li></ul></li></ul><p><strong>主要分为2步</strong></p><ul><li>获取当前主节点</li></ul><ol><li><p>使用命令</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">SENTINEL</span> <span class="hljs-built_in">get-master-addr-by-name</span> &lt;<span class="hljs-string">master-name</span>&gt;<br></code></pre></td></tr></table></figure><p>该命令会直接返回指定主节点名称对应的 IP 和端口，无需遍历所有主实例列表。</p></li><li><p>返回格式</p><ul><li><p>成功时，回复数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1</span>) <span class="hljs-string">&quot;&lt;master-ip&gt;&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;&lt;master-port&gt;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>名称不存在时，返回空（NIL） 。</p></li></ul></li><li><p>应用场景</p><ul><li>启动时：初始化连接 Redis，即刻知道当前应连接的主节点。</li><li>重连时：网络超时或 Sentinel 重启后，重新查询以获取最新主节点。</li></ul></li></ol><hr><ul><li>订阅所有 Sentinel 事件</li></ul><ol><li><p>使用模式订阅命令</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">PSUBSCRIBE <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>以通配符 <code>*</code> 订阅 Sentinel 发布的所有频道，包括 <code>+switch-master</code>、<code>+sdown</code>、<code>+odown</code> 等</p></li><li><p>消息格式<br> 当有事件发布时，客户端会收到类似以下格式的回复：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1</span>) <span class="hljs-string">&quot;pmessage&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;&lt;pattern&gt;&quot;</span>        # 即 <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;&lt;channel&gt;&quot;</span>        # 例如 <span class="hljs-string">&quot;+switch-master&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;&lt;payload&gt;&quot;</span>        # 事件内容，如 master 名称及新旧地址<br>``` <span class="hljs-punctuation">:</span>contentReference<span class="hljs-punctuation">[</span>oaicite<span class="hljs-punctuation">:</span><span class="hljs-number">4</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#123;</span>index=<span class="hljs-number">4</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>处理逻辑</p><ul><li>客户端在回调中只需关注最关键的 <code>+switch-master</code> 事件，即主从切换完成的通知；</li><li>其他事件（如 <code>+sdown</code>、<code>+odown</code>）可用于日志监控，但不影响连接逻辑。</li></ul></li></ol><hr><p><strong>2、处理订阅的事件（监听 +switch-master）</strong></p><p> 核心逻辑：</p><ol><li><p>处理事件格式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-string">&quot;pmessage&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;+switch-master&quot;</span>, <span class="hljs-string">&quot;mymaster 10.10.10.10 6379 20.20.20.20 6379&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>识别事件类型：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-built_in">string</span>.<span class="hljs-built_in">find</span>(redis_status, <span class="hljs-string">&quot;pmessage&amp;*&amp;+switch-master&amp;&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>) == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>提取新主节点地址：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span>  <span class="hljs-comment">-- 新主IP</span><br><span class="hljs-number">6379</span>         <span class="hljs-comment">-- 新主Port</span><br></code></pre></td></tr></table></figure></li><li><p>写入共享内存：</p></li></ol><p><strong>3、主动提取 Slave 信息（从新的主节点中获得）</strong></p><p>核心逻辑：</p><ul><li><p>连接新的主节点，调用 <code>INFO replication</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis:info(<span class="hljs-string">&quot;replication&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>Redis 返回内容示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">role:master<br>connected_slaves:<span class="hljs-number">1</span><br>slave0:ip=<span class="hljs-number">10.10</span><span class="hljs-number">.10</span><span class="hljs-number">.10</span>,port=<span class="hljs-number">6379</span>,state=online,offset=...,lag=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>解析 slave IP 和端口：</p></li><li><p>将 slave 信息也写入共享配置：</p></li></ul><h3 id="3-2、work更新节点信息"><a href="#3-2、work更新节点信息" class="headerlink" title="3.2、work更新节点信息"></a>3.2、work更新节点信息</h3><p><strong>1、其他 Worker 周期性同步新配置</strong></p><ul><li><p>所有非第一个 worker 会定时读取共享内存中配置</p></li><li><p>解析 <code>server</code>、<code>port</code>、<code>slave_server</code> 等字段并更新本地配置</p></li><li><p>这确保了所有工作进程都能基于最新主节点进行连接</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">┌────────────────────<br>│    <span class="hljs-title class_">Sentinel</span> 集群   <br>└────────┬───────────<br>         │  发布事件 (+<span class="hljs-keyword">switch</span>-master)<br>         ▼<br>┌──────────────────────────<br>│  第一个 <span class="hljs-title class_">Worker</span> 订阅事件 <br>└────────┬─────────────────<br>         ▼<br>┌─────────────────────────────────────────────<br>│ <span class="hljs-attr">deal_change_for_redis</span>:                      <br>│  - 识别事件并提取主节点                         <br>│  - 调用 get_slaves_config 获取从节点           <br>│  - 更新 redis_cfg 并写入 config_dict          <br>└─────────────────────────────────────────────<br>         ▼<br>┌─────────────────────────────────────<br>│ 其他 <span class="hljs-title class_">Worker</span> 每 <span class="hljs-number">3</span> 秒拉取 redis_config <br>│ 并更新本地 redis_cfg                <br>└─────────────────────────────────────<br><br></code></pre></td></tr></table></figure><h3 id="3-3、动态域名解析"><a href="#3-3、动态域名解析" class="headerlink" title="3.3、动态域名解析"></a>3.3、动态域名解析</h3><p>在 OpenResty 中，Lua 模块本身不会在运行时调用系统的 <code>/etc/hosts</code> 或者 <code>gethostbyname</code> 接口来做域名解析。因为这是阻塞的，openresty避免在运行过程中阻塞 nginx 的 epoll 循环调用。</p><p>这意味着如果上游地址Redis使用域名，默认情况下 NGINX&#x2F;Lua 不会动态更新解析结果，而只能在配置加载阶段解析一次。为了在运行时做到非阻塞、可控、动态的域名解析，需要借助专门的 Lua DNS 客户端库，比如<a href="https://github.com/openresty/lua-resty-dns">lua-resty-dns</a></p><p>主要有2个好处</p><ul><li><strong>高可用 &amp; 灾备切换</strong><br> redis集群发生故障切换时，如果域名指向了新的 IP，需要立即生效，而非重启或 reload NGINX。</li><li><strong>性能 &amp; 非阻塞</strong><br> Lua DNS 客户端通过 cosocket 实现非阻塞查询，性能更优。</li></ul><p>实际需要在connect之前需要先解析域名，当然如果传入的是ip会直接返回，也不会存在问题。</p><h3 id="3-4、ssl双向验证"><a href="#3-4、ssl双向验证" class="headerlink" title="3.4、ssl双向验证"></a>3.4、ssl双向验证</h3><p>在某些特殊场景下，openresty连接redis时需要ssl双向验证，目前openresty和<a href="https://github.com/openresty/lua-resty-redis">lua-resty-redis</a> 已经实现了相关指令，支持openresty在lua层面与后端进行ssl双向验证的交互</p><ul><li><p><code>ssl</code></p><p>If set to true, then uses SSL to connect to redis (defaults to false).</p></li><li><p><code>ssl_verify</code></p><p>If set to true, then verifies the validity of the server SSL certificate (defaults to false). Note that you need to configure the lua_ssl_trusted_certificate to specify the CA (or server) certificate used by your redis server. You may also need to configure lua_ssl_verify_depth accordingly.</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#客户端证书</span><br><span class="hljs-attribute">lua_ssl_certificate</span> ../../cert/test.crt;<br><span class="hljs-comment">#客户端私钥</span><br><span class="hljs-attribute">lua_ssl_certificate_key</span> ../../cert/test.key;<br><span class="hljs-comment">#验证redis的证书</span><br><span class="hljs-attribute">lua_ssl_trusted_certificate</span> ../../cert/test.crt;<br></code></pre></td></tr></table></figure><p>在连接时，需要先connect，然后进行sslhandshake</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> unix <span class="hljs-keyword">then</span><br>   <span class="hljs-keyword">if</span> port_or_opts ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>         ok, err = sock:connect(host, port_or_opts)<br>         opts = port_or_opts<br>    <span class="hljs-keyword">else</span><br>         ok, err = sock:connect(host)<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>    ok, err = sock:connect(host, port_or_opts, opts)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">if</span> opts <span class="hljs-keyword">and</span> opts.ssl <span class="hljs-keyword">then</span><br>    ok, err = sock:sslhandshake(<span class="hljs-literal">false</span>, opts.server_name, opts.ssl_verify)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> ok, <span class="hljs-string">&quot;failed to do ssl handshake: &quot;</span> .. err<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="3-5、总结"><a href="#3-5、总结" class="headerlink" title="3.5、总结"></a>3.5、总结</h3><p> 1、启动阶段</p><ul><li>OpenResty 启动时进行初始化。</li><li>它会判断当前是哪个 worker 进程：<ul><li>第一个 worker：启动订阅线程，监听 Sentinel 的事件；</li><li>其他 worker：定时从共享内存中读取配置，保持配置同步。</li></ul></li></ul><hr><p> 2、Sentinel 订阅处理（只在第一个 worker 中）</p><ul><li>每个 Sentinel 都会启动一个独立的线程 <code>tread_for_sentinel</code>。</li><li>线程中调用 <code>init_for_sentinel()</code>，与 Sentinel 建立连接，并通过 <code>PSUBSCRIBE *</code> 订阅所有事件。</li><li>成功后立即获取当前主节点及从节点信息，写入共享字典 <code>config_dict</code>。</li></ul><hr><p>3、监听到主从切换事件（+switch-master）</p><ul><li>当 Sentinel 触发故障转移并完成主从切换后，会发布 <code>+switch-master</code> 事件。</li><li>模块通过 <code>deal_change_for_redis</code> 处理这个事件：<ul><li>提取新的主节点 IP 和端口；</li><li>更新 <code>redis_cfg</code>；</li><li>调用 <code>get_slaves_config</code> 从新主节点中获取从节点信息；</li><li>最后将所有更新后的信息写入共享字典。</li></ul></li></ul><hr><p>4、其他 Worker 拉取配置</p><ul><li>非订阅 worker 每 3 秒执行一次定时任务 <code>update_cfg_for_redis</code>。</li><li>从共享字典中读取最新配置，更新本地 Redis 连接参数。</li></ul><hr><p>5、实现效果</p><ul><li>响应 <code>+switch-master</code> 事件，快速感知主节点切换；</li><li>自动完成主从信息提取与缓存；</li><li>多 worker 保持配置一致，无需重启；</li><li>支持多个 Redis Sentinel、多个 Redis 主从集群。</li></ul><h2 id="4、异常场景"><a href="#4、异常场景" class="headerlink" title="4、异常场景"></a>4、异常场景</h2><p>首先来看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">redis:read_reply()<br></code></pre></td></tr></table></figure><p>它使用 <strong>OpenResty 的 cosocket API</strong>（非标准 Lua 网络模块）；</p><p>底层调用 <code>ngx.socket.tcp():receive()</code>，这个是 <strong>事件驱动的非阻塞接收</strong>；</p><p>当没有消息时，它会<strong>让出当前 Lua 协程的控制权</strong>；</p><p>NGINX 的 epoll&#x2F;kqueue 会监听这个 socket 的“可读事件”；</p><p>一旦 Redis 服务器推送消息到来，<strong>NGINX 会唤醒协程继续执行</strong>，此时 <code>read_reply()</code> 立即返回数据</p><h3 id="4-1、网络中断"><a href="#4-1、网络中断" class="headerlink" title="4.1、网络中断"></a>4.1、网络中断</h3><p>read_reply可能触发 timeout 的真实场景</p><table><thead><tr><th>网络异常场景</th><th>描述</th></tr></thead><tbody><tr><td>Sentinel 宕机</td><td>Sentinel 节点突然挂掉，客户端连接仍保持但收不到数据</td></tr><tr><td>网络不通</td><td>Redis 与 OpenResty 之间网络中断、丢包，消息丢失</td></tr><tr><td>防火墙限制</td><td>Redis 连接通了，但防火墙屏蔽了订阅消息</td></tr><tr><td>Sentinel 正常但没消息推送</td><td>短时间内没有任何主从事件（也会超时，但不是错误）</td></tr></tbody></table><p>如果不处理 <code>timeout</code>，系统就会“瞎等”而错过关键事件，最终导致连接错误或服务异常。需要让系统能自动感知异常、自动恢复连接、自动更新主节点配置，从而实现高可用。</p><p><strong>1、导致的问题</strong></p><ol><li><strong>协程会持续调用 <code>read_reply()</code>，但什么都读不到，丢失哨兵推送消息</strong></li></ol><ul><li>当 Redis Sentinel 因为某些原因长时间没有发送事件（比如网络中断或 Sentinel 重启），<code>read_reply()</code> 每次都返回 <code>&quot;timeout&quot;</code>；</li><li>如果你不处理这个错误，协程会一直空转在超时循环中，每次 sleep 一下，然后再次调用 <code>read_reply()</code>；</li><li>此时你其实已经“失联”了，但却毫无察觉。</li></ul><hr><ol start="2"><li><strong>不能发现主节点已经切换</strong></li></ol><ul><li>如果 Sentinel 在这期间发生了故障转移，而原订阅连接没有断（但也收不到新消息），你将错过 <code>+switch-master</code> 事件；</li><li>所有 Worker 仍旧使用旧主节点地址，导致业务连接失败；</li><li>简单说：主已经切了，但还连着旧主，业务报错。</li></ul><hr><ol start="3"><li><strong>无法自我恢复，必须手动介入</strong></li></ol><ul><li>如果不主动重连 Sentinel，那除非 OpenResty 被 reload 或重启，否则这个订阅协程会一直挂在“无响应”状态；</li><li>实际部署中常会遇到：主从切换发生了，但系统完全没有感知，直到业务报警或用户报错才发现问题。</li></ul><p><strong>2、解决方式</strong></p><p>当触发 timeout时</p><p>   1.重新创建 Sentinel 连接</p><ul><li>创建一个新的 Sentinel 客户端实例，获取连接对象；</li></ul><hr><ol start="2"><li>请求 Sentinel 获取主节点地址</li></ol><ul><li>使用 <code>redissent:sentinel(&quot;get-master-addr-by-name&quot;, redis_cfg.master_name)</code> 获取当前主节点的 IP 和端口；</li></ul><hr><ol start="3"><li>解析和更新配置</li></ol><ul><li>获取主从节点，更新共享内存，让work可以感知切换</li></ul><h2 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h2><p>sentinel:    <a href="http://doc.redisfans.com/topic/sentinel.html">http://doc.redisfans.com/topic/sentinel.html</a></p><p>客户端实现规范：<a href="https://redis.io/docs/latest/develop/reference/sentinel-clients/">https://redis.io/docs/latest/develop/reference/sentinel-clients/</a></p><p>lua-resty-redis：<a href="https://github.com/openresty/lua-resty-redis?tab=readme-ov-file#connect">https://github.com/openresty/lua-resty-redis?tab=readme-ov-file#connect</a></p><p>lua-nginx-module：<a href="https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate">https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>openresty</tag>
      
      <tag>redis</tag>
      
      <tag>sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NGINX 如何根据客户端协议构造并返回响应</title>
    <link href="/2025/05/15/NGINX%20%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94/"/>
    <url>/2025/05/15/NGINX%20%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="NGINX-如何根据客户端协议构造并返回响应"><a href="#NGINX-如何根据客户端协议构造并返回响应" class="headerlink" title="NGINX 如何根据客户端协议构造并返回响应"></a>NGINX 如何根据客户端协议构造并返回响应</h1><p>Nginx 向客户端返回响应时，会根据客户端使用的协议类型，构造对应格式的响应数据。为了实现这一点，Nginx 在响应阶段设置了一系列 <strong>filter（过滤器）模块</strong>，每个 filter 对应特定协议或处理职责。</p><p>当响应准备就绪后，这些 filter 会按照链式结构依次执行。Nginx 会根据请求上下文中的 <code>r</code>（<code>ngx_http_request_t</code>）结构体中的属性，判断当前客户端使用的协议，并选择是否调用某个具体的 filter：</p><ul><li>对于 HTTP&#x2F;1.1 请求，会调用 <code>ngx_http_header_filter</code> 生成 HTTP&#x2F;1.x 的响应头；</li><li>对于 HTTP&#x2F;2 请求，则会调用 <code>ngx_http_v2_header_filter</code> 来构造 HTTP&#x2F;2 格式的头部帧。</li></ul><p>这些 <code>r</code> 的属性值是在客户端连接建立并解析请求时确定的。因此，响应阶段可以据此区分协议类型，选择合适的响应构建路径。</p><p>本文的主题是：</p><blockquote><p>Nginx 是如何根据客户端所用协议，在响应阶段构造并发送符合该协议格式的响应的？</p></blockquote><p>即下图第④步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">             <br>┌────────┐        ①              ┌────────────┐       ②               ┌────────┐<br>│ <span class="hljs-title class_">Client</span> │  ⇄ protocol_xx  ⇄    │   <span class="hljs-variable constant_">NGINX</span>    │  ⇄ protocol_xx  ⇄    │  <span class="hljs-title class_">App</span>   │<br>└────────┘        ④              └────────────┘       ③               └────────┘<br>                                       ▲<br>                                       │<br>                        协议转换（protocol_xx ⇄ protocol_xx）<br><br></code></pre></td></tr></table></figure><h2 id="1、header"><a href="#1、header" class="headerlink" title="1、header"></a>1、header</h2><p>响应头构建的整体流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">请求进入 → upstream 响应返回 → 构造 headers_out<br>      ↓ <br>调用 <span class="hljs-title function_">ngx_http_send_header</span>(r)<br>      ↓<br>执行 <span class="hljs-title function_">ngx_http_top_header_filter</span>(r)<br>      ↓<br>沿 filter 链依次调用，最终由协议对应的 header_filter 完成响应头构造<br>      ↓<br>响应体通过 <span class="hljs-title function_">ngx_http_output_filter</span>(r, cl) 发送<br></code></pre></td></tr></table></figure><ul><li><code>ngx_http_send_header(r)</code> 会触发从 <code>ngx_http_top_header_filter</code> 开始的 header filter 链，每个 filter 调用下一个，直到最终的 HTTP&#x2F;1.x 或 HTTP&#x2F;2 的 header_filter 执行完毕</li><li>响应体部分则由 <code>ngx_http_output_filter(r, cl)</code> 依次经过 body filter，最终输出到客户端</li></ul><p>协议差异详解</p><table><thead><tr><th>步骤</th><th>HTTP&#x2F;1.x</th><th>HTTP&#x2F;2</th></tr></thead><tbody><tr><td><strong>协议识别</strong></td><td><code>r-&gt;http_version</code> 为 1.0&#x2F;1.1</td><td><code>r-&gt;stream</code> 非 <code>NULL</code></td></tr><tr><td><strong>最终 header_filter</strong></td><td><code>ngx_http_header_filter()</code></td><td><code>ngx_http_v2_header_filter()</code></td></tr><tr><td><strong>头部格式</strong></td><td>文本：<code>HTTP/1.1 200 OK\r\nHeader: value\r\n\r\n</code></td><td>二进制 HPACK 编码的 <code>HEADERS</code> 帧（含伪头字段）</td></tr><tr><td><strong>体部发送</strong></td><td>按块写入 socket，可使用 <code>chunked</code> 编码</td><td>通过 <code>DATA</code> 帧发送，支持流控与多路复用</td></tr><tr><td><strong>连接管理</strong></td><td>基于 <code>Connection</code>&#x2F;<code>Keep-Alive</code> 头部</td><td>内建于 HTTP&#x2F;2 的连接与流模型中</td></tr><tr><td><strong>特殊字段处理</strong></td><td><code>Transfer-Encoding: chunked</code> 等</td><td>伪头字段如 <code>:status</code>、<code>:content-type</code> 等</td></tr></tbody></table><ul><li>HTTP&#x2F;1.x 在 <code>ngx_http_header_filter()</code> 中按 RFC 7230 拼接纯文本头部，并调用写过滤器输出</li><li>HTTP&#x2F;2 则在 <code>ngx_http_v2_header_filter()</code> 中将 <code>headers_out</code> 转为 HPACK 编码，并封装为 <code>HEADERS</code> 帧发送</li></ul><p>核心代码</p><p>HTTP&#x2F;1.x 的 header filter</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_header_filter</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    <span class="hljs-comment">// 构造状态行和头部文本</span><br>    <span class="hljs-comment">// 写入 r-&gt;headers_out.headers</span><br>    <span class="hljs-keyword">return</span> ngx_http_next_header_filter(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>HTTP&#x2F;2 的 header filter</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_v2_header_filter</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    <span class="hljs-comment">// HPACK 编码 headers_out</span><br>    <span class="hljs-comment">// 封装为 HEADERS 帧发送</span><br>    <span class="hljs-keyword">return</span> ngx_http_next_header_filter(r);<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p><strong>Nginx 通过统一的 filter 链机制，在尾部根据 <code>r-&gt;http_version</code> 或 <code>r-&gt;stream</code> 判断客户端协议，选择合适的 <code>header_filter</code>（文本 vs 帧格式）构造响应头，再由 output filter 发送响应体。</strong></p></blockquote><h2 id="2、body"><a href="#2、body" class="headerlink" title="2、body"></a>2、body</h2><p>Nginx 如何根据客户端协议生成并发送响应体</p><p>整体流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_output_filter(r, body)<br>      ↓<br>执行 ngx_http_top_body_filter(r, body)<br>      ↓<br>沿 body_filter 链依次传递（如 gzip、缓存、限速 等）<br>      ↓<br>最终由协议专属的 write_filter 将数据写入连接<br></code></pre></td></tr></table></figure><hr><p>协议差异详解</p><table><thead><tr><th>步骤</th><th>HTTP&#x2F;1.x</th><th>HTTP&#x2F;2</th></tr></thead><tbody><tr><td><strong>协议识别</strong></td><td><code>r-&gt;http_version == NGX_HTTP_VERSION_11</code>（值 1001）</td><td><code>r-&gt;stream != NULL</code></td></tr><tr><td><strong>最终写入函数</strong></td><td><code>ngx_http_write_filter()</code></td><td><code>ngx_http_v2_write_filter()</code></td></tr><tr><td><strong>数据格式</strong></td><td>纯文本，可使用 <code>Content-Length</code> 或 <code>Transfer-Encoding: chunked</code></td><td>HTTP&#x2F;2 <code>DATA</code> 帧，内建流控与多路复用</td></tr><tr><td><strong>分块策略</strong></td><td>若无 <code>Content-Length</code>，自动切分为 chunked 块</td><td>自动分帧（每帧通常 ≤16 KB），由帧头声明长度</td></tr><tr><td><strong>连接管理</strong></td><td>结束时依据 <code>Connection: keep-alive</code> 决定连接是否复用</td><td>通过 <code>END_STREAM</code> 标志结束流，无需单独的 Connection 头部</td></tr><tr><td><strong>调用链入口</strong></td><td><code>ngx_http_output_filter()</code> → <code>ngx_http_write_filter()</code></td><td><code>ngx_http_output_filter()</code> → <code>ngx_http_v2_write_filter()</code></td></tr></tbody></table><hr><p>Filter 链机制</p><ol><li><strong>ngx_http_output_filter</strong><br> 统一入口，将响应体推入 body_filter 链。</li><li><strong>gzip_body_filter</strong><br> 若开启 gzip，则对数据压缩。</li><li><strong>range_body_filter</strong><br> 若是 Range 请求，则截取对应区间。</li><li><strong>chunked_body_filter</strong><br> 在 HTTP&#x2F;1.1 无 <code>Content-Length</code> 时，添加 chunked 编码。</li><li><strong>write_filter</strong><br> 最终输出：HTTP&#x2F;1.x 调用 <code>ngx_http_write_filter()</code>，HTTP&#x2F;2 则走 <code>ngx_http_v2_write_filter()</code>。</li></ol><hr><p>HTTP&#x2F;1.x 下的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_write_filter(r, chain)<br>&#123;<br>    <span class="hljs-comment">// 如果有 Content-Length，按长度写入</span><br>    <span class="hljs-comment">// 否则自动插入 chunked 头尾</span><br>    ngx_chain_writer(&amp;writer_ctx, chain);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Chunked 编码</strong>：在无明确长度时，插入 <code>&lt;len&gt;\r\n&lt;data&gt;\r\n0\r\n\r\n</code>。</li><li><strong>写入方式</strong>：通过 <code>send()</code> 或缓冲区累积后写出。</li></ul><hr><p>HTTP&#x2F;2 下的输出</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 最终写出函数</span><br><span class="hljs-built_in">ngx_http_v2_write_filter</span>(r, chain)<br>&#123;<br>    <span class="hljs-comment">// 将每个 buf 构造成 DATA 帧</span><br>    <span class="hljs-comment">// 自动分帧、设置流控窗口、标记 END_STREAM</span><br>    <span class="hljs-built_in">ngx_http_v2_send_output_queue</span>(r);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>DATA 帧</strong>：每个帧包含长度、标志位和负载，完全由 HTTP&#x2F;2 规范管理。</li><li><strong>流控和多路复用</strong>：Nginx 底层处理，不需额外编码。</li></ul><hr><blockquote><p><strong>Nginx 在输出响应体时，通过统一的 body_filter 链完成压缩、缓存、限速等处理，最后根据 <code>r-&gt;stream</code> 或 <code>r-&gt;http_version</code> 选择协议专属的 write_filter，将数据以文本或帧的形式写回客户端。</strong></p></blockquote><h2 id="3、整体响应转发流程"><a href="#3、整体响应转发流程" class="headerlink" title="3、整体响应转发流程"></a>3、整体响应转发流程</h2><h3 id="3-1-原理概述"><a href="#3-1-原理概述" class="headerlink" title="3.1 原理概述"></a>3.1 原理概述</h3><p>当 Nginx 向 upstream 发起请求后，会将该连接的读事件处理函数（通常为 <code>ngx_http_upstream_process_header()</code>）注册到事件模块（如 epoll）中。一旦 upstream 返回响应，即由事件驱动机制触发该处理函数，开始解析并处理响应。整个流程可分为：从读取 upstream 响应，到构造并发送给客户端的完整闭环。</p><hr><h3 id="3-2-详细步骤"><a href="#3-2-详细步骤" class="headerlink" title="3.2 详细步骤"></a>3.2 详细步骤</h3><h4 id="1-读取并解析-Upstream-响应"><a href="#1-读取并解析-Upstream-响应" class="headerlink" title="1. 读取并解析 Upstream 响应"></a>1. 读取并解析 Upstream 响应</h4><ol><li><strong>异步读取响应头</strong><ul><li><code>ngx_http_upstream_process_header()</code> 负责循环读取 upstream 返回的数据，直至完整解析出状态行与响应头字段；</li><li>解析结果存储在 <code>ngx_http_upstream_t</code> 的相关数据结构中。</li></ul></li><li><strong>发送响应头到下游</strong><ul><li>解析完毕后，调用 <code>ngx_http_upstream_send_response()</code>，将 upstream 头部信息填充至 <code>r-&gt;headers_out</code>；</li><li>随后调用 <code>ngx_http_send_header(r)</code>，触发 header filter 链，最终由协议对应的 header_filter 输出响应头。</li></ul></li><li><strong>读取并转发响应体</strong><ul><li>上游的响应体数据通过 <code>ngx_http_upstream_send_response()</code> 逐块传递给下游；</li><li>响应体会在 <code>ngx_http_output_filter(r, body_chain)</code> 中经过 body filter 链（gzip、限速、chunked 等），并最终由协议专属的 write_filter 写出。</li></ul></li></ol><hr><h4 id="2-通过-Filter-链发送给客户端"><a href="#2-通过-Filter-链发送给客户端" class="headerlink" title="2. 通过 Filter 链发送给客户端"></a>2. 通过 Filter 链发送给客户端</h4><ol><li><strong>发送响应头</strong><ul><li><code>ngx_http_send_header(r)</code> 检查头部是否已发送，若未发送则执行 <code>ngx_http_top_header_filter(r)</code>；</li><li>对于 HTTP&#x2F;1.x，最终调度到 <code>ngx_http_header_filter()</code>；</li><li>对于 HTTP&#x2F;2，则由 <code>ngx_http_v2_header_filter()</code> 构造 HPACK 编码的 HEADERS 帧。</li></ul></li><li><strong>发送响应体</strong><ul><li><code>ngx_http_output_filter(r, body_chain)</code> 启动 body filter 链；</li><li>经过 <code>gzip_body_filter</code>、<code>range_body_filter</code>、<code>chunked_body_filter</code> 等处理后，最终调用：<ul><li>HTTP&#x2F;1.x 情况下的 <code>ngx_http_write_filter()</code>，通过 <code>ngx_chain_writer()</code> 按需添加 chunked 编码或直接写入 socket；</li><li>HTTP&#x2F;2 情况下的 <code>ngx_http_v2_write_filter()</code>，将每个 buffer 封装为 DATA 帧，自动处理分帧及流控。</li></ul></li></ul></li></ol><hr><h4 id="3-完成请求与连接管理"><a href="#3-完成请求与连接管理" class="headerlink" title="3. 完成请求与连接管理"></a>3. 完成请求与连接管理</h4><ol><li><strong>请求终结</strong><ul><li>当所有数据传输完毕后，调用 <code>ngx_http_finalize_request(r, rc)</code>，清理请求上下文并释放资源；</li></ul></li><li><strong>连接复用或关闭</strong><ul><li>若请求使用 HTTP&#x2F;1.1 或 HTTP&#x2F;2 并且支持 Keep-Alive（或多路复用），则保持连接或流打开，等待后续请求；</li><li>若收到 <code>Connection: close</code> 指令，或 Keep-Alive 不可用，则关闭连接或流。</li></ul></li></ol><hr><blockquote><p><strong>Nginx 在整个转发过程中，通过统一的 upstream 读事件回调获取上游数据，再通过 header&#x2F;body filter 链和协议专属的 header_filter&#x2F;write_filter，完成对不同协议（HTTP&#x2F;1.x 与 HTTP&#x2F;2）响应格式的动态构建与发送。</strong></p></blockquote><h3 id="3-2、流程图"><a href="#3-2、流程图" class="headerlink" title="3.2、流程图"></a>3.2、流程图</h3><p><img src="/img/NGINX%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%B9%B6%E8%BF%94%E5%9B%9E%E5%93%8D%E5%BA%94-01.png" alt="nginx返回响应整体流程"></p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>HTTP1</tag>
      
      <tag>HTTP2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx之上下游不同协议的转换</title>
    <link href="/2025/05/10/nginx%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%B8%B8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <url>/2025/05/10/nginx%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%B8%B8%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>Nginx 主要用于实现路由和反向代理功能。在实际应用中，客户端与后端服务可能使用不同的协议，例如客户端使用 HTTP&#x2F;2，而后端仍采用 HTTP&#x2F;1.1。作为应用层（L7）代理，Nginx 会分别与客户端和后端建立独立的连接，解析、处理请求和响应，并根据目标协议格式重新构造数据后转发。</p><p>需要注意的是：<strong>无论前后端协议是否一致，Nginx 始终执行这一套“应用层重构”流程</strong>。当协议不一致时，Nginx 会根据各自的协议要求，分别构造并发送符合协议格式的请求和响应（例如，将 HTTP&#x2F;2 帧格式转换为 HTTP&#x2F;1.1 文本响应）。因此，协议格式的转换是 Nginx 转发过程中的附加处理，而不是特殊情况。</p><p>本文的关注点在于</p><blockquote><p><strong>Nginx 是如何根据upstream使用的协议，构造并发送不同格式的请求转发给后端</strong></p></blockquote><p>以及如何实现HTTP协议到私有协议的转换</p><h2 id="1、HTTP请求的生命流程"><a href="#1、HTTP请求的生命流程" class="headerlink" title="1、HTTP请求的生命流程"></a>1、HTTP请求的生命流程</h2><p>上下游的流转，本文集中于第②步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">              <br>┌────────┐        ①              ┌────────────┐       ②               ┌────────┐<br>│ <span class="hljs-title class_">Client</span> │  ⇄ protocol_xx  ⇄    │   <span class="hljs-variable constant_">NGINX</span>    │  ⇄ protocol_xx  ⇄    │  <span class="hljs-title class_">App</span>   │<br>└────────┘        ④              └────────────┘       ③               └────────┘<br>                                       ▲<br>                                       │<br>                        协议转换（protocol_xx ⇄ protocol_xx）<br><br></code></pre></td></tr></table></figure><p>对于一个http请求，work的处理流程如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript">┌────────────────────────────┐<br>│      <span class="hljs-title class_">Worker</span> <span class="hljs-title class_">Process</span> <span class="hljs-title class_">Loop</span>   │<br>│  ngx_worker_process_cycle  │<br>└────────────┬───────────────┘<br>             ↓<br>    <span class="hljs-title function_">ngx_process_events_and_timers</span>()<br>             ↓<br>      <span class="hljs-title function_">ngx_event_process_events</span>()<br>             ↓<br>        🔔 <span class="hljs-title function_">epoll_wait</span>()<br>             ↓<br>     🔌 socket 可读 (新连接)<br>             ↓<br>       <span class="hljs-title function_">ngx_event_accept</span>()<br>             ↓                 <span class="hljs-comment">//此处tcp连接建立成功</span><br>  ✅ <span class="hljs-title function_">ngx_http_init_connection</span>()<br>             ↓<br>  设置连接回调为 ngx_http_wait_request_handler<br>             ↓<br>  🔁 等待并读取请求行（<span class="hljs-variable constant_">GET</span> /...）<br>             ↓<br>  <span class="hljs-title function_">ngx_http_process_request_line</span>()<br>             ↓<br>  读取并解析请求头<br>             ↓<br>  <span class="hljs-title function_">ngx_http_process_request_headers</span>()<br>             ↓<br>  创建 ngx_http_request_t 完整结构<br>             ↓                 <span class="hljs-comment">//初步解析HTTP行与头部，创建核心结构体r</span><br>  进入阶段引擎 <span class="hljs-title function_">ngx_http_core_run_phases</span>()<br>             ↓<br>  🔍 <span class="hljs-variable constant_">NGX_HTTP_FIND_CONFIG_PHASE</span><br>  → 匹配 location，找到 proxy_pass<br>  → 设置 r-&gt;content_handler = ngx_http_proxy_handler<br>             ↓<br>  ▶ <span class="hljs-variable constant_">NGX_HTTP_REWRITE_PHASE</span> 等（可选）<br>  → 执行重写指令，如 rewrite/set/<span class="hljs-keyword">return</span> 等<br>             ↓                 <span class="hljs-comment">//rewrite阶段，处理请求的相关逻辑</span><br>  ▶ <span class="hljs-variable constant_">NGX_HTTP_CONTENT_PHASE</span><br>  → 调用 <span class="hljs-title function_">ngx_http_proxy_handler</span>(r)<br>             ↓                 <span class="hljs-comment">//确认 upstream，初始化结构体，并建立连接</span><br>  <span class="hljs-title function_">ngx_http_proxy_handler</span>()<br>             ↓<br>  <span class="hljs-title function_">ngx_http_upstream_init</span>(r)<br>    → <span class="hljs-title function_">ngx_http_upstream_connect</span>(r, u)<br>      → <span class="hljs-title function_">ngx_event_connect_peer</span>()              <span class="hljs-comment">//发起与后端的连接</span><br>      → 设置 u-&gt;write_event_handler = ngx_http_upstream_send_request_handler<br>             ↓<br>  <span class="hljs-comment">//构造并发送请求到后端（构造 Host、URI）</span><br>    → <span class="hljs-title function_">ngx_http_upstream_send_request</span>()<br>             ↓<br>  <span class="hljs-comment">//异步读取后端响应（头 + body）</span><br>    → <span class="hljs-title function_">ngx_http_upstream_process_header</span>()<br>      ↓<br>    → <span class="hljs-title function_">ngx_http_upstream_send_response</span>()       <span class="hljs-comment">//开始转发响应体</span><br>             ↓<br>  <span class="hljs-comment">//通过 output filter 输出给客户端</span><br>    → <span class="hljs-title function_">ngx_http_output_filter</span>(r, out)<br>             ↓<br>  <span class="hljs-title function_">ngx_http_finalize_request</span>()<br>             ↓<br>  <span class="hljs-comment">//可保持 keepalive 或关闭连接</span><br></code></pre></td></tr></table></figure><h2 id="2、实际的例子"><a href="#2、实际的例子" class="headerlink" title="2、实际的例子"></a>2、实际的例子</h2><p>一个实际的例子，链路如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">                <br>┌────────┐               ┌────────────┐               ┌────────┐<br>│ <span class="hljs-title class_">Client</span> │               │   <span class="hljs-variable constant_">NGINX</span>    │               │  <span class="hljs-title class_">App</span>   │<br>└────────┘               └────────────┘               └────────┘<br>    │                           │                          │<br>    │ ① 请求 (<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2</span>)                                     <br>    ├─────────────────────────▶ │                          <br>    │                                                     <br>    │                              ② 转发请求 (<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1</span>)       <br>    │                           │  ──────────────────────▶ │<br>    │                                                     <br>    │                               ③ 接收响应 (<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1</span>)      <br>    │                           │ ◀─────────────────────── │<br>    │                                                     <br>    │ ④ 返回响应 (<span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2</span>)                                   <br>    ◀─────────────────────────  │                          <br><br></code></pre></td></tr></table></figure><p>nginx的配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-comment"># HTTP2</span><br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;<br>    <span class="hljs-attribute">server_name</span> ZJfans.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span>     /path/to/fullchain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /path/to/privkey.pem;<br><br>    <span class="hljs-attribute">ssl_protocols</span>       TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">ssl_ciphers</span>         HIGH:!aNULL:!MD5;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend_app;<br><br>        <span class="hljs-comment"># HTTP1.1</span><br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对于客户端，根据第1节的处理流程来看，nginx在ngx_http_wait_request_handler函数中，会根据HTTP协议版本的不同，进行不同处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HTTP_V2)</span><br><br>    h2scf = ngx_http_get_module_srv_conf(hc-&gt;conf_ctx, ngx_http_v2_module);<br><br>    <span class="hljs-keyword">if</span> (!hc-&gt;ssl &amp;&amp; (h2scf-&gt;enable || hc-&gt;addr_conf-&gt;http2)) &#123;     <span class="hljs-comment">//h2scf-&gt;enable端口开启HTTP2的标识 </span><br><br>        size = ngx_min(<span class="hljs-keyword">sizeof</span>(NGX_HTTP_V2_PREFACE) - <span class="hljs-number">1</span>,<br>                       (<span class="hljs-type">size_t</span>) (b-&gt;last - b-&gt;pos));<br><br>        <span class="hljs-keyword">if</span> (ngx_memcmp(b-&gt;pos, NGX_HTTP_V2_PREFACE, size) == <span class="hljs-number">0</span>) &#123;<br><br>            <span class="hljs-keyword">if</span> (size == <span class="hljs-keyword">sizeof</span>(NGX_HTTP_V2_PREFACE) - <span class="hljs-number">1</span>) &#123;<br>                ngx_http_v2_init(rev);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            ngx_post_event(rev, &amp;ngx_posted_events);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>这其实是处理HTTP的入口，之后会根据协议的不同，设置一系列的回调。</p><p>对于upstream，在NGX_HTTP_CONTENT_PHASE确定相关协议，其实proxy_pass这个指令只是做HTTP1.0&#x2F;1.1的转发，使用proxy_http_version可以指定具体版本</p><table><thead><tr><th>协议</th><th>指令</th><th>处理函数</th></tr></thead><tbody><tr><td>HTTP1.0&#x2F;1.1</td><td>proxy_pass</td><td>ngx_http_proxy_handler</td></tr><tr><td>HTTP2</td><td>grpc_pass</td><td>ngx_http_grpc_pass</td></tr><tr><td>websocket</td><td>proxy_pass<br>(proxy_set_header Upgrade $http_upgrade;<br>proxy_set_header Connection “Upgrade”;)</td><td>ngx_http_upstream_upgrade</td></tr></tbody></table><p>所以客户端和upstream是隔离的，但是都可以在r中取到相关的数据，r包含了一个请求生命周期的所有数据，对于写代码很友好。当然上下游数据格式是不一样的，nginx会将读取到的二进制数据封装为对应协议的格式，然后进行转发。</p><p>但是实际websocket又会不一样，类似TCP层面的转发，按照websocket的协议规范，客户端发送的数据必须使用掩码（masking），所以如果代理节点进行解码貌似也是一个破坏性的行为。</p><h2 id="3、实现HTTP私有协议的路由转换"><a href="#3、实现HTTP私有协议的路由转换" class="headerlink" title="3、实现HTTP&lt;-&gt;私有协议的路由转换"></a>3、实现HTTP&lt;-&gt;私有协议的路由转换</h2><p>在微服务架构中，HTTP 是广泛采用的通用协议，但为了满足特定业务需求或提升性能，会采用自定义的私有协议。对于我们的早期业务而言，只存在2种私有协议，随着微服务体系的接入，需要支持HTTP协议。</p><p>Nginx 原生支持同协议之间的代理（如 HTTP 到 HTTP、TCP 到 TCP），但如果需要实现 <strong>HTTP 到私有协议</strong> 的转换，便需引入一些定制逻辑。</p><p>事实上，实现此目标的主要流程可分为以下四步：</p><ol><li>根据http请求的uri&#x2F;参数&#x2F;头部确认是哪个upstream</li><li>将http的uri、参数、头部、body转换为私有协议规范</li><li>初始化upstream，接入到私有协议模块处理，进行交互</li><li>判断客户端协议，将数据转换为HTTP协议格式，然后交由http框架处理与客户端的交互</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">HTTP 请求 -&gt; [ 路由规则 -&gt; upstream 确定 -&gt; 请求数据转私有协议 -&gt; upstream 通信 -&gt; 响应转 HTTP ] -&gt; 返回客户端<br></code></pre></td></tr></table></figure><h3 id="3-1、根据-HTTP-请求确认目标-upstream"><a href="#3-1、根据-HTTP-请求确认目标-upstream" class="headerlink" title="3.1、根据 HTTP 请求确认目标 upstream"></a>3.1、根据 HTTP 请求确认目标 upstream</h3><p>当一个 HTTP 请求进入 Nginx，我们需要依据请求内容（如 URI、参数、Header 等）确定应该路由到哪个 upstream。这一步实际上是一个“请求路由判定”过程。</p><p><strong>基本思路：</strong></p><ul><li>定义一个内部变量 <code>$upstream_name</code>，其值由请求参数经过一定规则匹配后动态生成；</li><li>在 <code>proxy_pass</code> 中使用该变量完成请求转发：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">proxy_pass $upstream_name;<br></code></pre></td></tr></table></figure><p><strong>执行时机：</strong></p><p>在 Nginx 中，<code>proxy_pass</code> 的执行发生在 <strong>content phase</strong> 阶段，因此 <code>$upstream_name</code> 变量也会在此阶段被求值。Nginx 在处理 HTTP 请求时，会依次执行注册到 <code>NGX_HTTP_CONTENT_PHASE</code> 阶段的模块，<code>ngx_http_proxy_handler</code> 是其中之一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span> <span class="hljs-title function_">ngx_http_proxy_handler</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span>;<br></code></pre></td></tr></table></figure><p>该函数又调用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span> <span class="hljs-title function_">ngx_http_proxy_eval</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">                                     <span class="hljs-type">ngx_http_proxy_ctx_t</span> *ctx,</span><br><span class="hljs-params">                                     <span class="hljs-type">ngx_http_proxy_loc_conf_t</span> *plcf)</span>;<br></code></pre></td></tr></table></figure><p>核心逻辑是：<strong>在这里解析 <code>$upstream_name</code> 的值</strong>，也就是实际为当前请求分配 upstream 地址的地方。</p><p><strong>自定义逻辑：</strong></p><p>可以在 <code>$upstream_name</code> 的计算逻辑中嵌入业务自定义的路由规则，根据 URI、参数等信息选择合适的 upstream。</p><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs nginx">http接入 - uri：<br>a/<span class="hljs-attribute">xxx</span>   -&gt;    http_xxx_001<br>b/xxx   -&gt;    protocol_1_xxx_001<br>b/xxx   -&gt;    protocol_2_xxx_001<br><br>upstream http_xxx_001 &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.1:7000</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.2:7000</span>;<br>&#125;<br><br><span class="hljs-section">upstream</span> protocol_1_xxx_001 &#123;<br>    protocol_1;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.1.1:8000</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.1.2:8000</span>;<br>&#125;<br><br><span class="hljs-section">upstream</span> protocol_2_xxx_001 &#123;<br>    protocol_2;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.1.1:9000</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.1.2:9000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上只要确认upstream，就可以确认是什么协议。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </p><h3 id="3-2、HTTP-到私有协议的转换"><a href="#3-2、HTTP-到私有协议的转换" class="headerlink" title="3.2、HTTP 到私有协议的转换"></a>3.2、HTTP 到私有协议的转换</h3><p>确定了 upstream + 协议后，Nginx 需要将标准的 HTTP 请求数据转换为私有协议格式，这一步称为<strong>协议转换</strong>。</p><p><strong>内容包括：</strong></p><ul><li>将 URI、Query 参数、Headers、Body 数据按协议格式封装；</li><li>可能涉及字段编码、数据压缩等；</li><li>考虑不同类型请求（GET、POST 等）如何转换；</li><li>保证转换结果符合目标私有协议规范。</li></ul><p><strong>实现：</strong></p><ul><li>自定义一个模块挂在 content phase，作为 proxy 前置处理器；</li><li>使用模块内部逻辑，将 <code>r-&gt;headers_in</code> 和 <code>r-&gt;request_body</code> 构造成特定的 buffer；</li><li>传入私有协议模块处理。</li></ul><p>从实际来看，设计一个高可用、高可靠的协议难度很大，又要满足各种场景，又要可靠，还要性能更好一些（很遗憾，我们的协议并没有HTTP2的性能好，场景也缺失一些）。</p><p>协议归根结底是一种信息交换的规则，对话双方遵守同一种规则，就可以交换信息，类似于英语和汉语等等，也类似于编程语言？本质上就是人与机器做交互。从实际的实现看，设计的难度远远大于实现。</p><h3 id="3-3、与upstream交互"><a href="#3-3、与upstream交互" class="headerlink" title="3.3、与upstream交互"></a>3.3、与upstream交互</h3><ol><li><p>数据封装完毕，下一步是将构造好的私有协议请求通过 Nginx upstream 机制发送到后端服务，并接收响应。</p><p>核心流程如下：</p><ol><li><strong>选择合适的 server 节点</strong><br>通常upstream代表一个集群，其中会有大于等于1个节点，因此还需要根据负载算法，找到具体的server节点，支持轮询、hash、最小连接数等多种负载均衡算法</li><li><strong>发送封装后的请求数据</strong><br> 按协议定义的格式准确填充 buffer。</li><li><strong>异步接收 upstream 的响应数据</strong><br> 与 HTTP upstream 模块类似，需注册读事件处理响应内容</li></ol><p>事实上这一部分只借用已有模块即可</p></li></ol><h3 id="3-4、返回响应到客户端"><a href="#3-4、返回响应到客户端" class="headerlink" title="3.4、返回响应到客户端"></a>3.4、返回响应到客户端</h3><p>正常HTTP协议的upstream事件处理函数是读取响应头、响应body，然后再发送到客户端，依次注册回调函数。这里也类似，与upstream 通信完成后，Nginx 需要将私有协议格式的响应内容转换为 HTTP 响应返回给客户端。</p><p>常见处理逻辑：</p><ul><li>设置 HTTP 状态码、响应头部（如 <code>Content-Type</code>、<code>Content-Length</code>）；</li><li>将私有协议响应体解码、转码成 JSON、HTML、纯文本等 HTTP 能识别的格式；</li><li>调用 <code>ngx_http_send_header</code>、<code>ngx_http_output_filter</code> 等函数将内容写回客户端。</li></ul><p>这里需要读取响应后，做对应协议的格式转换，即转换为HTTP协议的数据格式（本质就是提取包含信息的数据，例如body、header、args这些，私有协议也有对应的规则）。然后交由http的框架处理与客户端交互，实际上nginx采用了过滤器的机制，根据客户端的协议，触发对应的过滤器模块，然后返回给客户端。</p><p>到此，这就是一个完整的由http接入的请求，经过nginx转发到私有协议的处理过程。</p><h2 id="4、nginx的内部变量原理"><a href="#4、nginx的内部变量原理" class="headerlink" title="4、nginx的内部变量原理"></a>4、nginx的内部变量原理</h2><p>在 Nginx 中，<strong>内部变量</strong>（如 <code>$host</code>、<code>$uri</code>、<code>$args</code>、自定义变量等）是模块之间进行数据传递和动态配置的重要机制。理解其原理，有助于灵活实现如动态 <code>proxy_pass</code>、请求路由、协议转换等高级功能。</p><hr><h3 id="4-1、内部变量的作用"><a href="#4-1、内部变量的作用" class="headerlink" title="4.1、内部变量的作用"></a>4.1、内部变量的作用</h3><p>内部变量是 Nginx 配置文件中通过 <code>$</code> 前缀引用的动态值。这些变量：</p><ul><li>可在配置中被引用（如 <code>proxy_pass $upstream_name</code>）；</li><li>可在模块中被赋值或获取；</li><li>可被多个模块共享、传递；</li><li>支持动态求值（如基于请求上下文的信息实时生成值）。</li></ul><hr><h3 id="4-2、变量的定义与注册"><a href="#4-2、变量的定义与注册" class="headerlink" title="4.2、变量的定义与注册"></a>4.2、变量的定义与注册</h3><p>Nginx 的变量机制由 <code>ngx_http_variables_module</code> 提供支持。每一个变量都通过一个 <code>ngx_http_variable_t</code> 结构体注册，其结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_str_t</span> name;<br>    ngx_http_set_variable_pt set_handler;<br>    ngx_http_get_variable_pt get_handler;<br>    <span class="hljs-type">uintptr_t</span> data;<br>    <span class="hljs-type">ngx_uint_t</span> flags;<br>&#125; <span class="hljs-type">ngx_http_variable_t</span>;<br></code></pre></td></tr></table></figure><ul><li><code>name</code>: 变量名，例如 <code>upstream_name</code>；</li><li><code>get_handler</code>: 获取变量值时调用的函数；</li><li><code>set_handler</code>: 设置变量值时调用的函数；</li><li><code>data</code>: 附加数据，通常为索引或上下文参数；</li><li><code>flags</code>: 控制是否缓存、是否可设置等属性。</li></ul><p>注册变量的方式：</p><p>在模块的 <code>postconfiguration</code> 回调中，调用如下方法注册变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_http_variable_t</span> *var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE);<br>var-&gt;get_handler = my_get_variable;<br></code></pre></td></tr></table></figure><hr><h3 id="4-3、变量值的获取时机"><a href="#4-3、变量值的获取时机" class="headerlink" title="4.3、变量值的获取时机"></a>4.3、变量值的获取时机</h3><p>Nginx 在处理请求时，会根据执行阶段和上下文动态求值变量：</p><ul><li>在某些阶段（如 rewrite、access、content），变量会被第一次引用时动态求值；</li><li>如果设置了缓存标志，变量的值会被计算一次后缓存；</li><li>某些变量可能依赖于请求内容（如 body），需要确保值可用时再引用。</li></ul><p>比如在 <code>proxy_pass $upstream_name;</code> 中，变量 <code>$upstream_name</code> 会在 content phase 阶段由 <code>ngx_http_proxy_eval</code> 调用变量系统求值。</p><hr><h3 id="4-4、自定义变量"><a href="#4-4、自定义变量" class="headerlink" title="4.4、自定义变量"></a>4.4、自定义变量</h3><p>在 Nginx 中通过 C 模块定义和使用内部变量：</p><p>一、自定义变量的注册</p><p>在模块的 <code>postconfiguration</code> 函数中注册变量，使用 <code>ngx_http_add_variable</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_xxx_module_postconfiguration</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf)</span> &#123;<br>    <span class="hljs-type">ngx_str_t</span> name = ngx_string(<span class="hljs-string">&quot;upstream_name&quot;</span>);<br>    <span class="hljs-type">ngx_http_variable_t</span> *var = ngx_http_add_variable(cf, &amp;name, NGX_HTTP_VAR_CHANGEABLE);<br>    <span class="hljs-keyword">if</span> (var == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br>    var-&gt;get_handler = ngx_http_my_variable_get;<br>    var-&gt;data = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>NGX_HTTP_VAR_CHANGEABLE</code>：表示变量值可被动态设置；</li><li><code>get_handler</code>：指定变量的获取逻辑函数；</li><li><code>data</code>：传递给 handler 的附加信息。</li></ul><hr><p>二、自定义变量的取值函数（get_handler）</p><p>变量的值由 <code>get_handler</code> 实现，它会在变量首次被引用时调用，并返回一个 <code>ngx_http_variable_value_t</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_proxy_handler<br>    -&gt;ngx_http_proxy_eval<br>    -&gt;ngx_http_script_run<br>    -&gt; ngx_http_script_copy_var_len_code (code((<span class="hljs-type">ngx_http_script_engine_t</span> *) &amp;e);)<br>    -&gt; ngx_http_get_indexed_variable<br>    -&gt;ngx_http_my_variable_get<br></code></pre></td></tr></table></figure><p>自定义的变量赋值函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_my_variable_get</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">                         <span class="hljs-type">ngx_http_variable_value_t</span> *v,</span><br><span class="hljs-params">                         <span class="hljs-type">uintptr_t</span> data)</span><br>&#123;<br>    <span class="hljs-type">ngx_str_t</span> upstream = ngx_string(<span class="hljs-string">&quot;http://backend_default&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (ngx_strncmp(r-&gt;uri.data, <span class="hljs-string">&quot;/api&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>        upstream = ngx_string(<span class="hljs-string">&quot;http://backend_api&quot;</span>);<br>    &#125;<br><br>    v-&gt;len = upstream.len;<br>    v-&gt;valid = <span class="hljs-number">1</span>;<br>    v-&gt;no_cacheable = <span class="hljs-number">0</span>;<br>    v-&gt;not_found = <span class="hljs-number">0</span>;<br>    v-&gt;data = upstream.data;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li><code>r-&gt;uri.data</code> 是当前请求的 URI；</li><li>根据 URI 判断要转发到哪个 upstream；</li><li>返回的 <code>v-&gt;data</code> 即 <code>$upstream_name</code> 的值。</li></ul><hr><p>三、在配置中使用自定义变量</p><p>一旦注册成功，就可以在 <code>nginx.conf</code> 中通过 <code>$upstream_name</code> 使用：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_pass</span> <span class="hljs-variable">$upstream_name</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 在执行 <code>proxy_pass</code> 时，会自动调用自定义的 <code>get_handler</code> 获取实际的 upstream 地址，从而完成 <strong>基于请求内容的动态转发</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>websocket</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务自动发现</title>
    <link href="/2025/04/19/%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0/"/>
    <url>/2025/04/19/%E6%9C%8D%E5%8A%A1%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>Nginx 采用 master–worker 多进程模型，其中 master 进程负责管理和信号交互，worker 进程执行网络 I&#x2F;O、定时器和延迟队列事件循环 。</p><h2 id="1、nginx的原理"><a href="#1、nginx的原理" class="headerlink" title="1、nginx的原理"></a>1、nginx的原理</h2><h3 id="1-1、配置解析与端口初始化"><a href="#1-1、配置解析与端口初始化" class="headerlink" title="1.1、配置解析与端口初始化"></a>1.1、配置解析与端口初始化</h3><p>1 Master 进程：解析配置与打开监听端口</p><ul><li><strong>配置解析</strong>：在 <code>main()</code> 中，master 进程首先调用 <code>ngx_init_cycle()</code>，该函数基于 <code>ngx_conf_parse()</code> 逐行读取并解析 <code>nginx.conf</code>，生成模块级的配置上下文（<code>cycle-&gt;conf_ctx</code>）</li><li><strong>构建 listening 数组</strong>：解析阶段，core 模块会为每个 <code>listen</code> 指令创建一个 <code>ngx_listening_t</code> 结构，并将其添加到 <code>cycle-&gt;listening</code> 数组中</li><li><strong>打开套接字</strong>：随后，master 调用 <code>ngx_open_listening_sockets()</code>，遍历 <code>cycle-&gt;listening</code>：为每个条目创建 socket（<code>socket()</code>）、绑定地址（<code>bind()</code>）并监听（<code>listen()</code>），同时设置常用选项（如 <code>reuseport</code>、<code>backlog</code>）</li><li><strong>继承老进程 socket</strong>：若为平滑重启，通过 <code>ngx_add_inherited_sockets()</code> 从环境变量获取老进程的 socket 描述符，避免中断服务 。</li></ul><p>2 Worker 进程：继承与初始化</p><ul><li><strong>Fork 产生</strong>：master 通过 <code>ngx_start_worker_processes()</code> 调用 <code>ngx_spawn_process()</code> fork 出多个 worker，继承 master 打开的所有监听 socket 。</li><li><strong>初始化调用</strong>：每个 worker 在 <code>ngx_worker_process_cycle()</code> 开始时调用 <code>ngx_worker_process_init()</code> 完成：设置进程类型标识、进程标题、初始化日志、事件模块、定时器与延迟队列，并为业务端口注册可读&#x2F;可写事件回调。</li><li><strong>不再 bind&#x2F;listen</strong>：worker 直接使用继承自 master 的 socket，无需再次调用 <code>bind()</code> 或 <code>listen()</code>，确保端口监听唯一由 master 或平滑重启过程中创建一次 。</li></ul><h3 id="1-2、for循环工作原理"><a href="#1-2、for循环工作原理" class="headerlink" title="1.2、for循环工作原理"></a>1.2、for循环工作原理</h3><p>work只处理3种事件</p><p>1、网络IO事件（读写、新连接）</p><p>2、定时器</p><p>3、延迟队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_worker_process_cycle</span><span class="hljs-params">(<span class="hljs-type">ngx_cycle_t</span> *cycle, <span class="hljs-type">void</span> *data)</span><br>&#123;<br>    <span class="hljs-type">ngx_int_t</span> worker = (<span class="hljs-type">intptr_t</span>) data;<br><br>    ngx_process = NGX_PROCESS_WORKER;<br>    <span class="hljs-comment">// 记录当前工作进程的编号</span><br>    ngx_worker = worker;<br>    <br>    <span class="hljs-comment">// 初始化工作进程，实际可以修改进程的相关配置</span><br>    ngx_worker_process_init(cycle, worker);<br>    <br>    <span class="hljs-comment">////////////实际这里可以根据进程编号，设置名称</span><br>    ngx_setproctitle(<span class="hljs-string">&quot;worker process&quot;</span>);<br><br>    <span class="hljs-comment">// 进入无限循环，处理工作进程的各种事件</span><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        <span class="hljs-keyword">if</span> (ngx_exiting) &#123;<br>            <span class="hljs-keyword">if</span> (ngx_event_no_timers_left() == NGX_OK) &#123;<br>                ngx_log_error(NGX_LOG_NOTICE, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;exiting&quot;</span>);<br>                ngx_worker_process_exit(cycle);<br>            &#125;<br>        &#125;<br>        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;worker cycle&quot;</span>);<br><br>        <span class="hljs-comment">// 处理事件和定时器</span><br>        ngx_process_events_and_timers(cycle);<br> <span class="hljs-comment">//.................................</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的处理：ngx_process_events_and_timers</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_process_events_and_timers(<span class="hljs-type">ngx_cycle_t</span> *cycle)<br>&#123;<br>    <span class="hljs-comment">//.........................</span><br>    <span class="hljs-comment">//判断进程是否启用了accept锁，很关键</span><br>    <span class="hljs-keyword">if</span> (ngx_use_accept_mutex) &#123;<br>        <span class="hljs-keyword">if</span> (ngx_accept_disabled &gt; <span class="hljs-number">0</span>) &#123;<br>            ngx_accept_disabled--;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 尝试获取接受互斥锁</span><br>            <span class="hljs-comment">//!!!这个函数虽然叫这个，实际里面做了accept，如果抢到锁，那就把打开的socket，都放入自己的事件循环里面，一般就是epoll_ctl</span><br>            <span class="hljs-keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//.............................................</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//.....................................</span><br>    <br>    delta = ngx_current_msec;<br><br>    <span class="hljs-comment">// 调用底层事件处理函数处理事件</span><br>    (<span class="hljs-type">void</span>) ngx_process_events(cycle, timer, flags);<br><br>    <span class="hljs-comment">// 计算事件处理所花费的时间</span><br>    delta = ngx_current_msec - delta;<br><br>    <span class="hljs-comment">// 处理发布的接受事件</span><br>    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);<br><br>    <span class="hljs-comment">// 如果持有接受互斥锁，则释放互斥锁</span><br>    <span class="hljs-keyword">if</span> (ngx_accept_mutex_held) &#123;<br>        ngx_shmtx_unlock(&amp;ngx_accept_mutex);<br>    &#125;<br><br>    <span class="hljs-comment">// 过期并处理超时的定时器事件</span><br>    ngx_event_expire_timers();<br><br>    <span class="hljs-comment">// 处理发布的普通事件</span><br>    ngx_event_process_posted(cycle, &amp;ngx_posted_events);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">循环开始<br>   |<br>   |-- <span class="hljs-title function_">ngx_process_events</span>()         &lt;- epoll_wait 等待事件<br>   |       |-- 已有连接的读写事件：直接调用 handler（如 ngx_http_process_request）<br>   |       |-- 新连接事件（accept） -&gt; post 到 ngx_posted_accept_events<br>   |<br>   |-- <span class="hljs-title function_">ngx_event_process_posted</span>(&amp;ngx_posted_accept_events)   &lt;- 执行 accept<br>   |<br>   |-- 释放锁<br>   |<br>   |-- <span class="hljs-title function_">ngx_event_expire_timers</span>()     &lt;- 红黑树定时器<br>   |       |-- 超时事件 -&gt; post 到 ngx_posted_events<br>   |<br>   |-- <span class="hljs-title function_">ngx_event_process_posted</span>(&amp;ngx_posted_events)          &lt;- 执行普通延迟事件<br>循环结束<br></code></pre></td></tr></table></figure><h2 id="2、与zookeeper的交互"><a href="#2、与zookeeper的交互" class="headerlink" title="2、与zookeeper的交互"></a>2、与zookeeper的交互</h2><p>为了支持与 ZooKeeper 的动态配置交互，单 Worker 直连 ZooKeeper进行配置变更，多进程通过共享内存同步配置，但是会阻塞这个work处理其他事件，影响服务可用性与性。</p><h3 id="2-1、-原始模式架构"><a href="#2-1、-原始模式架构" class="headerlink" title="2.1、 原始模式架构"></a>2.1、 原始模式架构</h3><p>早期架构中采用如下方案：</p><p>（1）单 Worker 负责注册 Watcher 与更新配置</p><ul><li>所有 Worker 中仅有一个被选定（编号为0）连接 ZooKeeper；</li><li>该 Worker 注册 Watcher，并监听配置中心的变更事件；</li><li>当监听到变更后，直接将最新配置写入本地文件，并通过共享内存设置一个“配置更新标志位”，实际为版本号。</li></ul><p>（2）其他 Worker 通过轮询方式感知并应用配置</p><ul><li>其他 Worker 启动定时器，定期比对本地进程内存和共享内存中的版本号是否一致；</li><li>一旦发现不一致，抢锁，然后读取配置文件，加载新配置并完成本地内存更新；</li><li>更新完成后，版本号修改为一致，释放锁。</li></ul><p>（3）不足：</p><ul><li>单个 Worker 除了负责网络事件、限流、负载均衡等核心逻辑，还需要连接 ZooKeeper、监听节点变更、处理推送等操作；一旦配置发生变化，该进程还要执行本地配置文件的写入和内存更新；这些操作<strong>会阻塞事件循环</strong>，延迟请求响应，导致实际服务性能下降，尤其在高并发场景下更加明显。</li><li>每个 Worker 都需要包含 ZooKeeper 连接管理、会话重连、Watcher 重订阅、异常恢复等完整流程；这些逻辑与原有的业务处理无关，但会侵入 Worker 的主循环结构，<strong>增加维护成本与出错风险</strong>；</li><li>变更配置后，单个Worker 负责将数据写入本地配置文件，其它 Worker 则轮询共享内存标志后读取该文件，由于竞争关系需要加锁，work串行更新配置；同时读取文件的效率低下</li></ul><h3 id="2-新模式设计：引入-0-号-manage-进程"><a href="#2-新模式设计：引入-0-号-manage-进程" class="headerlink" title="2. 新模式设计：引入 0 号 manage 进程"></a>2. 新模式设计：引入 0 号 manage 进程</h3><h4 id="1、优化点"><a href="#1、优化点" class="headerlink" title="1、优化点"></a>1、优化点</h4><ul><li>将与 ZooKeeper 交互、动态配置管理等耗时操作与网络 I&#x2F;O 分离，减轻 worker 负担，简化逻辑</li><li>避免单个 worker 因配置更新而阻塞服务，有助于提高整体吞吐与可用性。</li><li>配置更新后存入共享内存，work从内存读取数据，而不是读文件，提高更新效率</li><li>使用读写锁，work可以进行并行更新</li></ul><h4 id="2、设计方案"><a href="#2、设计方案" class="headerlink" title="2、设计方案"></a>2、设计方案</h4><p>1、主体目标</p><ul><li>新增一个manage进程，只处理配置更新，包括注册中心的配置更新、热更新、与redis哨兵、rabbitMq的订阅消息，不处理实际的客户端请求</li><li>work专注于业务请求</li></ul><p>2、详细设计</p><p><strong>进程定位与初始化</strong></p><ul><li>如果不是single模式，额外加一个work进程，然后修改进程名称为manage，即解析 <code>&quot;worker_processes&quot;</code> 时，如果为 <code>auto</code> 或数量 &gt;1，则额外创建一个编号为 0 的 manage 进程，实际<code>&quot;worker_processes&quot;</code> 加1就可以</li><li>manage进程不监听业务端口，即不处理客户端的请求-响应，只做配置更新，初始化时需要关闭业务端口，同时也<strong>需要不启用accept锁</strong></li><li>考虑到还有热更新的功能，新增一个”管理端口”，manage只监听这个端口，客户端可以调用这个接口做部分配置更新，同时work不需要监听这个端口，初始化时关闭</li></ul><p><strong>功能层面的设计</strong></p><ul><li><p>manage向 ZooKeeper 注册 watcher，同时创建5s定时器，扫描与zookeeper的数据交互结构体是否变更，如果有变更，说明有zookeeper的配置更新推送，开始获取数据更新到本地内存、共享内存、本地文件。</p></li><li><p>work创建2s定时器，扫描共享内存配置<strong>主版本号</strong>，针对功能的不同，再细化为功能版本号，比如路由版本号、流控版本号、访问控制版本号，这样主版本号发生变化时，获取更细致的功能配置变更，进行增量更新，抛弃原有的全量更新模式</p></li><li><p>在lua层面，由manage进程处理redis哨兵、rabbitMq的推送消息，处理节点变更以及实际的业务数据变更</p></li></ul><p><strong>竞争关系-锁</strong></p><p>很明显会发生一些竞争关系，比如work正在读取共享内存的新配置时，如果manage再次更新，那就会发生异常，需要上锁</p><ul><li><p>创建进程级别的共享锁，manage在更新配置时，禁止work读取，也就是work在更新配置时，需要先获取锁。这样的话，work是串行更新，因为拿到锁的才能更新内存中的配置，最好的场景是，manage更新时，work禁止更新，但是所有的work可以同时更新</p></li><li><p>实际可以使用读写锁ngx_rwlock_rlock，写时不可读，读时不可写，但是可以一起读，这样work可以并行更新配置</p></li><li><p>manage还处理热更新，这其实是调用式触发，主动模式，原理一致，即接收客户端的数据，更新本地内存、共享内存、本地文件，然后修改共享内存的标识。对于热更新，还需要更新zookeeper的配置，满足集群多节点的配置同步更新。</p></li></ul><p><strong>异常场景</strong></p><ul><li>watcher连续推送。manage进程更新完配置后，会将标志位恢复，然后重新创建定时器进行扫描标志位，如果manage进程正在更新配置（更新部分），此时又有watcher消息推送，manage接着更新完配置恢复了标志位，就会丢失这期间所有的变更推送。加锁解决不了这种竞争关系，新增updating标志位，标识更新期间再次发生更新，配置更新完毕后，不恢复更新标志位，等待下一个定时器再次触发</li></ul><h4 id="3、方案实现"><a href="#3、方案实现" class="headerlink" title="3、方案实现"></a>3、方案实现</h4><p>所有配置统一在 master 解析完成后共享，子进程（worker&#x2F;manage）在 init 阶段根据端口属性决定是否关闭 socket，并根据是否为 manage 调整是否参与 accept 竞争</p><ol><li><strong>进程结构调整</strong></li></ol><ul><li>如果不是 <code>single</code> 模式，且 <code>&quot;worker_processes&quot;</code> 为 <code>auto</code> 或 &gt; 1：<ul><li>实际创建 <code>N + 1</code> 个进程：<code>manage</code> + <code>N</code> 个 <code>worker</code></li><li><code>manage</code> 进程编号固定为 <code>0</code>，进程名修改为 <code>&quot;manage process&quot;</code></li></ul></li></ul><ol start="2"><li><strong>端口绑定策略</strong></li></ol><ul><li>所有进程都共享 <code>master</code> 解析好的配置，监听 socket 初始化在 master 完成</li><li>每个进程初始化时，<strong>根据端口的 <code>server_name.manage_server</code> 字段来判断要不要关闭该 fd</strong></li><li>每个进程都只会将应该处理的端口，加入自己的事件循环，（抢到锁的work）并执行 <code>accept()</code></li></ul><table><thead><tr><th>端口</th><th>manage 进程</th><th>worker 进程</th></tr></thead><tbody><tr><td><code>manage_server=1</code>（管理端口）</td><td>保留</td><td>关闭</td></tr><tr><td><code>manage_server=0</code>（业务端口）</td><td>关闭</td><td>保留</td></tr></tbody></table><ol start="3"><li><strong>accept_mutex 设置</strong></li></ol><ul><li>初始化阶段，若当前是 <code>manage</code> 进程：<ul><li>设置 <code>ngx_use_accept_mutex = 0</code>，不参与锁竞争（manage进程监听自己的端口，没有竞争关系）</li></ul></li></ul><ol start="4"><li><strong>配置解析阶段</strong></li></ol><ul><li><code>server</code> 块中增加一个布尔字段 <code>manage_server</code></li><li><code>ngx_http_core_srv_conf_t</code> 等结构体中加入该字段</li><li>master 解析配置时不做分支判断，所有进程继承同一份配置</li></ul><h4 id="4-分布式锁机制"><a href="#4-分布式锁机制" class="headerlink" title="4. 分布式锁机制"></a>4. 分布式锁机制</h4><p>4.1 锁的必要性</p><ul><li>manage 与 worker 分别会读写配置文件，需互斥防止并发导致更新的数据不一致。</li><li>ZooKeeper 模块触发更新时，需等待上一次更新完成：采用 <code>updating</code> 标志避免连续变更冲突。</li></ul><h4 id="5-问题"><a href="#5-问题" class="headerlink" title="5. 问题"></a>5. 问题</h4><p>整个配置更新期间，结合work的for循环工作模式，其实会有一些问题</p><p>1、特点</p><ul><li>当某个 worker 进程执行配置更新，其 for 循环在定时器阶段进行，不会抢到 accept 锁，新连接自动落到其他空闲 worker 上，保证无中断接入。</li><li>不同 worker 因版本更新不一致，可能出现：<ol><li>已更新的 worker 请求正常；</li><li>正在更新的 worker 请求略有延迟；</li><li>未更新的 worker 因服务节点变更导致请求异常。</li></ol></li></ul><p>2、work在更新配置时，这个进程无法处理业务</p><p>按照work的工作模式，依次处理网络IO（如果拿到锁还会处理新连接）、定时器、延迟队列，此时处于处理定时器阶段，如果要更新2s，那2s内其实处理不了其他的事件。</p><p>3、如果是多个进程，那么nginx还能正常处理业务吗？</p><p>需要看每个work处在for循环的哪个阶段，只要work触发定时器的配置更新后，就无法处理其他事件，但是不同的work，处的阶段可能不一样。</p><p>同一时间，有work抢到了accept锁，处理新连接，有的work处理自身的读写事件，有的work触发了定时器的事件，有的work处理延迟队列的新连接数据。</p><p>4、连续推送问题的解决—-updating</p><p>本质上watcher可以连续推送消息，再加上这和manage相当于是多线程的关系，也就是manage在更新配置的时候，watcher是可以并发推送的。</p><p>如果是单进程，这是不可能发生的，因为一个进程在执行定时器时，网络io事件需要下一次for循环，但是zookeeper的c语言sdk会创建一个线程，导致manage进程和这个线程存在竞争关系，会有什么问题？</p><ol><li>manage定时器检测标志位变华，开始处理本次变更，获取zookeeper的数据，更新配置（假设是配置的第100个版本，这里更新了路由）</li><li>watcher又推送了变更，更改了标志位（这里有可能发生多次的推送）</li><li>manage多次获取zookeeper数据，更新配置（有可能是101版本，或者更大，这里更新了流控）</li><li>manage处理完毕本次变更，恢复标志位，然后创建定时器</li><li>定时器继续扫描标志位，发现没有变化，等待下一次定时器</li></ol><p>首先zookeeper的数据是快照数据，1，3获取的数据很可能是不同版本，因为一直在变更。第四步处理完毕后，虽然配置变更了很多次，但是manage只更新了一次，路由的配置是旧的，但是流控的是新的！事实上需要再次更新到最新的</p><p>一般这种竞争关系，第一反应是加锁，但是这怎么加锁？manage更新的时候，watcher别更新？zookeeper貌似没有这种机制，那只能是标志位了</p><p>多加一个updating标志位，具体逻辑为：</p><ol><li>manage定时器检测标志位变华，开始处理本次变更，<strong>首先将updating设置为1，标识正在更新</strong>，（假设是配置的第100个版本，这里更新了路由）</li><li>watcher又推送了变更，更改了标志位（这里有可能发生多次的推送），<strong>同时将updating设置为0</strong></li><li>manage多次获取zookeeper数据，更新配置（有可能是101版本，或者更大，这里更新了流控）</li><li>manage处理完毕本次变更，<strong>如果updating为1，就直接恢复标志位</strong>，<strong>否则，不恢复标志位</strong>，<strong>为0就说明此时发生了多次推送</strong>，然后创建定时器</li><li>定时器继续扫描标志位，发现标志位<strong>依旧需要更新</strong>，开始更新</li></ol><h2 id="3、nginx关于accept锁"><a href="#3、nginx关于accept锁" class="headerlink" title="3、nginx关于accept锁"></a>3、nginx关于accept锁</h2><h3 id="3-1、空白期？"><a href="#3-1、空白期？" class="headerlink" title="3.1、空白期？"></a>3.1、空白期？</h3><p>在开始看这块代码时，我会有一个疑问，如果说只有抢到锁的进程，才能将监听socket放到自己的epoll，从而处理新连接，那么当前work释放锁之后，从epoll删除这个socket，在下一次多个work抢锁，并添加到epoll的时间差中，<strong>是否存在空白期，即没有一个work将这个socket放到epoll里面？这期间的新连接会怎么样，会丢失吗</strong>   这其实需要从2方面分析。</p><ol><li>内核如何处理socket</li><li>nginx如何处理accept</li></ol><p><strong>事实上完全不会</strong></p><p>对于内核，即使在两次操作之间理论上会有时间差，内核不会丢失连接，因为未被 accept 的新连接一直保留在 socket 的 backlog 队列中，且 epoll 的事件会在重新启用时一次性报告所有待处理的连接（包括中间到达的）。</p><p>对于work，释放锁之后，不会立即从epoll删除这个socket，所以不会空白期。</p><p>也就是说，就算有空白期，内核也不会丢失连接，更何况，nginx通过机制，不会存在空白期，保持高性能处理新连接-accept。</p><h3 id="3-2、内核的处理"><a href="#3-2、内核的处理" class="headerlink" title="3.2、内核的处理"></a>3.2、内核的处理</h3><p>1、 backlog 队列保证连接不丢失</p><ul><li>TCP 新连接在完成三次握手后先放入内核的 backlog 队列，不会因为用户态未调用 <code>accept()</code> 而丢失；除非达到队列上限才会拒绝新连接。</li><li>即便 nginx 在释放锁后删掉或禁用了自己 epoll 实例中的监听事件，内核 backlog 依然保留了所有已完成的连接请求，等待下一个 <code>accept()</code> 调用。</li></ul><p>2 、epoll 的“待报告”事件语义</p><ul><li><strong>Level-triggered</strong>（默认）模式下，只要文件描述符对应的内核读缓冲区或 backlog 非空，<code>epoll_wait()</code> 每次都会报告该事件；禁用后重新启用即可一次性报告所有积压的事件，不会遗漏。</li><li>即使使用 <code>EPOLLONESHOT</code>、<code>EPOLL_EXCLUSIVE</code> 等高级选项，内核也会在重新 arm（重新添加或修改）后，将中间产生的事件一次性返回</li></ul><h3 id="3-3、nginx的处理"><a href="#3-3、nginx的处理" class="headerlink" title="3.3、nginx的处理"></a>3.3、nginx的处理</h3><p>只有拿到锁的work才会epoll_wait，拿不到锁的work，虽然epoll里面有这个监听socket，但是不会立马epoll_wait。这个老的work，在没拿到锁时，会进行删除操作，把socket从epoll删除，然后再epoll_wait，这样新连接可以即时处理，也不会存在竞争关系。</p><p>1、举个例子</p><p>🕒 第 1 轮事件循环</p><ul><li><strong>Worker 1：</strong><ol><li>尝试获取 <code>accept_mutex</code>，成功。</li><li>调用 <code>ngx_enable_accept_events()</code>，将监听 socket 添加到自己的 epoll中。</li><li>设置 <code>ngx_accept_mutex_held = 1</code>。</li><li>调用 <code>epoll_wait()</code>，等待事件。</li><li>接收到新连接事件，处理 <code>accept()</code>，建立连接。</li><li>处理完事件后，调用 <code>ngx_shmtx_unlock(&amp;ngx_accept_mutex)</code>，释放锁。</li><li><strong>注意：此时并未调用 <code>epoll_ctl(DEL)</code>，监听 socket 仍在 epoll中。</strong></li></ol></li><li><strong>Worker 2：</strong><ol><li>尝试获取 <code>accept_mutex</code>，失败。</li><li>由于 <code>ngx_accept_mutex_held == 0</code>，未持有锁，因此不会将监听 socket 添加到 epoll 中。</li><li>调用 <code>epoll_wait()</code>，等待事件。</li><li>未接收到新连接事件，继续等待。</li></ol></li></ul><p>🕒 第 2 轮事件循环</p><ul><li><strong>Worker 2：</strong><ol><li>尝试获取 <code>accept_mutex</code>，成功。</li><li>调用 <code>ngx_enable_accept_events()</code>，将监听 socket 添加到自己的 epoll 中。</li><li>设置 <code>ngx_accept_mutex_held = 1</code>。</li><li>调用 <code>epoll_wait()</code>，等待事件。</li><li>接收到新连接事件，处理 <code>accept()</code>，建立连接。</li><li>处理完事件后，调用 <code>ngx_shmtx_unlock(&amp;ngx_accept_mutex)</code>，释放锁。</li><li><strong>注意：此时并未调用 <code>epoll_ctl(DEL)</code>，监听 socket 仍在 epoll 中。</strong></li></ol></li><li><strong>Worker 1：</strong><ol><li>尝试获取 <code>accept_mutex</code>，失败。</li><li>检测到 <code>ngx_accept_mutex_held == 1</code>，说明上一轮持有过锁。</li><li>调用 <code>ngx_disable_accept_events()</code>，将监听 socket 从 epoll 中删除。</li><li>设置 <code>ngx_accept_mutex_held = 0</code>。</li><li>调用 <code>epoll_wait()</code>，等待事件。</li><li>未接收到新连接事件，继续等待。</li></ol></li></ul><hr><p>✅ 总结</p><ul><li>在每轮事件循环中，只有成功获取 <code>accept_mutex</code> 的 worker 进程会将监听 socket 添加到其 epoll 中，并处理新连接。</li><li>释放锁后，监听 socket 并不会立即从 epoll 中删除，而是在下一轮事件循环开始时，检测到未获取锁且上一轮持有过锁的情况下，才调用 <code>ngx_disable_accept_events()</code> 删除监听 socket。</li><li>释放锁后，监听 socket 并不会立即从 epoll 中删除，而是在下一轮事件循环开始时，当获取锁失败（说明已经有其他work获取到了锁，开始listen）检测到未获取锁且上一轮持有过锁的情况下，才调用 <code>ngx_disable_accept_events()</code> 删除监听 socket。</li></ul><h3 id="3-4、源码分析"><a href="#3-4、源码分析" class="headerlink" title="3.4、源码分析"></a>3.4、源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_trylock_accept_mutex</span><span class="hljs-params">(<span class="hljs-type">ngx_cycle_t</span> *cycle)</span><br>&#123;<br>    <span class="hljs-comment">// 尝试获取接受互斥锁</span><br>    <span class="hljs-keyword">if</span> (ngx_shmtx_trylock(&amp;ngx_accept_mutex)) &#123;<br><br>        <span class="hljs-comment">// 尝试启用接受事件，-----------  1、拿到锁的进程，在epoll添加socket</span><br>        <span class="hljs-keyword">if</span> (ngx_enable_accept_events(cycle) == NGX_ERROR) &#123;<br>            <span class="hljs-comment">// 如果启用失败，释放互斥锁</span><br>            ngx_shmtx_unlock(&amp;ngx_accept_mutex);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 重置接受事件计数</span><br>        ngx_accept_events = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 标记已经持有互斥锁</span><br>        ngx_accept_mutex_held = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> NGX_OK;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果之前已经持有互斥锁</span><br>    <span class="hljs-keyword">if</span> (ngx_accept_mutex_held) &#123;<br>        <span class="hljs-comment">// 尝试禁用接受事件,-------  2、拿不到锁的进程，在epoll删除socket</span><br>        <span class="hljs-keyword">if</span> (ngx_disable_accept_events(cycle, <span class="hljs-number">0</span>) == NGX_ERROR) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>        <span class="hljs-comment">// 标记不再持有互斥锁</span><br>        ngx_accept_mutex_held = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码执行完毕，每个进程才会执行epoll_wait，那自然不会有问题了</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>work</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome 133 引发 net::ERR_CONTENT_LENGTH_MISMATCH 问题的分析与解决</title>
    <link href="/2025/02/26/chrome-netERR_CONTENT_LENGTH_MISMATCH/"/>
    <url>/2025/02/26/chrome-netERR_CONTENT_LENGTH_MISMATCH/</url>
    
    <content type="html"><![CDATA[<p><strong>【现象】</strong></p><p>最近有用户反馈，在使用 浏览器 访问系统时，部分静态资源请求出现 <code>net::ERR_CONTENT_LENGTH_MISMATCH</code> 错误。<br>具体现象：</p><ul><li>页面请求 多个静态资源（HTML&#x2F;JS&#x2F;CSS），但部分请求随机失败。</li><li>每次刷新，失败的资源 不固定，但问题持续发生。</li></ul><p><strong>【排查】</strong></p><p>介入排查后，发现几个问题</p><ul><li><p>使用 Chrome 131 及以下版本、Edge、Firefox 均无法复现。</p></li><li><p>升级到 Chrome 133 后，问题立即复现。</p></li></ul><p><strong><code>ERR_CONTENT_LENGTH_MISMATCH</code> 的常见原因：</strong></p><ul><li>服务器返回的数据 大小 与 <code>Content-Length</code> 不匹配。</li><li>数据传输中断，导致客户端未接收完整数据。</li><li>代理层或防火墙 可能影响数据完整性</li></ul><p>因此在网关侧和windows侧同时抓包，发现2个问题</p><p>1、nginx返回的数据没有异常</p><p>2、在传输几十ms后，数据还没传输完，客户端给nginx发送了FIN，<strong>也就是说chrome在数据没有传输完成时，发送了FIN，断开了连接</strong>。RST很好理解，nginx接收FIN后，立马close这个连接的socket，后续请求来临时，内核不识别这条连接直接返回RST</p><p><img src="/img/chrome-nginx-%E7%BD%91%E7%BB%9C%E5%8C%85%E5%88%86%E6%9E%90.png" alt="chrome-nginx-网络包分析"></p><p>同时查看了windows侧抓的包，确认确实是chrome发出的FIN，排除现场防火墙拦截的可能性。</p><p><strong>【初步结论】</strong></p><ul><li>Chrome 133 在数据传输未完成时，主动发送 FIN 终止连接，导致 部分静态资源加载失败。</li><li>Edge、Chrome 131 及以下版本均无此问题，升级至 Chrome 133 后，问题立即复现。</li><li>结论：Chrome 133 的 TCP 处理逻辑存在 Bug，并非 Nginx 或防火墙导致的问题。</li></ul><p><strong>【Bug 反馈 &amp; 官方响应】</strong></p><ul><li>我在 Chromium Bug Tracker <ul><li><a href="https://issues.chromium.org/issues/397848897">https://issues.chromium.org/issues/397848897</a></li></ul></li><li>但是发现该问题已有人提交：<ul><li><a href="https://issues.chromium.org/issues/391126826">https://issues.chromium.org/issues/391126826</a></li></ul></li><li>官方确认：问题由 <code>TcpSocketIoCompletionPortWin</code> 引发。</li><li>Chrome 133.0.6943.142 版本默认关闭该特性，作为临时解决方案。</li></ul><p><strong>【TcpSocketIoCompletionPortWin】</strong></p><p>TcpSocketIoCompletionPortWin&#96; 在 Chrome 网络栈中的作用</p><ul><li>负责 Windows 平台的 TCP 异步 I&#x2F;O 处理，使用 IOCP（I&#x2F;O Completion Port）机制 进行高效管理。</li><li>影响范围：<ol><li>HTTP(S) 连接：网页加载的所有 TCP 请求（包括静态资源）。</li><li>WebSocket 连接：影响 WebSocket 长连接数据传输。</li><li>Chromium IPC（进程间通信）：影响 Chrome 进程间的数据传输。</li><li>QUIC&#x2F;TLS 连接：影响 TLS 加密连接的数据流控制。</li></ol></li></ul><p>源码主要在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">net/socket/tcp_socket_win.cc<br>net/socket/tcp_socket_win.h<br>net/socket/tcp_socket_io_completion_port_win.cc<br>net/socket/tcp_socket_io_completion_port_win.h<br></code></pre></td></tr></table></figure><p><a href="https://source.chromium.org/chromium/chromium/src/+/main:net/socket/tcp_socket_io_completion_port_win.cc">https://source.chromium.org/chromium/chromium/src/+/main:net/socket/tcp_socket_io_completion_port_win.cc</a></p><p>虽然对网络这块很感兴趣，不过这里还是不为难自己了，关注一下后续怎么修复</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux对于io_uring的应用</title>
    <link href="/2025/02/12/linux%E5%AF%B9%E4%BA%8Eio_uring%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2025/02/12/linux%E5%AF%B9%E4%BA%8Eio_uring%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1、内核支持io-uring"><a href="#1、内核支持io-uring" class="headerlink" title="1、内核支持io_uring"></a>1、内核支持io_uring</h2><p>最近发现linux新增了2个补丁，关于支持io_uring，事实上linux在5.1版本就引入了io_uring，有点好奇这次的补丁是实现什么功能</p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32</a></p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=dcc0113acd3b77cca3c7e805fffd8ea4c5a675b3">netdev: add io_uring memory provider info - kernel&#x2F;git&#x2F;netdev&#x2F;net-next.git - Netdev Group’s -next networking tree</a></p><p>看了一下文档，这个补丁通过 <code>io_uring</code> 提供了零拷贝接收功能，使得硬件接收到的数据可以直接传输到用户空间，避免了内核和用户空间之间的数据拷贝。具体是内核会预先配置了一个页面池，这些页面是由用户空间应用程序申请的，且当硬件接收到数据时，会通过 <strong>DMA</strong> 直接将数据传输到这些用户空间页面中，比起常规的数据接收，减少了一次数据拷贝。不过有个问题是，不知道会不会影响tcpdump抓包，毕竟整个流转发生了变化。</p><h2 id="2、liburing"><a href="#2、liburing" class="headerlink" title="2、liburing"></a>2、liburing</h2><p>目前流行的是liburing这个库，对整个io_uring做了一层封装，github有3k+⭐</p><h2 id="3、nginx支持io-uring"><a href="#3、nginx支持io-uring" class="headerlink" title="3、nginx支持io_uring"></a>3、nginx支持io_uring</h2><p>nginx目前还没有支持io_uring，io_uring会对nginx的性能有一些提升，尤其是零拷贝，大数据量下肯定会有很大的提升</p><h2 id="4、内核补丁"><a href="#4、内核补丁" class="headerlink" title="4、内核补丁"></a>4、内核补丁</h2><h3 id="4-1、描述"><a href="#4-1、描述" class="headerlink" title="4.1、描述"></a>4.1、描述</h3><p>io_uring 零拷贝 rx</p><p>此补丁集包含新 io_uring 请求所需的 net&#x2F; 补丁，该请求将零拷贝 rx 实现到用户空间页面，从而消除了内核到用户的复制。</p><p>我们配置了一个页面池，驱动程序使用它来填充 hw rx 队列以分发用户页面而不是内核页面。因此，任何最终到达此 hw rx 队列的数据都将直接通过 dma 进入用户空间内存，而无需通过内核内存反弹。从套接字中“读取”数据反而成为一种_通知_机制，内核会告诉用户空间数据在哪里。总体方法类似于 devmem TCP 提案。</p><p>这依赖于 hw 标头&#x2F;数据拆分、流控制和 RSS，以确保数据包标头保留在内核内存中，并且只有所需的流才会到达配置为零拷贝的 hw rx 队列。配置它超出了此补丁集的范围。</p><p>我们与 devmem TCP 共享 netdev 核心基础设施。主要区别在于 io_uring 用于 uAPI，并且所有对象的生命周期都绑定到 io_uring 实例。使用新的 io_uring 请求类型“读取”数据。完成后，数据通过新的共享重新填充队列返回。零拷贝页面池直接从此重新填充队列重新填充 hw rx 队列。当然，这些数据缓冲区的生命周期由 io_uring 而不是网络堆栈管理，具有不同的引用计数规则。</p><p>此补丁集是添加基本零拷贝支持的第一步。我们将使用新功能迭代扩展它，例如动态分配的零拷贝区域、THP 支持、dmabuf 支持、改进的复制回退、一般优化等。</p><p>在 netdev 支持方面，我们首先针对 Broadcom bnxt。补丁不包括在内，因为 Taehee Yoo 已经在 [1] 中发送了一个更全面的补丁集来添加支持。 Google gve 应该已经支持此功能，<br>而 Mellanox mlx5 支持仍在进行中，有待驱动程序更改。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Performance &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>注意：与 epoll + TCP_ZEROCOPY_RECEIVE 的比较尚未完成。</p><p>测试设置：</p><ul><li>AMD EPYC 9454</li><li>Broadcom BCM957508 200G</li><li>内核 v6.11 基础 [2]</li><li>liburing fork [3]</li><li>kperf fork [4]</li><li>4K MTU</li><li>单个 TCP 流</li></ul><p>将应用程序线程 + net rx softirq 固定到 <em>不同</em> 核心：</p><p>使用应用程序线程 + net rx softirq 固定到 <em>不同</em> 核心：</p><table><thead><tr><th>epoll</th><th>io_uring</th></tr></thead><tbody><tr><td>82.2 Gbps</td><td>116.2 Gbps (+41%)</td></tr></tbody></table><p>固定到 <em>相同</em> 核心：</p><table><thead><tr><th>epoll</th><th>io_uring</th></tr></thead><tbody><tr><td>62.6 Gbps</td><td>80.9 Gbps (+29%)</td></tr></tbody></table><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">Diffstat</a></p><table><thead><tr><th>-rw-r–r–</th><th><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/Documentation/netlink/specs/netdev.yaml?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">Documentation&#x2F;netlink&#x2F;specs&#x2F;netdev.yaml</a></th><th>15</th><th></th></tr></thead><tbody><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/include/net/netmem.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">include&#x2F;net&#x2F;netmem.h</a></td><td>21</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/include/net/page_pool/memory_provider.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">include&#x2F;net&#x2F;page_pool&#x2F;memory_provider.h</a></td><td>45</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/include/net/page_pool/types.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">include&#x2F;net&#x2F;page_pool&#x2F;types.h</a></td><td>4</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/include/uapi/linux/netdev.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">include&#x2F;uapi&#x2F;linux&#x2F;netdev.h</a></td><td>7</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/dev.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;dev.c</a></td><td>16</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/devmem.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;devmem.c</a></td><td>93</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/devmem.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;devmem.h</a></td><td>49</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/netdev-genl.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;netdev-genl.c</a></td><td>11</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/netdev_rx_queue.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;netdev_rx_queue.c</a></td><td>69</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/page_pool.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;page_pool.c</a></td><td>51</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/core/page_pool_user.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;core&#x2F;page_pool_user.c</a></td><td>7</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/net/ipv4/tcp.c?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">net&#x2F;ipv4&#x2F;tcp.c</a></td><td>7</td><td></td></tr><tr><td>-rw-r–r–</td><td><a href="https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/diff/tools/include/uapi/linux/netdev.h?id=71f0dd5a3293d75d26d405ffbaedfdda4836af32">tools&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;netdev.h</a></td><td>7</td><td></td></tr></tbody></table><h3 id="4-2、代码解析"><a href="#4-2、代码解析" class="headerlink" title="4.2、代码解析"></a>4.2、代码解析</h3><p>一、Netlink 及 UAPI 接口扩展</p><p>1.1 修改 Documentation&#x2F;netlink&#x2F;specs&#x2F;netdev.yaml</p><ul><li>新增属性集 “io-uring-provider-info”<ul><li>在属性集定义中增加了一个名为 <code>io-uring-provider-info</code> 的空属性集，作为嵌套属性使用的模板。</li></ul></li><li>扩展 page-pool 属性<ul><li>在 page-pool 的属性中，除了原来的 <code>dmabuf</code> 属性，还增加了一个嵌套属性 <code>io-uring</code>，其嵌套属性集就是前面定义的 <code>io-uring-provider-info</code>。</li><li>同样，在队列属性中也增加了 <code>io-uring</code> 字段，这样用户空间通过 Netlink 获取设备信息时，可以看到和配置 io_uring 内存提供者相关的信息。</li></ul></li></ul><p>1.2 修改 UAPI 头文件 tools&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;netdev.h 和 include&#x2F;uapi&#x2F;linux&#x2F;netdev.h</p><ul><li>新增枚举值<ul><li>分别为 page-pool 和队列属性增加了 <code>NETDEV_A_PAGE_POOL_IO_URING</code> 与 <code>NETDEV_A_QUEUE_IO_URING</code> 枚举值，以及 <code>NETDEV_A_IO_URING_PROVIDER_INFO_MAX</code>。</li><li>这些修改使得内核在通过 Netlink 通知用户空间时，能传递与 io_uring 内存提供相关的配置信息。</li></ul></li></ul><hr><p>二、内存向量与页面池相关改动</p><p>2.1 修改 include&#x2F;net&#x2F;netmem.h</p><ul><li>更新 net_iov 结构体<ul><li>原来 <code>net_iov</code> 结构体中 <code>owner</code> 字段由指向 <code>dmabuf_genpool_chunk_owner</code> 修改为指向新定义的 <code>net_iov_area</code>。</li></ul></li><li>新增结构体 net_iov_area<ul><li>用于管理一片区域内的 net_iov 数组，包含：<ul><li><code>niovs</code>：指向 net_iov 数组的指针；</li><li><code>num_niovs</code>：数组中 net_iov 的数量；</li><li><code>base_virtual</code>：表示该区域在 dma-buf 中起始的虚拟偏移。</li></ul></li></ul></li><li>新增内联辅助函数<ul><li><code>net_iov_owner()</code> 用于获取 net_iov 的所属区域；</li><li><code>net_iov_idx()</code> 用于计算 net_iov 在所属区域内的索引。</li></ul></li></ul><p>2.2 修改 include&#x2F;net&#x2F;page_pool&#x2F;types.h</p><ul><li>整合内存提供者接口<ul><li>在 <code>pp_memory_provider_params</code> 结构中增加了一个指向 <code>memory_provider_ops</code> 的指针。</li><li>同时，在 <code>struct page_pool</code> 中也新增了同样的指针。这样页面池在初始化、分配、释放、销毁等操作时，可以通过统一的接口调用不同内存提供者的实现。</li></ul></li></ul><p>2.3 新增内存提供者接口定义（include&#x2F;net&#x2F;page_pool&#x2F;memory_provider.h）</p><ul><li>定义结构体 memory_provider_ops<ul><li>包含一系列函数指针，主要操作包括：<ul><li><code>alloc_netmems</code>：分配 netmem；</li><li><code>release_netmem</code>：释放 netmem；</li><li><code>init</code> 和 <code>destroy</code>：初始化和销毁内存提供者；</li><li><code>nl_fill</code>：用于通过 Netlink 填充内存提供者相关的信息；</li><li><code>uninstall</code>：在设备注销时卸载内存提供者。</li></ul></li></ul></li><li>辅助函数声明<ul><li>声明了设置 DMA 地址、关联&#x2F;解除页面池与 net_iov 的函数，以及打开&#x2F;关闭 RX 队列时的接口。</li></ul></li></ul><hr><p>三、核心代码中的内存提供者支持</p><p>3.1 在 net&#x2F;core&#x2F;dev.c 中</p><ul><li>新增 dev_memory_provider_uninstall()<ul><li>遍历设备的所有 RX 队列，检查各队列是否已绑定内存提供者（通过 mp_ops 字段），如果绑定，则调用对应的 uninstall 回调函数。</li></ul></li><li>修改注销流程<ul><li>在注销设备时，用 dev_memory_provider_uninstall() 替代了原来的 dev_dmabuf_uninstall，确保所有内存提供者资源得到正确清理。</li></ul></li></ul><p>3.2 在 net&#x2F;core&#x2F;devmem.c 中</p><ul><li>调整对 net_iov 的访问<ul><li>将原来直接使用 <code>owner-&gt;niovs</code> 改为通过 <code>owner-&gt;area.niovs</code>，并更新 <code>num_niovs</code> 为 <code>owner-&gt;area.num_niovs</code>。</li></ul></li><li>更新绑定与释放逻辑<ul><li>修改了函数 net_devmem_bind_dmabuf_to_queue、net_devmem_alloc_dmabuf、net_devmem_free_dmabuf 等，使其使用新结构来处理内存提供者信息。</li></ul></li><li>实现 dmabuf_devmem_ops<ul><li>定义了一个静态的 <code>memory_provider_ops</code> 结构 dmabuf_devmem_ops，将初始化、销毁、分配、释放、Netlink 填充（nl_fill）和卸载函数关联起来，为 dmabuf 类型的内存提供者提供实现。</li></ul></li></ul><p>3.3 在 net&#x2F;core&#x2F;netdev-genl.c 中</p><ul><li>调整 Netlink 填充逻辑<ul><li>修改 netdev_nl_queue_fill_one 函数，使其在处理 RX 队列时，如果队列绑定了内存提供者，则调用内存提供者的 nl_fill() 回调来填充 Netlink 消息。</li></ul></li></ul><p>3.4 在 net&#x2F;core&#x2F;netdev_rx_queue.c 中</p><ul><li>新增 RX 队列内存提供者管理函数<ul><li>实现了 net_mp_open_rxq 和 net_mp_close_rxq 接口，用于在特定 RX 队列上绑定和解绑内存提供者。这包括对 mp_params 的设置和队列重启的调用。</li></ul></li></ul><p>3.5 在 net&#x2F;core&#x2F;page_pool.c 与 page_pool_user.c 中</p><ul><li>整合内存提供者接口<ul><li>在页面池初始化、分配、释放和销毁过程中，均通过检查 pool-&gt;mp_ops 是否设置，来决定是否调用内存提供者的相关接口。</li><li>新增辅助函数 net_mp_niov_set_dma_addr、net_mp_niov_set_page_pool、net_mp_niov_clear_page_pool，分别用于设置 DMA 地址、关联和解除页面池与 net_iov 之间的关系。</li></ul></li><li>更新 Netlink 填充逻辑<ul><li>在 page_pool_nl_fill 函数中，调用内存提供者的 nl_fill() 回调，以将相关信息填入消息。</li></ul></li></ul><p>3.6 在 net&#x2F;ipv4&#x2F;tcp.c 中</p><ul><li>修改 TCP 接收逻辑<ul><li>在 tcp_recvmsg_dmabuf 函数中，将原来调用 net_iov_binding_id 改为 net_devmem_iov_binding_id，以使用新接口获取绑定 ID，从而适配新的内存提供者机制。</li></ul></li></ul><hr><p>四、总结</p><p>这份补丁的主要改动可以总结为以下几点：</p><ol><li><strong>扩展 Netlink&#x2F;UAPI 接口</strong><ul><li>在文档和 UAPI 头文件中新增了 io_uring 内存提供者相关的属性，方便用户空间配置与监控。</li></ul></li><li><strong>引入统一的内存提供者接口</strong><ul><li>通过新增 memory_provider_ops 接口，统一管理各种内存提供者（如 dmabuf 和未来的 io_uring 零拷贝方案）的分配、释放、初始化、销毁和卸载等操作。</li><li>修改页面池（page pool）和 netmem 相关数据结构，引入 net_iov_area 来代替原来的直接指针，并新增辅助函数。</li></ul></li><li><strong>修改核心网络代码以支持新接口</strong><ul><li>在网络设备注销、RX 队列绑定、页面池操作和 TCP 接收逻辑中，均调用新的内存提供者接口，从而实现对内存提供者（包括未来的 io_uring 零拷贝）的统一支持。</li></ul></li></ol><p>总体来说，这套改动为内核网络子系统引入了更灵活、统一的内存管理机制，为未来支持基于 io_uring 的零拷贝网络接收铺平了道路。通过这一改动，数据在网络接收过程中可以直接从硬件 DMA 到用户空间内存（零拷贝），减少了不必要的数据复制，从而在高吞吐量、低延迟的场景下提升系统性能。</p><h2 id="5、接口"><a href="#5、接口" class="headerlink" title="5、接口"></a>5、接口</h2><ol><li><code>io_uring_setup</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_setup(unsigned entries, struct io_uring_params *p);</code></p></li><li><p><strong>作用</strong>：创建一个 <code>io_uring</code> 实例，初始化提交队列和完成队列，并返回一个文件描述符（<code>fd</code>）来与内核进行后续的 I&#x2F;O 操作。</p></li><li><p>参数</p><p>：</p><ul><li><code>entries</code>：提交队列和完成队列的条目数。</li><li><code>p</code>：一个 <code>io_uring_params</code> 结构体，用于传递内核参数（如队列大小、特性标志等）。</li></ul></li><li><p><strong>返回值</strong>：成功返回一个文件描述符，用于后续操作；失败返回负数错误码。</p></li></ul><ol start="2"><li><code>io_uring_enter</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_enter(int fd, unsigned to_submit, unsigned min_complete, unsigned flags, sigset_t *sig);</code></p></li><li><p><strong>作用</strong>：提交 I&#x2F;O 请求并等待完成。它将请求从用户空间提交到内核，并在必要时等待 I&#x2F;O 请求的完成。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>to_submit</code>：提交的 I&#x2F;O 请求数量。</li><li><code>min_complete</code>：最小完成队列条目数，表示内核完成的请求数量。</li><li><code>flags</code>：标志位，控制操作的行为。</li><li><code>sig</code>：信号掩码，指定在等待时要屏蔽的信号。</li></ul></li><li><p><strong>返回值</strong>：成功返回已提交的条目数；失败返回负数错误码。</p></li></ul><ol start="3"><li><code>io_uring_register</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_register(int fd, unsigned opcode, void *arg, unsigned arg2);</code></p></li><li><p><strong>作用</strong>：用于注册一些额外的内核行为，例如注册文件描述符、缓冲区等。此函数允许用户为 <code>io_uring</code> 实例注册一些资源，供后续 I&#x2F;O 操作使用。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>opcode</code>：操作码，表示要执行的注册操作类型（如注册文件描述符、缓冲区等）。</li><li><code>arg</code>：操作所需的参数（例如文件描述符、缓冲区地址等）。</li><li><code>arg2</code>：额外的参数（根据操作类型不同而不同）。</li></ul></li><li><p><strong>返回值</strong>：成功时返回 0，失败时返回负数错误码。</p></li></ul><ol start="4"><li><code>io_uring_unregister</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_unregister(int fd, unsigned opcode);</code></p></li><li><p><strong>作用</strong>：撤销之前注册的资源，例如取消对某些文件描述符的注册。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>opcode</code>：操作码，指定要撤销的注册资源。</li></ul></li><li><p><strong>返回值</strong>：成功时返回 0，失败时返回负数错误码。</p></li></ul><ol start="5"><li><code>io_uring_peek_cqe</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_peek_cqe(int fd, struct io_uring_cqe **cqe);</code></p></li><li><p><strong>作用</strong>：检查完成队列中是否有完成的 I&#x2F;O 请求，而不阻塞。如果有，返回一个指向完成队列条目的指针。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>cqe</code>：指向指针的指针，用于返回完成队列条目。</li></ul></li><li><p><strong>返回值</strong>：成功时返回 0，失败时返回负数错误码。</p></li></ul><ol start="6"><li><code>io_uring_wait_cqe</code></li></ol><ul><li><p><strong>原型</strong>：<code>int io_uring_wait_cqe(int fd, struct io_uring_cqe **cqe);</code></p></li><li><p><strong>作用</strong>：等待并返回一个已完成的 I&#x2F;O 请求的完成队列条目。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>cqe</code>：指向指针的指针，用于返回完成队列条目。</li></ul></li><li><p><strong>返回值</strong>：成功时返回 0，失败时返回负数错误码。</p></li></ul><ol start="7"><li><code>io_uring_cq_advance</code></li></ol><ul><li><p><strong>原型</strong>：<code>void io_uring_cq_advance(int fd, unsigned count);</code></p></li><li><p><strong>作用</strong>：推进完成队列，通常在用户空间处理完一个或多个完成队列条目后调用，以通知内核已处理。</p></li><li><p>参数</p><p>：</p><ul><li><code>fd</code>：<code>io_uring</code> 实例的文件描述符。</li><li><code>count</code>：推进的完成队列条目数。</li></ul></li><li><p><strong>返回值</strong>：无返回值。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>io_uring</tag>
      
      <tag>epoll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络部分-epoll分析</title>
    <link href="/2024/11/29/%E7%BD%91%E7%BB%9CIO/"/>
    <url>/2024/11/29/%E7%BD%91%E7%BB%9CIO/</url>
    
    <content type="html"><![CDATA[<h2 id="1、内核如何接收数据"><a href="#1、内核如何接收数据" class="headerlink" title="1、内核如何接收数据"></a>1、内核如何接收数据</h2><p>不同主机通过网卡进行数据的交互，网卡将电磁波转换为模拟信号，再转换为数字信号，再由OSI模型传到应用层，变成人可以识别的数据。信号转换属于通信相关的知识，所以从接收到数字信号开始分析数据的流转。</p><ol><li>首先当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的RingBuffer中寻找可用的内存位置，找到后DMA引擎会把数据DMA到网卡之前关联的内存里，这个时候CPU都是无感的。当DMA操作完成以后，网卡会像CPU发起一个硬中断，通知CPU有数据到达。</li><li>Linux在硬中断里只完成简单必要的工作，剩下的大部分的处理都是转交给软中断的，硬中断处理过程真的是非常短。只是记录了一个寄存器，修改了一下下CPU的poll_list，然后发出个软中断。</li><li>软中断和硬中断中调用了同一个函数<code>local_softirq_pending</code>。使用方式不同的是硬中断位置是为了写入标记，这里仅仅只是读取这个标记。</li><li>把数据帧从RingBuffer上取下来，数据包将被送到协议栈中，ip  -&gt;   tcp&#x2F;udp，tcpdump就是在这里获取数据包</li><li>对应的协议栈将数据送往对应的socket，socket通知对应的进程</li></ol><h2 id="2、socket的概念"><a href="#2、socket的概念" class="headerlink" title="2、socket的概念"></a>2、socket的概念</h2><h3 id="2-1、通过socket唤醒各个进程"><a href="#2-1、通过socket唤醒各个进程" class="headerlink" title="2.1、通过socket唤醒各个进程"></a>2.1、通过socket唤醒各个进程</h3><p>用户进程可以通过socket接口与内核进行数据的交互，当一个进程想要listen一个端口时，首先需要创建一个socket绑定这个端口，当这个端口收到数据时，内核先将数据送往对应的协议栈，协议栈主要做2个事情</p><ul><li>保存数据到socket的接收缓冲队列</li><li>唤醒队列上的进程</li></ul><p>拿多进程举例子，如果master监听了某端口后，会创建对应的socket，后续fork时，子进程也共享这个打开的socket，也会”监听”这个socket（当某个进程调用 accept() 时，内核会动态地将该进程注册到 socket 的等待队列中），这就导致socket的等待队列会有多个work进程阻塞在这里，也就是说socket的等待队列存在多个进程。</p><p>​                                                                                                  多进程共享一个socket，但是进程各自有epoll</p><p>在唤醒进程时，如果唤醒所有的进程，就会引发惊群效应。有了epoll后，每个进程都会有自己的epoll，相当于会唤醒所有的epoll ，唤醒本质就是调用epoll注册的回调函数。</p><h3 id="2-2、通过epoll唤醒各个进程"><a href="#2-2、通过epoll唤醒各个进程" class="headerlink" title="2.2、通过epoll唤醒各个进程"></a>2.2、通过epoll唤醒各个进程</h3><p>根据socket等待队列中的元素，找到对应的epoll和epitem，这个回调函数第一时间会把epitem放到epoll对象的就绪链表里面，后续epoll_wait就会从就绪链表读取事件进行处理。</p><p>同样唤醒时可以选择唤醒一个进程还是多个</p><p>​                                                                                                   多进程共享一个epoll</p><h2 id="3、惊群效应"><a href="#3、惊群效应" class="headerlink" title="3、惊群效应"></a>3、惊群效应</h2><p>当讨论到惊群效应，其实要分层次讨论，因为socket和epoll都会有惊群效应。简单来说先fork再epoll_create()，socket的等待队列会存在多个””进程”; 先epoll_create()再fork，epoll的等待队列会有多个进程；</p><h3 id="3-1、socket的惊群效应"><a href="#3-1、socket的惊群效应" class="headerlink" title="3.1、socket的惊群效应"></a>3.1、socket的惊群效应</h3><p>多个进程共享一个socket，即主进程create、bind、listen，然后fork子进程后，多个进程共享一个socket，进行accept的场景，这时候socket的等待队列会存在多个进程。</p><p>当使用epoll时，那就意味着socket的等待队列存在多个epoll。比如nginx的每个work都会有自己的epoll，会把这个socket注册到epoll，相应的注册回调到socket的等待队列，相当于把本进程注册到socket。</p><p>当数据被送到socket时，socket会”唤醒”等待队列的各个进程（其实是调用epoll注册的回调函数），这时候如果唤醒所有的进程，就会引发惊群效应，因为只有一个进程会accept成功。</p><p>解决办法</p><ol><li>使用WQ_FLAG_EXCLUSIVE，在唤醒进程时，不会唤醒所有的进程，只会唤醒一个进程，但是解决不了epoll的场景。（ Linux 2.6 版本中引入）</li><li>使用SO_REUSEPORT，每个进程都有自己的socket，大家不共享socket，由内核负载socket。 （Linux 3.9 版本中引入）</li><li>使用锁，在应用层解决竞争关系，只有拿到锁的进程才能accept，nginx早期就是这么做的</li></ol><p>对于epoll，用户层可以调用的EPOLLEXCLUSIVE，实际使用的就是WQ_FLAG_EXCLUSIVE，使用EPOLLEXCLUSIVE ，添加事件时，epoll 会将对应的 epitem 节点标记为“独占模式” ，带有 EPOLLEXCLUSIVE 的监听者会被加入独占等待队列中，而非普通等待队列。如果有多个监听者，只会唤醒等待队列中第一个处于 EPOLLEXCLUSIVE 模式的监听者。如果没有 EPOLLEXCLUSIVE 模式监听者，唤醒其他普通监听者。（Linux 4.5 版本中引入）</p><h3 id="3-2、epoll的惊群效应"><a href="#3-2、epoll的惊群效应" class="headerlink" title="3.2、epoll的惊群效应"></a>3.2、epoll的惊群效应</h3><p>多进程共享一个epoll，即多个进程共享一个epoll的对象。一个主进程先epoll_create()，然后再fork() 创建多个进程。其实这种模式常见于多线程(其实也不常见吧，应该不会有人会这么设计吧？)，使用pthread_create()创建线程，本质上和fork没区别，实际上进程和进程也没区别，都会调用到 kernel_clone()，区别在于传入的参数不一样，这个函数会根据参数的不同，执行不同的逻辑，结果就是子进程会不会与父进程共享地址等等。</p><p>各个进程调用epoll_wait时，会把自己注册到epoll的等待队列，这会导致epoll的等待队列存在多个进程。</p><p>当socket执行到epoll的回调函数时，epoll首先会把自己的epitem放到就绪链表，然后唤醒等待队列的进程，其实就是执行等待队列元素的回调函数。如果唤醒所有的进程，那就会引发惊群效应。</p><p>解决办法</p><ol><li><p>实际查看linux代码，epoll_wait会默认设置独占模式。用户调用 epoll_wait 进入阻塞状态，如果没有事件，就阻塞自己，把当前进程写入到epoll元素的等待队列中，并设置WQ_FLAG_EXCLUSIVE。那其实就意味着这种场景没有惊群效应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>__add_wait_queue_exclusive(<span class="hljs-keyword">struct</span> wait_queue_head *wq_head, <span class="hljs-keyword">struct</span> wait_queue_entry *wq_entry)<br>&#123;<br>wq_entry-&gt;flags |= WQ_FLAG_EXCLUSIVE;  <span class="hljs-comment">//设置WQ_FLAG_EXCLUSIVE</span><br>__add_wait_queue(wq_head, wq_entry);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>不过一般多线程的架构设计不会这么设计，一般会主线程负责accept，在创建新的socket连接后，交由work线程，work会把这个新的socket加到自己的epoll，然后处理后续的事件。</p><p>不过多进程共享一个epoll绝对是不好的设计。</p><h3 id="3-3、各个属性分析"><a href="#3-3、各个属性分析" class="headerlink" title="3.3、各个属性分析"></a>3.3、各个属性分析</h3><p>1、WQ_FLAG_EXCLUSIVE</p><ol><li>减少惊群效应：<code>WQ_FLAG_EXCLUSIVE</code> 主要用于减少多个进程或进程同时被唤醒的情况，即惊群效应。当多个进程或进程等待同一个socket上的事件时，一个新连接的到来会导致所有阻塞在该socket上的进程或进程都被唤醒，但最终只有一个能处理这个连接，其余的进程或进程会重新进入等待状态。</li><li>内核层面的优化：<code>WQ_FLAG_EXCLUSIVE</code> 通过内核排他性唤醒机制，确保一次只唤醒一个等待队列中的进程，从而减少不必要的上下文切换和性能损耗。</li></ol><p>2、SO_REUSEPORT</p><ol><li>端口复用：<code>SO_REUSEPORT</code> 允许多个进程或进程绑定到同一端口上，每个进程或进程独立处理收到的数据。这在传统的socket编程中是不允许的，因为一个端口只能被一个进程绑定。</li><li>负载均衡：<code>SO_REUSEPORT</code> 不仅允许多个进程绑定到同一端口，还能在内核层面实现负载均衡，将新连接均匀分配给不同的进程或进程，从而提高多核系统的并行处理能力和整体性能。</li></ol><p>区别和联系</p><ul><li>作用层面：<code>WQ_FLAG_EXCLUSIVE</code> 主要是在内核层面减少不必要的进程唤醒，而 <code>SO_REUSEPORT</code> 是在应用层面允许多个进程或进程共享同一个端口，并在内核层面实现负载均衡。</li><li>应用场景：<code>WQ_FLAG_EXCLUSIVE</code> 更适用于单个进程内部的进程间协作，减少进程间的唤醒竞争；而 <code>SO_REUSEPORT</code> 更适用于多个进程间共享端口资源，提高系统的并发处理能力。</li><li>性能优化：<code>WQ_FLAG_EXCLUSIVE</code> 通过减少不必要的进程唤醒来优化性能；<code>SO_REUSEPORT</code> 通过负载均衡和多进程&#x2F;进程处理来提高性能。</li></ul><h3 id="3-4、源码分析"><a href="#3-4、源码分析" class="headerlink" title="3.4、源码分析"></a>3.4、源码分析</h3><p>1、对于socket</p><p>到达协议栈后，最终会调用__wake_up_sync_key唤醒进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __wake_up_sync_key(<span class="hljs-keyword">struct</span> wait_queue_head *wq_head, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode,<br><span class="hljs-type">void</span> *key)<br>&#123;<br>    <span class="hljs-keyword">if</span> (unlikely(!wq_head))<br>        <span class="hljs-keyword">return</span>;<br>    <br>    __wake_up_common_lock(wq_head, mode, <span class="hljs-number">1</span>, WF_SYNC, key);   <span class="hljs-comment">//这里的参数传了1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用到wake_up_common_lock  -&gt; __wake_up_common，其中nr_exclusive传了1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __wake_up_common(<span class="hljs-keyword">struct</span> wait_queue_head *wq_head, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode,<br><span class="hljs-type">int</span> nr_exclusive, <span class="hljs-type">int</span> wake_flags, <span class="hljs-type">void</span> *key)<br>&#123;<br><span class="hljs-type">wait_queue_entry_t</span> *curr, *next;<br>lockdep_assert_held(&amp;wq_head-&gt;lock);<br>curr = list_first_entry(&amp;wq_head-&gt;head, <span class="hljs-type">wait_queue_entry_t</span>, entry);<br><br><span class="hljs-comment">// 如果列表为空，则直接返回未使用的独占型进程唤醒名额</span><br><span class="hljs-keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head)<br><span class="hljs-keyword">return</span> nr_exclusive;<br><br><span class="hljs-comment">// 安全地遍历等待队列</span><br>list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;<br><span class="hljs-type">unsigned</span> flags = curr-&gt;flags;<br><span class="hljs-type">int</span> ret;<br><span class="hljs-comment">// 调用当前队列项的唤醒函数</span><br>ret = curr-&gt;func(curr, mode, wake_flags, key);<br><span class="hljs-comment">// 如果唤醒函数返回负值，则停止遍历</span><br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-comment">// 如果唤醒成功且当前队列项是独占型的，则减少剩余的独占型进程唤醒名额</span><br><span class="hljs-keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)      <span class="hljs-comment">//关键在这里</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 返回未使用的独占型进程唤醒名额</span><br><span class="hljs-keyword">return</span> nr_exclusive;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><ul><li><strong><code>ret</code></strong>: 唤醒操作是否成功。如果为 <code>true</code>，表示有进程被成功唤醒。</li><li><strong><code>flags &amp; WQ_FLAG_EXCLUSIVE</code></strong>: 检查当前队列项是否为独占型。<code>WQ_FLAG_EXCLUSIVE</code> 是一个标志位，表示该队列项是独占型的。</li><li><strong><code>!--nr_exclusive</code></strong>: 减少剩余的独占型进程唤醒名额，并检查是否已经用完所有名额。<code>--nr_exclusive</code> 先将 <code>nr_exclusive</code> 减 1，然后取其值。如果减 1 后 <code>nr_exclusive</code> 变为 0，则 <code>!</code> 运算符将其转换为 <code>true</code>。</li></ul><p>代码逻辑分析</p><ol><li>唤醒成功：<code>ret</code> 为 <code>true</code>，表示有进程被成功唤醒。</li><li>独占型队列项：<code>flags &amp; WQ_FLAG_EXCLUSIVE</code> 为 <code>true</code>，表示当前队列项是独占型的。</li><li>减少独占型唤醒名额：<code>--nr_exclusive</code> 将 <code>nr_exclusive</code> 减 1。</li><li>检查名额是否用完：如果 <code>nr_exclusive</code> 减 1 后变为 0，则 <code>!</code> 运算符将其转换为 <code>true</code>，执行 <code>break</code> 语句，跳出循环。</li></ol><p>通常nr_exclusive为1，也就是唤醒独占型的1个进程。但是会不会发生下面的场景呢？非独占型的进程在前面，独占型的进程在后面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*假设队列为：A（非独占） → B（独占） → C（独占） → D（非独占）</span><br><span class="hljs-comment">任务 A（非独占）：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">被唤醒（ret = 1），继续遍历。</span><br><span class="hljs-comment">任务 B（独占）：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">被唤醒（ret = 1），nr_exclusive--。</span><br><span class="hljs-comment">此时 nr_exclusive = 0，触发 break。</span><br><span class="hljs-comment">循环终止，任务 C 和任务 D 不会被处理。*/</span><br></code></pre></td></tr></table></figure><p>但是实际linux在添加进程时，会优先把独占型的进程添加到头部，新的独占型总会加到独占型的最后一个，如果没有他就会第一个，例如</p><ul><li>A（非独占）B（独占）C（独占）D（非独占）</li></ul><p>A</p><p>B-&gt;A</p><p>B-&gt;C-&gt;A</p><p>B-&gt;C-&gt;A-&gt;D</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __add_wait_queue(<span class="hljs-keyword">struct</span> wait_queue_head *wq_head, <span class="hljs-keyword">struct</span> wait_queue_entry *wq_entry)<br>&#123;<br>    <span class="hljs-comment">// 获取等待队列头部的列表头指针。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">head</span> =</span> &amp;wq_head-&gt;head;<br>    <span class="hljs-comment">// 定义一个等待队列项指针，用于遍历等待队列。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">wait_queue_entry</span> *<span class="hljs-title">wq</span>;</span><br><br>    <span class="hljs-comment">// 遍历等待队列头部中的所有等待队列项。</span><br>    list_for_each_entry(wq, &amp;wq_head-&gt;head, entry) &#123;<br>        <span class="hljs-comment">// 检查当前等待队列项是否具有优先级标志。</span><br>        <span class="hljs-keyword">if</span> (!(wq-&gt;flags &amp; WQ_FLAG_PRIORITY))<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// 如果当前项有优先级标志，则更新列表头指针为当前项的列表入口。</span><br>        head = &amp;wq-&gt;entry;<br>    &#125;<br>    <span class="hljs-comment">// 将新的等待队列项添加到找到的位置之前。</span><br>    list_add(&amp;wq_entry-&gt;entry, head);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以如果有独占型的进程，那确实不会唤醒其他非独占型的进程，WQ_FLAG_PRIORITY和nr_exclusive决定了最终唤醒的结果，让我们分析下4种组合的情况</p><hr><table><thead><tr><th><strong>场景</strong></th><th><strong>队列中是否有 <code>WQ_FLAG_EXCLUSIVE</code></strong></th><th><strong><code>nr_exclusive</code></strong></th><th><strong>结果</strong></th><th><strong>返回值</strong></th></tr></thead><tbody><tr><td><strong>1</strong> 无独占任务</td><td>否</td><td>1</td><td>所有非独占任务被唤醒；<code>nr_exclusive</code> 不减少</td><td>1</td></tr><tr><td><strong>2</strong> 无独占任务</td><td>否</td><td>0</td><td>所有非独占任务被唤醒；<code>nr_exclusive</code> 不减少</td><td>0</td></tr><tr><td><strong>3</strong> 有独占任务</td><td>是</td><td>1</td><td>唤醒一个独占任务后退出；</td><td>0</td></tr><tr><td><strong>4</strong> 有独占任务</td><td>是</td><td>0</td><td>所有任务（独占和非独占）都被唤醒；<code>nr_exclusive</code> 递减到负数</td><td>负数（最终值）</td></tr></tbody></table><hr><p>其实socket的处理过程中，nr_exclusive一直是1，所以到底唤醒一个进程还是多个，由用户层决定，毕竟WQ_FLAG_EXCLUSIVE是可以设置的。</p><p>2、对于epoll</p><p>epoll在唤醒它的等待队列中的元素时，依次调用了 wake_up_locked() -&gt; __wake_up_locked -&gt; wake_up_common</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> wake_up_locked(x)__wake_up_locked((x), TASK_NORMAL, 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> wake_up_all_locked(x)__wake_up_locked((x), TASK_NORMAL, 0)</span><br></code></pre></td></tr></table></figure><p>wake_up_locked() 和 wake_up_all_locked() 都是用于唤醒等待队列中的进程的宏，最后都调用了 wake_up_common，原理也如上述所示。</p><p>但是因为epoll_wait，将进程设置到epoll的等待链表时，会默认设置WQ_FLAG_EXCLUSIVE（要明白，这里区别于socket的等待队列，因为socket设置时并不会默认设置WQ_FLAG_EXCLUSIVE），且nr_exclusive传了1，按照组合的情况，只会唤醒一个独占进程。</p><h2 id="4、epoll实现原理"><a href="#4、epoll实现原理" class="headerlink" title="4、epoll实现原理"></a>4、epoll实现原理</h2><p>epoll主要涉及3个接口</p><ul><li>epoll_create：创建一个 epoll 对象</li><li>epoll_ctl：向 epoll 对象中添加要管理的连接</li><li>epoll_wait：等待其管理的连接上的 IO 事件</li></ul><h3 id="4-1、epoll-create"><a href="#4-1、epoll-create" class="headerlink" title="4.1、epoll_create"></a>4.1、epoll_create</h3><p>在用户进程调用 epoll_create 时，内核会创建一个 struct eventpoll 的内核对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br><br>    <span class="hljs-comment">//sys_epoll_wait用到的等待队列</span><br>    <span class="hljs-type">wait_queue_head_t</span> wq;<br><br>    <span class="hljs-comment">//接收就绪的描述符都会放到这里</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><br><br>    <span class="hljs-comment">//每个epoll对象中都有一颗红黑树</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span><br><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>eventpoll 这个结构体中的几个成员的含义如下：</p><ul><li><strong>wq：</strong> 等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。</li><li><strong>rbr：</strong> 一棵红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一棵红黑树。通过这棵树来管理用户进程下添加进来的所有 socket 连接。</li><li><strong>rdllist：</strong> 就绪的描述符的链表。当有的连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历整棵树。</li></ul><h3 id="4-2、epoll-ctl"><a href="#4-2、epoll-ctl" class="headerlink" title="4.2、epoll_ctl"></a>4.2、epoll_ctl</h3><p>使用 epoll_ctl 注册每一个 socket 的时候，内核会做如下三件事情</p><ul><li>1.分配一个红黑树节点对象 epitem，</li><li>2.添加等待事件到 socket 的等待队列中，其回调函数是 ep_poll_callback</li><li>3.将 epitem 插入到 epoll 对象的红黑树里</li></ul><p>对于每一个 socket，调用 epoll_ctl 的时候，都会为之分配一个 epitem。该结构的主要数据如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//file: fs/eventpoll.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> &#123;</span><br><br>    <span class="hljs-comment">//红黑树节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span><br><br>    <span class="hljs-comment">//socket文件描述符信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span><br><br>    <span class="hljs-comment">//所归属的 eventpoll 对象</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><br><br>    <span class="hljs-comment">//等待队列</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqlist</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在创建 epitem 并初始化之后，ep_insert 中第二件事情就是设置 socket 对象上的等待任务队列。并把函数 fs&#x2F;eventpoll.c 文件下的 ep_poll_callback 设置为数据就绪时候的回调函数。</p><p>在这个函数里它获取了 sock 对象下的等待队列列表头 wait_queue_head_t，待会等待队列项就插入这里。这里稍微注意下，是 socket 的等待队列，不是 epoll 对象的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//file:include/linux/wait.h</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init_waitqueue_func_entry</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">wait_queue_t</span> *q, <span class="hljs-type">wait_queue_func_t</span> func)</span><br>&#123;<br>    q-&gt;flags = <span class="hljs-number">0</span>;<br>    q-&gt;private = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//ep_poll_callback 注册到 wait_queue_t对象上</span><br>    <span class="hljs-comment">//有数据到达的时候调用 q-&gt;func</span><br>    q-&gt;func = func;   <br>&#125;<br></code></pre></td></tr></table></figure><p>分配完 epitem 对象后，紧接着并把它插入到红黑树中</p><h3 id="4-3、epoll-wait"><a href="#4-3、epoll-wait" class="headerlink" title="4.3、epoll_wait"></a>4.3、epoll_wait</h3><p>当它被调用时它观察 eventpoll-&gt;rdllist 链表里有没有数据即可。有数据就返回，没有数据就创建一个等待队列项，将其添加到 eventpoll 的等待队列上，然后把自己阻塞掉。</p><p>再回顾一下，这里添加到 eventpoll 的等待队列上时，会附带WQ_FLAG_EXCLUSIVE属性。</p><h3 id="4-4、接收数据"><a href="#4-4、接收数据" class="headerlink" title="4.4、接收数据"></a>4.4、接收数据</h3><p>当网卡的数据交到tcp协议栈时，协议栈会找到对应的socket，然后回调socket等待队列中的”epoll”们，找到了 socket 等待队列项里注册的函数 ep_poll_callback，软中断接着就会调用它。首先把自己的 epitem 添加到 epoll 的就绪队列中。接着它又会查看 eventpoll 对象上的等待队列里是否有等待项（epoll_wait 执行的时候会设置）。</p><p>在 __wake_up_common里， 调用 curr-&gt;func。这里的 func 是在 epoll_wait 是传入的 default_wake_function 函数。在default_wake_function 中找到等待队列项里的进程描述符，然后唤醒之。将epoll_wait进程推入可运行队列，等待内核重新调度进程。然后epoll_wait对应的这个进程重新运行后，就从 schedule 恢复</p><p>当进程醒来后，继续从 epoll_wait 时暂停的代码继续执行。把 rdlist 中就绪的事件返回给用户进程，用户进程对其进行处理。</p><hr><p>我觉得<code>epoll</code> 的关键在于它能够让一个进程同时处理多个 <code>socket</code>，而不需要像传统的阻塞 I&#x2F;O那样每次处理一个 <code>socket</code>，然后进入阻塞睡眠，等到有新事件再唤醒。这种方式显著减少了进程切换的开销，从而提升了处理性能。</p><p>虽然 <code>epoll</code> 本身是通过 <code>epoll_wait</code> 阻塞来等待事件的触发，但它提供了一种非阻塞的方式来处理每个 <code>socket</code> 的 I&#x2F;O 操作。具体来说，<code>socket</code> 可以设置为非阻塞模式，在调用 <code>read</code> 或 <code>write</code> 时，如果没有数据可读或无法立即写入，系统会返回一个错误码，而不是阻塞进程。</p><p>epoll 不负责真正的数据读写，它只是告诉用户程序哪些 <code>socket</code> 可以进行读写操作。在真正的异步 I&#x2F;O 模型（如 <code>io_uring</code> 或 POSIX AIO）中，应用程序发起 I&#x2F;O 操作后立即返回，由内核或驱动完成 I&#x2F;O 操作，并通过回调或信号通知操作结果。所以epoll 的工作方式仍然需要应用程序显式调用处理函数，因此是同步的。</p><hr><h2 id="5、nginx如何支持IO复用"><a href="#5、nginx如何支持IO复用" class="headerlink" title="5、nginx如何支持IO复用"></a>5、nginx如何支持IO复用</h2><p>Nginx 本质上属于 <strong>异步非阻塞</strong> 模型。在处理请求时，Nginx 不会因为等待某个操作完成（如读取数据）而阻塞当前进程，而是通过事件驱动机制在 I&#x2F;O 操作完成时继续处理请求。虽然 Nginx 使用的是异步方式，但它依赖操作系统（如 <code>epoll</code>）来管理事件的触发和 I&#x2F;O 操作的完成，Nginx 自己并不处理底层的 I&#x2F;O 操作，而是通过事件循环和回调的方式继续处理其他任务。</p><h3 id="5-1、nginx怎么选择IO复用"><a href="#5-1、nginx怎么选择IO复用" class="headerlink" title="5.1、nginx怎么选择IO复用"></a>5.1、nginx怎么选择IO复用</h3><p>nginx在初始化事件模块时，根据系统支持的事件模型（如epoll、devpoll、kqueue、select）选择一个合适的事件模块，支持哪些模型由编译期决定，比如linux支持epoll，windows支持kqueue，因此编译的宏也是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_EPOLL) &amp;&amp; !(NGX_TEST_BUILD_EPOLL)</span><br><br>    fd = epoll_create(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) &#123;<br>        (<span class="hljs-type">void</span>) close(fd);<br>        module = &amp;ngx_epoll_module;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_errno != NGX_ENOSYS) &#123;<br>        module = &amp;ngx_epoll_module;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>...........................<br>    <br>    event_module = module-&gt;ctx;<br></code></pre></td></tr></table></figure><p>定义ngx_epoll_module_ctx</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_str_t</span>              *name;<br><br>    <span class="hljs-type">void</span>                 *(*create_conf)(<span class="hljs-type">ngx_cycle_t</span> *cycle);<br>    <span class="hljs-type">char</span>                 *(*init_conf)(<span class="hljs-type">ngx_cycle_t</span> *cycle, <span class="hljs-type">void</span> *conf);<br><br>    <span class="hljs-type">ngx_event_actions_t</span>     actions;   <span class="hljs-comment">//定义的方法集合</span><br>&#125; <span class="hljs-type">ngx_event_module_t</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;<br>    &amp;epoll_name,<br>    ngx_epoll_create_conf,               <span class="hljs-comment">/* create configuration */</span><br>    ngx_epoll_init_conf,                 <span class="hljs-comment">/* init configuration */</span><br><br>    &#123;<br>        ngx_epoll_add_event,             <span class="hljs-comment">/* add an event */</span><br>        ngx_epoll_del_event,             <span class="hljs-comment">/* delete an event */</span><br>        ngx_epoll_add_event,             <span class="hljs-comment">/* enable an event */</span><br>        ngx_epoll_del_event,             <span class="hljs-comment">/* disable an event */</span><br>        ngx_epoll_add_connection,        <span class="hljs-comment">/* add an connection */</span><br>        ngx_epoll_del_connection,        <span class="hljs-comment">/* delete an connection */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_EVENTFD)</span><br>        ngx_epoll_notify,                <span class="hljs-comment">/* trigger a notify */</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-literal">NULL</span>,                            <span class="hljs-comment">/* trigger a notify */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        ngx_epoll_process_events,        <span class="hljs-comment">/* process the events */</span><br>        ngx_epoll_init,                  <span class="hljs-comment">/* init the events */</span><br>        ngx_epoll_done,                  <span class="hljs-comment">/* done the events */</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>epoll初始化时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_event_actions = ngx_epoll_module_ctx.actions;<br></code></pre></td></tr></table></figure><p>设置事件模块的回调为epoll的函数，如果使用的是poll，那将会是poll的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_process_events   ngx_event_actions.process_events</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_done_events      ngx_event_actions.done</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_add_event        ngx_event_actions.add</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_del_event        ngx_event_actions.del</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_add_conn         ngx_event_actions.add_conn</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_del_conn         ngx_event_actions.del_conn</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_notify           ngx_event_actions.notify</span><br></code></pre></td></tr></table></figure><h3 id="5-2、EPOLLEXCLUSIVE的问题"><a href="#5-2、EPOLLEXCLUSIVE的问题" class="headerlink" title="5.2、EPOLLEXCLUSIVE的问题"></a>5.2、EPOLLEXCLUSIVE的问题</h3><p>对于epoll，nginx默认就开启了EPOLLEXCLUSIVE，但是存在一个问题，nginx是这么描述的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Linux with EPOLLEXCLUSIVE 通常只通知第一个将监听套接字添加到 epoll 实例的进程。</span><br><span class="hljs-comment">    * 因此，大多数连接都由第一个工作进程处理。为了解决这个问题，我们会定期重新添加套接字，</span><br><span class="hljs-comment">    * 以便其他工作进程也有机会接受连接。</span><br><span class="hljs-comment">    */</span><br></code></pre></td></tr></table></figure><p>由3.4可以知道，在添加独占型的进程时，独占型的进程总是处在链表的前面，但是当有多个独占型的进程时，后加的就会排在独占型后面</p><p>A（非独占）B（独占）C（独占）D（非独占）</p><p>A</p><p>B-&gt;A</p><p>B-&gt;C-&gt;A</p><p>B-&gt;C-&gt;A-&gt;D</p><p>这里的C就是后面注册的，这导致连接事件都会被B处理掉，因此nginx做了优化，当一个socket的连接数大于16时，重新将这个socket添加到epoll中。即如果B处理的连接过多，就重新注册B，那么链表的顺序就会变为</p><p>C-&gt;B-&gt;A-&gt;D</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_EPOLLEXCLUSIVE)</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_reorder_accept_events</span><span class="hljs-params">(<span class="hljs-type">ngx_listening_t</span> *ls)</span><br>&#123;<br>    <span class="hljs-type">ngx_connection_t</span>  *c;<br>    <br>    <span class="hljs-comment">// 如果没有启用独占接受，则直接返回</span><br>    <span class="hljs-keyword">if</span> (!ngx_use_exclusive_accept) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br>    <span class="hljs-comment">// 如果启用了端口复用，则直接返回</span><br>    <span class="hljs-keyword">if</span> (ls-&gt;reuseport) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 获取连接对象</span><br>    c = ls-&gt;connection;<br><br>    <span class="hljs-comment">// 如果请求计数不是 16 的倍数，并且接受禁用计数器小于等于 0，则直接返回</span><br>    <span class="hljs-keyword">if</span> (c-&gt;requests++ % <span class="hljs-number">16</span>!= <span class="hljs-number">0</span><br>        &amp;&amp; ngx_accept_disabled &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 epoll 中删除读事件</span><br>    <span class="hljs-keyword">if</span> (ngx_del_event(c-&gt;read, NGX_READ_EVENT, NGX_DISABLE_EVENT)<br>        == NGX_ERROR)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 将读事件重新添加到 epoll 中，并设置为独占模式</span><br>    <span class="hljs-keyword">if</span> (ngx_add_event(c-&gt;read, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)<br>        == NGX_ERROR)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>但是有人报告这个补丁使性能下降10%，于是我使用1.27版本做一个性能测试对比</p><p><strong>wrk -t10 -c500 -d10s <a href="http://127.0.0.1/">http://127.0.0.1:80</a></strong></p><ul><li><code>-t10</code>：<code>wrk</code>将使用10个线程来发送HTTP请求。</li><li><code>-c500</code>：每个线程将保持500个HTTP连接。因此，总共会有<code>10*500=5000</code>个HTTP连接。</li><li><code>-d10s</code>：测试将运行10秒钟。</li></ul><p>机器性能  <strong>2C2G</strong></p><p>1、正常版本测试</p><table><thead><tr><th></th><th align="center">请求速率(Requests&#x2F;sec)</th><th align="center">延迟(Avg)&#x2F;ms</th></tr></thead><tbody><tr><td>1</td><td align="center">17090.42</td><td align="center">49.61</td></tr><tr><td>2</td><td align="center">17432.39</td><td align="center">41.05</td></tr><tr><td>3</td><td align="center">17204.18</td><td align="center">38.19</td></tr><tr><td>4</td><td align="center">18132.32</td><td align="center">29.42</td></tr><tr><td>5</td><td align="center">18691.90</td><td align="center">33.30</td></tr><tr><td>6</td><td align="center">17703.41</td><td align="center">32.45</td></tr><tr><td>7</td><td align="center">17217.81</td><td align="center">39.34</td></tr><tr><td>8</td><td align="center">16366.40</td><td align="center">43.62</td></tr><tr><td>9</td><td align="center">17850.73</td><td align="center">40.91</td></tr><tr><td>平均</td><td align="center">17521.06</td><td align="center">38.65</td></tr></tbody></table><p>2、去掉补丁</p><table><thead><tr><th></th><th align="center">请求速率(Requests&#x2F;sec)</th><th align="center">延迟(Avg)&#x2F;ms</th></tr></thead><tbody><tr><td>1</td><td align="center">16526.34</td><td align="center">40.29</td></tr><tr><td>2</td><td align="center">16450.97</td><td align="center">44.82</td></tr><tr><td>3</td><td align="center">16267.48</td><td align="center">42.94</td></tr><tr><td>4</td><td align="center">15692.15</td><td align="center">41.11</td></tr><tr><td>5</td><td align="center">15625.75</td><td align="center">46.53</td></tr><tr><td>6</td><td align="center">15756.77</td><td align="center">41.79</td></tr><tr><td>7</td><td align="center">15714.21</td><td align="center">44.25</td></tr><tr><td>8</td><td align="center">15693.36</td><td align="center">46.92</td></tr><tr><td>9</td><td align="center">16354.10</td><td align="center">57.01</td></tr><tr><td>平均</td><td align="center">16009.01</td><td align="center">45.67</td></tr></tbody></table><p>事实上性能并没有下降，还有提升，这个补丁会提升9.44%的QPS。</p><h3 id="5-3、SO-REUSEPORT属性"><a href="#5-3、SO-REUSEPORT属性" class="headerlink" title="5.3、SO_REUSEPORT属性"></a>5.3、SO_REUSEPORT属性</h3><p>首先在进程初始化解析配置时，会判断一个端口是否开启了reuseport，如果开启了，套接字 <code>nls[n]</code> 的 <code>reuseport</code> 标志为真</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br>                    <span class="hljs-keyword">if</span> (nls[n].reuseport &amp;&amp; !ls[i].reuseport) &#123;<br>                        nls[n].add_reuseport = <span class="hljs-number">1</span>;  <span class="hljs-comment">//</span><br>                    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>每个进程初始化event模块配置时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br><br>    <span class="hljs-comment">// 获取核心配置结构体</span><br>    ccf = (<span class="hljs-type">ngx_core_conf_t</span> *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);<br><br>    <span class="hljs-comment">// 如果不是测试配置且master进程存在，则进行端口复用处理</span><br>    <span class="hljs-keyword">if</span> (!ngx_test_config &amp;&amp; ccf-&gt;master) &#123;<br><br>        <span class="hljs-comment">// 获取监听套接字数组</span><br>        ls = cycle-&gt;listening.elts;<br>        <span class="hljs-comment">// 遍历所有监听套接字</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;<br><br>            <span class="hljs-comment">// 跳过未启用reuseport或worker不为0的监听套接字</span><br>            <span class="hljs-keyword">if</span> (!ls[i].reuseport || ls[i].worker != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 克隆监听套接字，如果克隆失败，则返回配置错误</span><br>            <span class="hljs-keyword">if</span> (ngx_clone_listening(cycle, &amp;ls[i]) != NGX_OK) &#123;<br>                <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>            &#125;<br><br>            <span class="hljs-comment">// 克隆操作可能更改cycle-&gt;listening.elts指针，因此重新获取指针</span><br>            ls = cycle-&gt;listening.elts;<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>关键是ngx_clone_listening：克隆当前监听套接字，为每个 <code>worker</code> 进程创建一个独立的监听实例，并设置其worker属性</p><ul><li>每个克隆的监听套接字会分配给一个 <code>worker</code>，并具有独立的监听队列。</li><li>这样每个进程能独立处理自己的客户端连接，避免锁争用，提高性能。</li></ul><p>每个进程初始化时，确保每个工作进程（worker）只保留属于自己的监听套接字，关闭那些不属于自己的套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br>        <span class="hljs-comment">// 检查当前监听套接字是否启用了reuseport选项并且不是当前工作进程的</span><br>        <span class="hljs-keyword">if</span> (ls[i].reuseport &amp;&amp; ls[i].worker != ngx_worker) &#123;<br>            <span class="hljs-comment">// 如果是，记录调试信息并关闭该套接字</span><br>            ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;closing unused fd:%d listening on %V&quot;</span>,<br>                           ls[i].fd, &amp;ls[i].addr_text);<br><br>            <span class="hljs-comment">// 关闭套接字并检查是否成功</span><br>            <span class="hljs-keyword">if</span> (ngx_close_socket(ls[i].fd) == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-comment">// 如果关闭失败，记录错误信息</span><br>                ngx_log_error(NGX_LOG_EMERG, cycle-&gt;<span class="hljs-built_in">log</span>, ngx_socket_errno,<br>                              ngx_close_socket_n <span class="hljs-string">&quot; %V failed&quot;</span>,<br>                              &amp;ls[i].addr_text);<br>            &#125;<br><br>            <span class="hljs-comment">// 将套接字描述符设置为无效值</span><br>            ls[i].fd = (<span class="hljs-type">ngx_socket_t</span>) <span class="hljs-number">-1</span>;<br><br>            <span class="hljs-comment">// 继续处理下一个监听套接字</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>最后看一下将epoll注册到socket内核中，ngx_add_event  -&gt;  epoll_ctl</p><ul><li>开启了reuseport时，将本进程的epoll注册到socket</li><li>开启了EPOLLEXCLUSIVE时，将本进程的epoll独占式的注册到socket</li><li>如果什么都没开启，则将本进程的epoll注册到socket</li></ul><p>其中<br>c &#x3D; rev-&gt;-&gt;data</p><p>c-&gt;fd就是本进程监听的socket，在上面已经设置过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果定义了NGX_HAVE_REUSEPORT宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br><br>        <span class="hljs-comment">// 如果当前监听套接字启用了reuseport选项</span><br>        <span class="hljs-keyword">if</span> (ls[i].reuseport) &#123;<br>            <span class="hljs-comment">// 尝试为读事件添加epoll事件，如果不成功则返回错误</span><br>            <span class="hljs-keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="hljs-number">0</span>) == NGX_ERROR) &#123;<br>                <span class="hljs-keyword">return</span> NGX_ERROR;<br>            &#125;<br><br>            <span class="hljs-comment">// 继续处理下一个监听套接字</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// 如果使用了accept mutex机制，则跳过添加epoll事件</span><br>        <span class="hljs-keyword">if</span> (ngx_use_accept_mutex) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br><span class="hljs-comment">// 如果定义了NGX_HAVE_EPOLLEXCLUSIVE宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_EPOLLEXCLUSIVE)</span><br><br>        <span class="hljs-comment">// 如果使用了epoll事件模型且配置了多个工作进程</span><br>        <span class="hljs-keyword">if</span> ((ngx_event_flags &amp; NGX_USE_EPOLL_EVENT)<br>            &amp;&amp; ccf-&gt;worker_processes &gt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 启用exclusive accept模式</span><br>            ngx_use_exclusive_accept = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// 尝试以独占方式为读事件添加epoll事件，如果不成功则返回错误</span><br>            <span class="hljs-keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, NGX_EXCLUSIVE_EVENT)<br>                == NGX_ERROR)<br>            &#123;<br>                <span class="hljs-keyword">return</span> NGX_ERROR;<br>            &#125;<br><br>            <span class="hljs-comment">// 继续处理下一个监听套接字</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// 如果上述条件都不满足，尝试为读事件添加epoll事件，如果不成功则返回错误</span><br>        <span class="hljs-keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="hljs-number">0</span>) == NGX_ERROR) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br></code></pre></td></tr></table></figure><p>最后再看下不使用reuseport，常规使用锁的情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 检查是否需要使用接受互斥锁</span><br><span class="hljs-keyword">if</span> (ngx_use_accept_mutex) &#123;<br>    <span class="hljs-comment">// 如果接受互斥锁被禁用，则递减禁用计数器</span><br>    <span class="hljs-keyword">if</span> (ngx_accept_disabled &gt; <span class="hljs-number">0</span>) &#123;<br>        ngx_accept_disabled--;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 尝试获取接受互斥锁</span><br>        <span class="hljs-keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 根据互斥锁是否已被持有来决定事件的处理方式</span><br>        <span class="hljs-keyword">if</span> (ngx_accept_mutex_held) &#123;<br>            flags |= NGX_POST_EVENTS;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 调整定时器以适应接受互斥锁的延迟</span><br>            <span class="hljs-keyword">if</span> (timer == NGX_TIMER_INFINITE<br>                || timer &gt; ngx_accept_mutex_delay)<br>            &#123;<br>                timer = ngx_accept_mutex_delay;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4、实际操作"><a href="#5-4、实际操作" class="headerlink" title="5.4、实际操作"></a>5.4、实际操作</h3><p>nginx开启了1个master，2个work，且开启了reuseport</p><p><img src="/img/%E5%BC%80%E5%90%AFreuseport.png" alt="开启reuseport"></p><p>来看下没有启用reuseport的情况</p><p><img src="/img/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9B%91%E5%90%AC%E4%B8%80%E4%B8%AAsocket.png" alt="多进程监听一个socket"></p><p>可以明显看到开启reuseport后，不同的work会监听自己的socket。而根据实际的性能测试来看，开启reuseport可以明显提升性能。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>参考自：《深入理解linux网络》第三章<br>linux版本：6.12<br>nginx代码：1.27</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>epoll</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ingress-nginx使用limit_except的问题</title>
    <link href="/2024/08/25/Problems%20with%20ingress-nginx%20using%20limit_except/"/>
    <url>/2024/08/25/Problems%20with%20ingress-nginx%20using%20limit_except/</url>
    
    <content type="html"><![CDATA[<h2 id="1、错误的返回-503"><a href="#1、错误的返回-503" class="headerlink" title="1、错误的返回-503"></a>1、错误的返回-503</h2><p>起因是ingress-nginx有人提了一个issue：<a href="https://github.com/kubernetes/ingress-nginx/issues/11742">https://github.com/kubernetes/ingress-nginx/issues/11742</a> ，使用limit_except时没有得到预期的403，而是得到了503，首先看下怎么复现</p><p>首先得有一个kubernetes环境，启动一个服务节点foo，然后安装ingress-nginx，ingress的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/configuration-snippet:</span> <span class="hljs-string">limit_except</span> <span class="hljs-string">GET</span> &#123; <span class="hljs-string">deny</span> <span class="hljs-string">all;</span> &#125;<br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/server-snippet:</span> <span class="hljs-string">|</span><br><span class="hljs-string">      location  =/ &#123;</span><br><span class="hljs-string">        return 403;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string"></span><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/foo</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">foo-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>这个配置的含义是，只允许get请求请求foo，其余请求一律为403，比如一个POST请求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -X POST http://172.xx.xx.xx:32080/foo<br></code></pre></td></tr></table></figure><p>按照正常思维来说应该返回403，但是返回了503？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;503 Service Temporarily Unavailable&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;503 Service Temporarily Unavailable&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>难道是nginx&#x2F;openresty的问题吗？于是在openresty快速测试一下，配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">5678</span>;<br>        <span class="hljs-attribute">server_name</span> ZJfans.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">limit_except</span> GET &#123;<br>                <span class="hljs-attribute">deny</span> all;<br>            &#125;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">200</span>;<br>        &#125;<br>    <br>        <span class="hljs-section">location</span> = / &#123;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>        &#125;<br>    <br>        <span class="hljs-section">location</span> = /foo &#123;<br>            <span class="hljs-attribute">limit_except</span> GET &#123;<br>                <span class="hljs-attribute">deny</span> all;<br>            &#125;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">200</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>测试的结果,post确实返回了403，所以openresty本身没有问题，那么问题就出在ingress-nginx</p><p><img src="/img/limit_except-%E5%9B%BE1.png" alt="openresty测试limit_except"></p><h2 id="2、ingress的nginx-conf配置"><a href="#2、ingress的nginx-conf配置" class="headerlink" title="2、ingress的nginx.conf配置"></a>2、ingress的nginx.conf配置</h2><p>现在来看下ingress生成的nginx.conf有什么特殊的，只看重点</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> = /foo &#123;                                    <br>                                                           <br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$namespace</span>      <span class="hljs-string">&quot;default&quot;</span>;                <br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$ingress_name</span>   <span class="hljs-string">&quot;foo-ingress&quot;</span>;<br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$service_name</span>   <span class="hljs-string">&quot;foo-service&quot;</span>;         <br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$service_port</span>   <span class="hljs-string">&quot;8080&quot;</span>;                 <br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$location_path</span>  <span class="hljs-string">&quot;/foo&quot;</span>;<br>                        <span class="hljs-attribute">set</span> <span class="hljs-variable">$global_rate_limit_exceeding</span> n;         <br>                                                                       <br>                        <span class="hljs-section">rewrite_by_lua_block</span> &#123;                        <br>                                lua_ingress.rewrite(&#123;                                             <br>                                        <span class="hljs-attribute">force_ssl_redirect</span> = <span class="hljs-literal">false</span>,           <br>                                        ssl_redirect = <span class="hljs-literal">true</span>,      <br>                                        force_no_ssl_redirect = <span class="hljs-literal">false</span>,<br>                                        preserve_trailing_slash = <span class="hljs-literal">false</span>,<br>                                        use_port_in_redirects = <span class="hljs-literal">false</span>,<br>                                        global_throttle = &#123; <span class="hljs-attribute">namespace</span> = <span class="hljs-string">&quot;&quot;</span>, limit = <span class="hljs-number">0</span>, window_size = <span class="hljs-number">0</span>, key = &#123; &#125;, <span class="hljs-attribute">ignored_cidrs</span> = &#123; &#125; &#125;,<br>                                &#125;)                                 <br>                                balancer.rewrite()          <br>                                plugins.run()                         <br>                        &#125;<br>    <br>                   <span class="hljs-attribute">set</span> <span class="hljs-variable">$proxy_upstream_name</span> <span class="hljs-string">&quot;default-foo-service-8080&quot;</span>;<br>    <br>                   <span class="hljs-comment">#   ............................................... </span><br>                   <span class="hljs-comment">#   ..................忽略海量配置............................. </span><br>                   <span class="hljs-comment">#   ............................................... </span><br>                                                                                                      <br>                        <span class="hljs-attribute">limit_except</span> GET &#123; <span class="hljs-attribute">deny</span> all; &#125;                                                     <br>                                                                                                                                    <br>                                                                                                     <br>                        <span class="hljs-attribute">proxy_pass</span> http://upstream_balancer;                                          <br>                                                                                                      <br>                        <span class="hljs-attribute">proxy_redirect</span>                          <span class="hljs-literal">off</span>;                                 <br>                                                                                                      <br>                &#125;<br></code></pre></td></tr></table></figure><p>测试了一下，我发现balancer.rewrite()是问题的关键，这其实是balancer初始化的一个实例，那么我们来看看这块代码</p><h2 id="3、balancer-lua"><a href="#3、balancer-lua" class="headerlink" title="3、balancer.lua"></a>3、balancer.lua</h2><p>可以看到这里确实返回了503，那么为什么get_balancer()会失败呢？</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_M.rewrite</span><span class="hljs-params">()</span></span><br>  <span class="hljs-keyword">local</span> balancer = get_balancer()<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancer <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_SERVICE_UNAVAILABLE<br>    <span class="hljs-keyword">return</span> ngx.<span class="hljs-built_in">exit</span>(ngx.<span class="hljs-built_in">status</span>)<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>现在来看看get_balancer的实现，其实就是，没有获取到balancer返回了nil</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_balancer</span><span class="hljs-params">()</span></span><br>  <span class="hljs-keyword">if</span> ngx.ctx.balancer <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> ngx.ctx.balancer<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> backend_name = ngx.var.proxy_upstream_name<br><br>  <span class="hljs-keyword">local</span> balancer = balancers[backend_name]<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancer <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>  <span class="hljs-keyword">end</span><br><br> <span class="hljs-comment">-- ......................省略............................</span><br><br>  <span class="hljs-keyword">return</span> balancer<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>现在来看为什么没有获取到balancer，首先使用ngx.say输出一下backend_name，我发现是一个  ”-“，这其实很奇怪，因为nginx.conf是这么设置的</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">set</span> <span class="hljs-variable">$proxy_upstream_name</span> <span class="hljs-string">&quot;default-foo-service-8080&quot;</span>;<br></code></pre></td></tr></table></figure><p>照理ngx.var.proxy_upstream_name可以取到的值是default-foo-service-8080，那为什么会变成   -  ？这又到了openresty的问题了，这时我们需要研究一下limit_except的源码</p><h2 id="4、limit-except代码"><a href="#4、limit-except代码" class="headerlink" title="4、limit_except代码"></a>4、limit_except代码</h2><p>简单研究一下，直接来看关键的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_update_location_config</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    <span class="hljs-type">ngx_http_core_loc_conf_t</span>  *clcf;<br><br>    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);<br><br>    <span class="hljs-keyword">if</span> (r-&gt;method &amp; clcf-&gt;limit_except) &#123;<br>        r-&gt;loc_conf = clcf-&gt;limit_except_loc_conf;<br>        clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);<br>    &#125;<br><span class="hljs-comment">// ..................................省略....................................</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>关键在于r-&gt;loc_conf &#x3D; clcf-&gt;limit_except_loc_conf;这里切换了r的loc，配置进行了更新，在 Nginx 中，<code>r-&gt;loc_conf = clcf-&gt;limit_except_loc_conf;</code> 这行代码用于处理特定请求方法时的配置切换。具体来说，当客户端请求的 HTTP 方法不在 <code>limit_except</code> 指定的允许范围内时，Nginx 会将该请求的 <code>loc_conf</code>（location 配置）切换到为该方法配置的 <code>limit_except_loc_conf</code>。</p><p><strong>举个具体的例子：</strong></p><p>假设有如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">5678</span>;<br>        <span class="hljs-attribute">server_name</span> ZJfans.com;<br><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">limit_except</span> GET &#123;<br>                <span class="hljs-attribute">deny</span> all;<br>            &#125;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">200</span>;<br>        &#125;<br>    <br>        <span class="hljs-section">location</span> = / &#123;<br>            <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>        &#125;<br>    <br>        <span class="hljs-section">location</span> /foo &#123;<br>            <span class="hljs-attribute">set</span> <span class="hljs-variable">$proxy_upstream_name</span> <span class="hljs-string">&quot;default-foo-service-8080&quot;</span>;<br><br>            <span class="hljs-section">rewrite_by_lua_block</span> &#123;<br>                <span class="hljs-attribute">local</span> upstream_name = ngx.var.proxy_upstream_name<br>                ngx.log(ngx.INFO, <span class="hljs-string">&quot;Proxy upstream name: &quot;</span>, upstream_name)<br>            &#125;<br><br>            limit_except GET &#123;<br>                <span class="hljs-attribute">deny</span> all;<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个配置中：</p><ol><li><p><strong>配置结构</strong>：</p><ul><li><code>clcf-&gt;limit_except</code> 保存了限制条件，即允许的 HTTP 方法，这里是 <code>GET</code> 和 <code>POST</code>。</li><li><code>clcf-&gt;limit_except_loc_conf</code> 是一个指向 <code>limit_except</code> 条件下的特定 location 配置结构的指针。</li></ul></li><li><p><strong>请求处理</strong>：</p><ul><li>当一个请求到达 <code>/foo</code> 路径时，Nginx 首先会根据请求的方法来检查 <code>clcf-&gt;limit_except</code> 中的配置。</li><li>如果请求方法是 <code>GET</code> ，则继续使用原始的 <code>loc_conf</code> 处理请求，执行 <code>rewrite_by_lua_block</code> 等其他配置。</li><li>如果请求方法是其他方法（如 <code>DELETE</code> 或 <code>POST</code>），代码中的 <code>if (r-&gt;method &amp; clcf-&gt;limit_except)</code> 条件会成立，Nginx 会将 <code>r-&gt;loc_conf</code> 切换到 <code>clcf-&gt;limit_except_loc_conf</code>，即对应限制方法的特定配置。这时，Nginx 可能会直接拒绝请求或应用不同的配置。</li></ul></li><li><p><strong>具体行为</strong>：</p><ul><li>当请求方法是 <code>GET</code> 或时，<code>r-&gt;loc_conf</code> 保持为原始的配置，执行 <code>rewrite_by_lua_block</code>，可以打印 <code>proxy_upstream_name</code>。</li><li>当请求方法是 <code>POST</code>，<code>r-&gt;loc_conf</code> 切换为 <code>limit_except_loc_conf</code>，此时不再执行 <code>rewrite_by_lua_block</code>，直接应用 <code>deny all</code>，返回 403 错误。</li></ul></li></ol><p><strong>所以如果请求方法是 <code>POST</code>，ngx.var.proxy_upstream_name根本就获取不到值，因为此时配置更新为limit_except的loc，在locatioon设置的变量都无法访问到，nginx会报错<code>using uninitialized</code>，此时问题已经定位到了，这是nginx的限制</strong></p><p><img src="/img/limit_except-%E5%9B%BE2.png" alt="获取location设置的变量失败"></p><p>再深入一下，如果把set $proxy_upstream_name “default-foo-service-8080”;设置为server级别呢，是否可以获取到这个变量？</p><p>答案是可以的，因为现在只是替换了location级别的配置，server级别的配置并没有更新，可以正常获取</p><h2 id="5、验证–调试balancer-lua"><a href="#5、验证–调试balancer-lua" class="headerlink" title="5、验证–调试balancer.lua"></a>5、验证–调试balancer.lua</h2><h3 id="5-1、”-“-从哪里来的"><a href="#5-1、”-“-从哪里来的" class="headerlink" title="5.1、”-“ 从哪里来的"></a>5.1、”-“ 从哪里来的</h3><p>来看nginx.conf的配置，server里面设置了默认值，所以  -  就是从这里来的</p><p><img src="/img/limit_except-%E5%9B%BE3.png" alt="proxy_upstream_name设置初始值为&quot;-&quot;"></p><h3 id="5-2、balancers结构"><a href="#5-2、balancers结构" class="headerlink" title="5.2、balancers结构"></a>5.2、balancers结构</h3><p>回到balancer.lua，我对balancers的结构体挺好奇的，于是打印一下，看下具体的配置</p><p>1、查看</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua">ocal <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_balancer</span><span class="hljs-params">()</span></span>                                      <br>  <span class="hljs-keyword">if</span> ngx.ctx.balancer <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> ngx.ctx.balancer                                <br>  <span class="hljs-keyword">end</span>                                                      <br>                                                           <br>  <span class="hljs-keyword">local</span> backend_name = ngx.var.proxy_upstream_name <br>    <br><span class="hljs-comment">---------------------------------------begin---------------------------------</span><br>  backend_name = <span class="hljs-string">&quot;default-foo-service-8080&quot;</span>     <span class="hljs-comment">--设置正确的值</span><br>    <br>  <span class="hljs-keyword">local</span> balancer = balancers[backend_name] <br>   <br>  <span class="hljs-keyword">if</span> balancer <span class="hljs-keyword">then</span>                                   <span class="hljs-comment">--返回数据结构  </span><br>    <span class="hljs-keyword">local</span> balancer_json = cjson.encode(balancer)  <br>    ngx.header[<span class="hljs-string">&quot;Content-Type&quot;</span>] = <span class="hljs-string">&quot;application/json&quot;</span><br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_OK                      <br>    ngx.say(balancer_json)                         <br>  <span class="hljs-keyword">end</span><br><span class="hljs-comment">---------------------------------------end-----------------------------------</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancer <span class="hljs-keyword">then</span>                     <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>                                  <br>  <span class="hljs-keyword">end</span> <br></code></pre></td></tr></table></figure><p>请求&#x2F;响应</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -X POST http://172.xx.xx.xx:32080/foo<br><br>&#123;&quot;traffic_shaping_policy&quot;:&#123;&quot;weight&quot;:0,&quot;cookie&quot;:&quot;&quot;,&quot;headerPattern&quot;:&quot;&quot;,&quot;headerValue&quot;:&quot;&quot;,&quot;header&quot;:&quot;&quot;,&quot;weightTotal&quot;:0&#125;,&quot;instance&quot;:&#123;&quot;nodes&quot;:&#123;&quot;10.233.xx.xx:5678&quot;:1&#125;,&quot;gcd&quot;:1,&quot;only_key&quot;:&quot;10.233.xx.xx:5678&quot;,&quot;cw&quot;:1,&quot;last_id&quot;:&quot;10.233.xx.xx:5678&quot;,&quot;max_weight&quot;:1&#125;&#125;<br></code></pre></td></tr></table></figure><p>所以如果正常能取到proxy_upstream_name的值，也是能取到balancer的</p><h2 id="6、如何修复"><a href="#6、如何修复" class="headerlink" title="6、如何修复"></a>6、如何修复</h2><p>按照我的初步想法，简单粗暴，在proxy_upstream_name没有被重新赋值时，直接返回403。因为使用了limit_except 后，location设置的proxy_upstream_name将无法被获取，肯定为  - ，所以可以认为只要是  -，就是使用了limit_except？返回403也比较合理。</p><p>唯一的问题是，会不会有其他指令，也会导致这个情况，但是他需要返回其他的状态码，这个暂时还没想到有，nginx的指令很多，需要慢慢确认</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get_balancer</span><span class="hljs-params">()</span></span><br>  <span class="hljs-keyword">if</span> ngx.ctx.balancer <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> ngx.ctx.balancer<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">local</span> backend_name = ngx.var.proxy_upstream_name<br><span class="hljs-comment">---------------------------------------begin---------------------------------</span><br>  <span class="hljs-keyword">if</span> backend_name == <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">then</span><br>    ngx.<span class="hljs-built_in">status</span> = ngx.HTTP_FORBIDDEN<br>    <span class="hljs-keyword">return</span> ngx.<span class="hljs-built_in">exit</span>(ngx.<span class="hljs-built_in">status</span>)                                                     <br>  <span class="hljs-keyword">end</span><br><span class="hljs-comment">---------------------------------------end-----------------------------------</span><br>  <span class="hljs-keyword">local</span> balancer = balancers[backend_name]<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> balancer <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-comment">-- ......................省略............................</span><br>  <span class="hljs-keyword">return</span> balancer<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>–</p><p>已经向社区反馈该问题的进展，结果后续会更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>ingress-nginx</tag>
      
      <tag>limit_except</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc编译选项--fcommon</title>
    <link href="/2024/08/17/gcc%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9--fcommon/"/>
    <url>/2024/08/17/gcc%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9--fcommon/</url>
    
    <content type="html"><![CDATA[<h2 id="multiple-definition"><a href="#multiple-definition" class="headerlink" title="multiple definition"></a>multiple definition</h2><p>最近在龙蜥操作系统编译时，出现了multiple definition的错误，重复定义？查看了代码，有几个变量确实是重复定义了，简单来讲就是在一个.h文件定义了一个变量，多个.c文件又包含了这个.h，导致这个变量在多个.c文件重复定义，在编译时报错。</p><p>修复也很简单，.h文件的中的变量统一加extern，然后只有一个.c文件才能定义初始化这个变量，这样就可以避免重复定义，也顺利编译成功。</p><h2 id="gcc的版本"><a href="#gcc的版本" class="headerlink" title="gcc的版本"></a>gcc的版本</h2><p>代码确实存在问题，不过其他操作系统并不会报错，只是一个警告，因此我很好奇这是为什么。网上搜索后，发现了一篇很好的文章：<a href="https://club.rt-thread.org/ask/article/5fb1ecf297a83492.html">https://club.rt-thread.org/ask/article/5fb1ecf297a83492.html</a>    ，gcc版本在10版本后，关闭了 fcommon选项，使用了fno-common，来看看这个选项的描述：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">-fcommon<br>In C code, this option controls <span class="hljs-keyword">the</span> placement <span class="hljs-keyword">of</span> <span class="hljs-built_in">global</span> variables defined <span class="hljs-keyword">without</span> <span class="hljs-keyword">an</span> initializer, known <span class="hljs-keyword">as</span> tentative definitions <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> C standard. Tentative definitions are distinct <span class="hljs-built_in">from</span> declarations <span class="hljs-keyword">of</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">variable</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> extern keyword, which <span class="hljs-built_in">do</span> <span class="hljs-keyword">not</span> allocate storage.<br><br>The default is -fno-common, which specifies that <span class="hljs-keyword">the</span> compiler places uninitialized <span class="hljs-built_in">global</span> variables <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> BSS section <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> object <span class="hljs-built_in">file</span>. This inhibits <span class="hljs-keyword">the</span> merging <span class="hljs-keyword">of</span> tentative definitions <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> linker so you <span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span> multiple-definition error <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">variable</span> is accidentally defined <span class="hljs-keyword">in</span> more than <span class="hljs-literal">one</span> compilation unit.<br><br>The -fcommon places uninitialized <span class="hljs-built_in">global</span> variables <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> common block. This allows <span class="hljs-keyword">the</span> linker <span class="hljs-built_in">to</span> <span class="hljs-built_in">resolve</span> all tentative definitions <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> same <span class="hljs-built_in">variable</span> <span class="hljs-keyword">in</span> different compilation units <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> same object, <span class="hljs-keyword">or</span> <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> non-tentative definition. This behavior is inconsistent <span class="hljs-keyword">with</span> C++, <span class="hljs-keyword">and</span> <span class="hljs-keyword">on</span> <span class="hljs-title">many</span> <span class="hljs-title">targets</span> <span class="hljs-title">implies</span> <span class="hljs-title">a</span> <span class="hljs-title">speed</span> <span class="hljs-title">and</span> <span class="hljs-title">code</span> <span class="hljs-title">size</span> <span class="hljs-title">penalty</span> <span class="hljs-title">on</span> <span class="hljs-title">global</span> <span class="hljs-title">variable</span> <span class="hljs-title">references</span>. <span class="hljs-title">It</span> <span class="hljs-title">is</span> <span class="hljs-title">mainly</span> <span class="hljs-title">useful</span> <span class="hljs-title">to</span> <span class="hljs-title">enable</span> <span class="hljs-title">legacy</span> <span class="hljs-title">code</span> <span class="hljs-title">to</span> <span class="hljs-title">link</span> <span class="hljs-title">without</span> <span class="hljs-title">errors</span>.<br></code></pre></td></tr></table></figure><p>文章已经讲解很清楚，这里作为我的理解</p><p><code>-fno-common</code></p><ul><li><strong>作用</strong>：当使用<code>-fno-common</code>选项时，编译器将未初始化的全局变量放置在BSS段中。</li><li><strong>链接器行为</strong>：未初始化的全局变量会被视为强符号。在链接阶段，如果相同的未初始化全局变量在多个编译单元中被定义，链接器会将其视为重复定义，并报告错误。也就是说，链接器不会合并这些变量的定义，任何多个定义的冲突都会导致链接错误。</li></ul><p><code>-fcommon</code></p><ul><li><strong>作用</strong>：当使用<code>-fcommon </code>选项时，编译器会将未初始化的全局变量放入一个<code>COMMON</code>块中。</li><li><strong>链接器行为</strong>：<code>COMMON</code>块是一种特殊的内存区域，允许链接器在链接阶段合并同名的未初始化全局变量的定义。即使这些变量在多个编译单元中被定义，链接器会将它们合并为一个单一的变量对象。</li></ul><p>也就是使用了fcommon，未初始化的全局变量放在<code>COMMON</code>块，允许重复定义，链接期会合并为1个。</p><p>GCC 默认的链接器行为是，如果在链接过程中发现重复的符号，它会选择第一个找到的符号，并忽略后续的符号。这意味着，链接器会使用第一个定义的符号（包括它的数据类型），而忽略后续定义的符号。但是2个变量使用的内存初始地址是一样的，也就是一个int  a和double  a其实共用一块内存，int占4个字节，double占8个字节，这样其实可能导致问题。int  a中可能还有一个int  b，这个b占用了a后面的4个字节，2个变量（b 和  double a）使用了一块内存，肯定会有问题。</p><p>而使用了fno-common属性后，未初始化的全局变量现在会放到BSS段，属于强符号，不允许重复定义</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>C语言程序的内存通常被分为几个主要区域：</p><ul><li><strong>Text段</strong>（代码段）：<ul><li><strong>作用</strong>：存放程序的可执行代码，包括所有函数和指令。</li><li><strong>属性</strong>：通常是只读的，以防止程序代码在运行时被修改，并且可以在多个进程间共享。</li></ul></li><li><strong>Data段</strong>（数据段）：<ul><li><strong>作用</strong>：存放已初始化的全局变量和静态变量。<ul><li><strong><code>.data</code>段</strong>：包含初始化的全局和静态变量。</li><li><strong><code>.rodata</code>段</strong>：包含只读的初始化数据（如字符串常量）。</li></ul></li></ul></li><li><strong>BSS段</strong>：<ul><li><strong>作用</strong>：存放未初始化的全局变量和静态变量。程序加载时，这部分内存会被自动初始化为0。</li><li><strong>特点</strong>：在可执行文件中不占用实际空间，只有在程序运行时才分配内存。</li></ul></li><li><strong>堆</strong>（Heap）：<ul><li><strong>作用</strong>：动态分配内存区域，通过函数如<code>malloc()</code>和<code>free()</code>进行管理。用于存放动态分配的数据结构。</li><li><strong>管理</strong>：需要程序员手动管理内存分配和释放，避免内存泄漏和悬挂指针。</li></ul></li><li><strong>栈</strong>（Stack）：<ul><li><strong>作用</strong>：存放局部变量、函数参数和返回地址。每个函数调用时会在栈上分配一个栈帧。</li><li><strong>特点</strong>：栈内存的分配和释放由系统自动管理。栈大小通常有限，如果超出栈空间会导致栈溢出。</li></ul></li></ul><h2 id="强符号-弱符号"><a href="#强符号-弱符号" class="headerlink" title="强符号&#x2F;弱符号"></a>强符号&#x2F;弱符号</h2><p>对于全局变量来说，如果初始化了不为0的值，那么该全局变量则被保存在data段，如果初始化的值为0，那么将其保存在bss段，如果没有初始化，则将其保存在common段，等到链接时再将其放入到bss段。关于第三点不同编译器行为会不同，有的编译器会把没有初始化的全局变量直接放到bss段，也就是gcc的-fcommon与-fno-common属性的差异。</p><p>绝大多数情况下，函数和已初始化的变量是强符号，而未初始化的变量是弱符号。对于它们，下列三条规则适用：</p><ol><li>同名的强符号只能存在一个。</li><li>一个强符号可以和多个同名的弱符号共存，但调用时会选择强符号的值。</li><li>有多个弱符号时，链接器可以选择其中任意一个。</li></ol><h2 id="librdkafka的编译问题？"><a href="#librdkafka的编译问题？" class="headerlink" title="librdkafka的编译问题？"></a>librdkafka的编译问题？</h2><p>目前librdkafka的最新版本是2.5，最近需要升级这个库，于是我在十几个操作系统编译了一下这个库，有3个编译报错，其中一个是因为依赖的libssl没找到，于是我在lib64指定了一下libssl.so也就编译通过了，而官方最近刚修复了这个问题，也就是没找ssl依赖的情况下，也能编译成功，有点巧。</p><p>还有2个报了<strong>redefinition of typedef</strong>的错误，一个是suse  sp4，一个是centos 6，github搜了一下，发现这是老问题，这个项目以前经常会遇到这个错误，看着是修复过了，现在还会有错误？这2个操作系统的gcc都是4.4，版本比较低，而其他编译过的操作系统，gcc有4.8、7.3、8.3、10.3、12.3，也就是说旧的gcc反而会报错。找了一个变量看下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rd_kafka_toppar_s</span> <span class="hljs-title">rd_kafka_toppar_t</span>;</span><br></code></pre></td></tr></table></figure><p>在<strong>rdkafka_int.h</strong>和<strong>rdkafka_op.h</strong>都定义了这个变量，然后 <strong>rdkafka_op.c</strong>都包含了这个头文件，很明显是重复定义了。但是这个符合c语言规则的</p><p>ISO&#x2F;IEC 9899:1999  6.7.3中是这么描述的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-type">If</span> an identifier has no linkage, there shall be no more than one declaration of the identifier<br>(in a declarator or <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">specifier</span>) <span class="hljs-keyword">with</span> <span class="hljs-title">the</span> <span class="hljs-title">same</span> <span class="hljs-title">scope</span> <span class="hljs-title">and</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">same</span> <span class="hljs-title">name</span> <span class="hljs-title">space</span>, <span class="hljs-title">except</span></span><br><span class="hljs-keyword">for</span> tags as specified in <span class="hljs-number">6.7</span><span class="hljs-number">.2</span><span class="hljs-number">.3</span>.<br></code></pre></td></tr></table></figure><p>而c99中</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">If <span class="hljs-keyword">the</span> same qualifier appears more than once <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> same specifier-qualifier-list, either<br>directly <span class="hljs-keyword">or</span> via <span class="hljs-literal">one</span> <span class="hljs-keyword">or</span> more typedefs, <span class="hljs-keyword">the</span> behavior is <span class="hljs-keyword">the</span> same <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> appeared only<br>once.<br></code></pre></td></tr></table></figure><p>其实就是以前的c标准不允许重复重复声明，c99开始允许了，因此代码这么写没有问题，只是老版本的gcc遵循老的c标准，编译会报错。但是librdkafka明确表示以后不支持centos 6和7，所以也没什么好说的。8的gcc版本一般为8.3，可以正常编译，后续其实要推动客户升级操作系统，毕竟后续会出现越来越多的兼容性问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>gcc</tag>
      
      <tag>fcommon</tag>
      
      <tag>fno-common</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chunked编码格式引发的问题</title>
    <link href="/2024/08/13/chunked%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/13/chunked%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h2><p>在适配某家的cas时，票据校验时一直失败，通常是以下几个问题引发的问题<br>1、网关与cas服务器的网络不通，导致票校验的请求发送不出去<br>2、cas服务器的票据校验接口，配置了域名，但是在nginx没有配置dns，导致域名无法解析，请求无法发送</p><p>3、配置了ip，但是cas服务端限制了host，禁用了ip访问</p><p>4、票据校验的请求有问题，service参数组装不正确</p><p>经过排查后，发现都不是上面的原因，因此抓了一个包，发现cas服务端是正常把响应返回回来的</p><h2 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h2><h3 id="2-1、定位"><a href="#2-1、定位" class="headerlink" title="2.1、定位"></a>2.1、定位</h3><p>既然cas服务端正常返回了响应，那就是网关侧有异常，代码打印状态码和body，发现状态码确实200，但是body是nil，也就是没有获取到body。我们采用了agentzh” Yichun“ 写的lua-resty-http模块(<a href="https://github.com/liseen/lua-resty-http">https://github.com/liseen/lua-resty-http</a>)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span>  xxx   =  hc:request&#123;<br>    url = cas_validate_uri,<br>    method = <span class="hljs-string">&quot;GET&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">--结果调用的是</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span><span class="hljs-params">(self, reqt)</span></span><br></code></pre></td></tr></table></figure><p>其中接收响应body的代码是</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- receive body</span><br>    <span class="hljs-keyword">if</span> shouldreceivebody(nreqt, code) <span class="hljs-keyword">then</span><br>        body, err = receivebody(sock, headers, nreqt)   <span class="hljs-comment">--接收body</span><br>        <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span><br>            sock:<span class="hljs-built_in">close</span>()<br>            <span class="hljs-keyword">if</span> code == <span class="hljs-number">200</span> <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>, code, headers, <span class="hljs-built_in">status</span>, <span class="hljs-literal">nil</span><br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;read body failed &quot;</span> .. err<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>所以我们重点分析receivebody</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receivebody</span><span class="hljs-params">(sock, headers, nreqt)</span></span><br>    <span class="hljs-comment">-- 定义一个名为 receivebody 的本地函数，接收三个参数：</span><br>    <span class="hljs-comment">-- sock：表示连接的套接字对象，用于读取数据。</span><br>    <span class="hljs-comment">-- headers：表示请求的头部信息。</span><br>    <span class="hljs-comment">-- nreqt：包含配置参数的表格，例如最大允许的主体大小和回调函数。</span><br><br>    <span class="hljs-keyword">local</span> t = headers[<span class="hljs-string">&quot;transfer-encoding&quot;</span>] <span class="hljs-comment">-- 获取 &quot;transfer-encoding&quot; 头部的值并存储在变量 t 中</span><br>    <span class="hljs-keyword">local</span> body = &#123;&#125; <span class="hljs-comment">-- 用于存储响应体的数据块的表格</span><br>    <span class="hljs-keyword">local</span> callback = nreqt.body_callback <span class="hljs-comment">-- 获取 nreqt 中的 body_callback 函数</span><br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> callback <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 如果没有提供回调函数</span><br><br>        <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bc</span><span class="hljs-params">(data, chunked_header, ...)</span></span><br>            <span class="hljs-comment">-- 定义一个本地回调函数 bc，用于处理接收到的数据块</span><br>            <span class="hljs-keyword">if</span> chunked_header <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>            <span class="hljs-comment">-- 如果存在 chunked_header，则返回，不处理数据块</span><br>            body[#body+<span class="hljs-number">1</span>] = data<br>            <span class="hljs-comment">-- 将数据块添加到 body 表格中</span><br>        <span class="hljs-keyword">end</span><br><br>        callback = bc<br>        <span class="hljs-comment">-- 将本地定义的回调函数赋值给 callback</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">if</span> t <span class="hljs-keyword">and</span> t ~= <span class="hljs-string">&quot;identity&quot;</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 如果 &quot;transfer-encoding&quot; 头部存在且其值不等于 &quot;identity&quot;：</span><br>        <span class="hljs-comment">-- 表示响应体是分块传输编码（chunked）</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> <span class="hljs-keyword">do</span><br>            <span class="hljs-comment">-- 开始一个无限循环，处理每个块</span><br><br>            <span class="hljs-keyword">local</span> chunk_header = sock:receiveuntil(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>            <span class="hljs-comment">-- 调用 sock 对象的 receiveuntil 方法，读取直到 &quot;\r\n&quot; 为止的数据，表示读取块头部信息。</span><br>            <br>            <span class="hljs-keyword">local</span> data, err, partial = chunk_header()<br>            <span class="hljs-comment">-- 调用 chunk_header 函数以获取数据块头部。如果成功，将数据块头部内容存储在 data 中。</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>                <span class="hljs-comment">-- 如果 data 为 nil，表示读取失败，返回错误信息。</span><br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-keyword">then</span><br>                    <span class="hljs-comment">-- 如果读取到的块头部为 &quot;0&quot;，表示传输结束。</span><br><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(body) <span class="hljs-comment">-- 将 body 中的数据块合并成一个字符串并返回</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">local</span> length = <span class="hljs-built_in">tonumber</span>(data, <span class="hljs-number">16</span>)<br>                    <span class="hljs-comment">-- 否则，将块头部内容转换为十六进制表示的长度。</span><br><br>                    <span class="hljs-comment">-- TODO check nreqt.max_body_size !!</span><br>                    <span class="hljs-comment">-- 注释：需要检查块的大小是否超过最大允许的主体大小。</span><br><br>                    <span class="hljs-keyword">local</span> ok, err = read_body_data(sock, length, nreqt.fetch_size, callback)<br>                    <span class="hljs-comment">-- 调用 read_body_data 函数从套接字读取指定长度的数据，并处理它。</span><br>                    <span class="hljs-comment">-- sock：表示连接的套接字对象。</span><br>                    <span class="hljs-comment">-- length：数据块的长度。</span><br>                    <span class="hljs-comment">-- nreqt.fetch_size：每次读取数据的大小。</span><br>                    <span class="hljs-comment">-- callback：读取后的回调函数。</span><br><br>                    <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>                        <span class="hljs-comment">-- 如果读取失败，返回错误信息。</span><br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">elseif</span> headers[<span class="hljs-string">&quot;content-length&quot;</span>] ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">tonumber</span>(headers[<span class="hljs-string">&quot;content-length&quot;</span>]) &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-comment">-- 如果 &quot;transfer-encoding&quot; 不存在或等于 &quot;identity&quot;，且存在 &quot;content-length&quot; 头部且其值为非负数：</span><br>        <span class="hljs-comment">-- 表示响应体的传输长度是固定的。</span><br><br>        <span class="hljs-keyword">local</span> length = <span class="hljs-built_in">tonumber</span>(headers[<span class="hljs-string">&quot;content-length&quot;</span>])<br>        <span class="hljs-comment">-- 将 &quot;content-length&quot; 的值转换为数值。</span><br><br>        <span class="hljs-keyword">if</span> length &gt; nreqt.max_body_size <span class="hljs-keyword">then</span><br>            <span class="hljs-comment">-- 如果内容长度大于最大允许的主体大小：</span><br><br>            ngx.<span class="hljs-built_in">log</span>(ngx.INFO, <span class="hljs-string">&#x27;content-length &gt; nreqt.max_body_size !! Tail it !&#x27;</span>)<br>            <span class="hljs-comment">-- 记录日志提示该情况。</span><br><br>            length = nreqt.max_body_size<br>            <span class="hljs-comment">-- 将长度截取为最大允许的大小。</span><br>        <span class="hljs-keyword">end</span><br><br>        <span class="hljs-keyword">local</span> ok, err = read_body_data(sock, length, nreqt.fetch_size, callback)<br>        <span class="hljs-comment">-- 调用 read_body_data 函数读取指定长度的数据，并处理它。</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>            <span class="hljs-comment">-- 如果读取失败，返回错误信息。</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">-- 如果既没有 &quot;transfer-encoding&quot; 头部，也没有 &quot;content-length&quot; 头部：</span><br>        <span class="hljs-comment">-- 假设响应体会在连接关闭时结束。</span><br><br>        <span class="hljs-keyword">local</span> ok, err = read_body_data(sock, nreqt.max_body_size, nreqt.fetch_size, callback)<br>        <span class="hljs-comment">-- 调用 read_body_data 函数读取直到最大允许大小的数据，并处理它。</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>            <span class="hljs-comment">-- 如果读取失败，返回错误信息。</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(body)<br>    <span class="hljs-comment">-- 将 body 中的数据块合并成一个字符串并返回</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>抓包查看，响应的编码格式是 <strong>Transfer-Encoding：chunked</strong>，因此确认是走到了上述代码解析chunked的逻辑，在关键代码打印日志后，发现这里返回了错误，读取body失败</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err<br></code></pre></td></tr></table></figure><p>那么为什么读取会失败？</p><h3 id="2-2、什么是chunked类型的数据？"><a href="#2-2、什么是chunked类型的数据？" class="headerlink" title="2.2、什么是chunked类型的数据？"></a>2.2、什么是chunked类型的数据？</h3><p>HTTP 中的 <code>Chunked</code> 传输编码是一种在不预先知道响应数据大小的情况下进行数据传输的方式。通常在 HTTP 响应中，服务器会在头部发送 <code>Content-Length</code> 字段，指定即将发送的数据的总长度。然而，有时候服务器在生成响应内容时并不知道最终的内容长度，比如当内容是动态生成的。这时候，服务器可以使用 <code>Chunked</code> 传输编码。</p><p>Chunked 传输编码的基本工作原理</p><p>在 <code>Chunked</code> 传输编码中，响应体被分割成一系列块（chunks），每个块可以有不同的大小。每个块由两部分组成：</p><ol><li>块头部（Chunk Header）： 该部分指定了块的大小（以16进制表示），后面紧跟着一个回车换行符（\r\n）。</li><li>数据块（Chunk Data）： 紧跟在块头部之后的实际数据，数据块的长度由块头部指定。块数据后面也跟着一个回车换行符（\r\n）。</li></ol><p>响应的最后一个块是一个特殊的块，它的大小为 0，表示数据传输的结束。</p><p><strong>客户端解析 Chunked 数据</strong></p><p>客户端接收到 <code>Chunked</code> 编码的响应时，会逐块解析数据，直到遇到大小为 <code>0</code> 的块。具体的解析步骤如下：</p><ol><li>读取块头部，确定当前块的大小。</li><li>读取指定大小的数据块。</li><li>继续读取下一个块，重复步骤 1 和 2。</li><li>当遇到大小为 <code>0</code> 的块时，停止读取。</li></ol><p><strong>常规的内容传输</strong></p><p>在通常情况下，当服务器要发送响应时，会先计算好整个响应体的大小，并在 HTTP 响应头的 <code>Content-Length</code> 字段中告知客户端。例如，服务器在发送一个 HTML 页面时，可能会先生成整个页面内容，并且计算出它的大小，然后在响应头中设置 <code>Content-Length</code>，再将整个内容一次性发送给客户端。</p><p>这种方式的缺点是：</p><ol><li>延迟高：服务器必须等待整个内容生成完毕，才能开始发送。这增加了初始延迟。</li><li>不适合动态生成的内容：如果内容是逐步生成的（例如，来自数据库的查询结果或通过流处理的内容），服务器需要等到所有内容都生成后才能计算总大小并发送。</li></ol><p><strong><code>Chunked</code> 传输编码的优势</strong></p><p>使用 <code>Chunked</code> 传输编码，服务器不需要预先知道响应内容的总大小。相反，它可以在生成内容的同时逐步将内容以一块块的形式发送给客户端。</p><h3 id="2-3、分析"><a href="#2-3、分析" class="headerlink" title="2.3、分析"></a>2.3、分析</h3><p>了解了原理，那我们来看下服务端返回的数据是否正常，使用tcp追踪流展示数据</p><p><img src="/img/chunked-01.png" alt="chunked-01"></p><p>十六进制：</p><p><img src="/img/chunked-02.png" alt="chunked-02"></p><p>数据很明显有问题，让我们回到代码，只有读到一个0，才会认为数据结束了，也就是已经接收到了完整的数据，但是现在不是一个0，是0000，从十六进制看也很明显，我们需要读取到  <strong>30  od  oa</strong>才会认为数据结束，但是现在是<strong>30  30 30 30 od  oa</strong>。因此客户端会一直读数据，而从请求的响应头connection:close 可以知道，这个连接在传输完数据后会关闭。因此当连接关闭时， local data, err, partial &#x3D; chunk_header()最后会报错，err其实是一个close。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> chunk_header = sock:receiveuntil(<span class="hljs-string">&quot;\r\n&quot;</span>)<br>            <span class="hljs-keyword">local</span> data, err, partial = chunk_header()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">then</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">if</span> data == <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-keyword">then</span>     <span class="hljs-comment">--只有读到一个0才会认为数据结束了</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(body) <span class="hljs-comment">-- end of chunk</span><br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">local</span> length = <span class="hljs-built_in">tonumber</span>(data, <span class="hljs-number">16</span>)<br><br>                    <span class="hljs-comment">-- TODO check nreqt.max_body_size !!</span><br><br>                    <span class="hljs-keyword">local</span> ok, err = read_body_data(sock,length, nreqt.fetch_size, callback)<br>                    <span class="hljs-keyword">if</span> err <span class="hljs-keyword">then</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>,err<br>                    <span class="hljs-keyword">end</span><br>                <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>所以到这里，问题其实可以确认是cas返回的数据有问题</p><h2 id="3、问题解决"><a href="#3、问题解决" class="headerlink" title="3、问题解决"></a>3、问题解决</h2><h3 id="3-1、本地验证"><a href="#3-1、本地验证" class="headerlink" title="3.1、本地验证"></a>3.1、本地验证</h3><p>联系了cas的服务商，被告知这个cas是拿开源来用的，掌握程度一般，沟通下来比较困难🙄，刚好我对这个问题比较感兴趣，因此拿对应开源版本做一个验证<br>cas地址：<a href="https://github.com/apereo/cas/tree/5.3.x?tab=readme-ov-file">https://github.com/apereo/cas/tree/5.3.x?tab=readme-ov-file</a><br>安装参考文档：<a href="https://www.cnblogs.com/hellxz/p/15740935.html">https://www.cnblogs.com/hellxz/p/15740935.html</a><br>tomact：<a href="https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.93/bin/">https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.93/bin/</a><br>cas的war包：<a href="https://repo1.maven.org/maven2/org/apereo/cas/cas-server-webapp-tomcat/">https://repo1.maven.org/maven2/org/apereo/cas/cas-server-webapp-tomcat/</a></p><p>简单运行后，成功对接我们的网关，那么抓包看一下返回的数据</p><p><img src="/img/chunked-03.png" alt="chunked-03"></p><p>数据格式非常正确！</p><h3 id="3-2、最终的结论"><a href="#3-2、最终的结论" class="headerlink" title="3.2、最终的结论"></a>3.2、最终的结论</h3><p>那么现在有问题的场景，还是cas做了一定的改动？cas是用java实现的，这块对我有一定的研究成本，研究了下源码，最后追踪到了视图，但是没找到具体哪里可以设置传输编码，后面有时间再研究一下，还是先把问题还给服务商。</p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>Transfer-Encoding</tag>
      
      <tag>chunked</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSO实践</title>
    <link href="/2024/08/04/SSO/"/>
    <url>/2024/08/04/SSO/</url>
    
    <content type="html"><![CDATA[<p>在早期的互联网发展时期，用户使用的系统很少，每个系统都有自己的登录系统，用户使用每个系统需要分别进行登录。随着互联网的发展，同一产品下耦合的系统越来越多，这时还需要用户在每个系统都进行登录，这对用户的体验感很不好，这时就需要一种方案可以解决多个相互信任系统需要多次登录的问题，此时单点登录应用而生。</p><p>单点登录全称Single Sign On，简称SSO。它的作用是：在多个应用系统中，只需要登录一次，就可以访问其他相互信任的系统。目前有很多种实现方式，本文将介绍3种常见的方式</p><h2 id="1、cas单点登录"><a href="#1、cas单点登录" class="headerlink" title="1、cas单点登录"></a>1、cas单点登录</h2><h3 id="1-1、什么是CAS"><a href="#1-1、什么是CAS" class="headerlink" title="1.1、什么是CAS"></a>1.1、什么是CAS</h3><p>CAS全称 Central Authentication Service，中央认证服务，一种独立开放指令协议，旨在为web应用系统提供一种可靠的单点登录方法。CAS结构体系分为CAS Server与CAS Client，CAS Server负责用户的认证工作，对用户的用户密码进行校验，生成票据。CAS Client负责处理客户端的访问请求，当需要对请求方进行身份认证时，重定向到CAS Server进行认证。其中有3个核心票据需要我们理解，TGT、TGC、ST。</p><ul><li>TGT（Ticket Grangting Ticket）</li></ul><p>TGT为CAS Server为用户签发的登录票据，当用户在CAS Server登录成功后，CAS Server会为该用户生成唯一TGT对象，表示该用户登录成功，TGT封装了Cookie值以及Cookie值对应的用户信息。CAS Server会将生成的TGT对象放在Session中，同时将生成的Cookie，即TGC，返回给浏览器，TGT对象的ID就是cookie的值。TGC-TGT 相当于key-value，可以根据TGC查询TGT。</p><ul><li>TGC（Ticket Granting Cookie）</li></ul><p>TGC，是存放TGT的Session的唯一标识（SessionId），用以查询TGT</p><ul><li>ST（ServiceTicket）</li></ul><p>ST是CAS Server为用户签发的访问某一服务票据。当用户访问某一Service时，Service发现用户没有ST，就会使用户跳转至CAS Server获取ST，此时，如果用户的请求中含有Cookie，则CAS Server会以这个Cookie值（TGC）为key查询session有无TGT，如果有的话，说明用户已登录，则用此TGT签发一个ST返回给用户。用户携带此票据访问Service，Service拿此ST去CAS Server进行验证，如果验证通过，则允许用户访问资源。<strong>需要注意的是，同一单点登录系统下，多个系统不共用一个ST，CAS Server会为每个系统生成对应ST，但是TGT与TGC都只有一个。</strong></p><h3 id="1-2、认证过程"><a href="#1-2、认证过程" class="headerlink" title="1.2、认证过程"></a>1.2、认证过程</h3><ul><li>登录过程</li></ul><ol><li>用户访问系统一，系统检测用户未登录，携带自己的参数跳转到CAS Server进行认证</li><li>CAS Server发现用户并未登录，返回登录界面</li><li>用户输入用户、密码进行登录</li><li>CAS Server校验用户信息，通过后生成TGT、TGC、ST，将TGT缓存在Session，返回给用户TGC、ST，并重定向到系统一</li><li>用户携带ST访问系统一，系统一请求CAS Server的检验接口对ST进行校验，通过后登录成功，此票据失效</li><li>用户在同域页面携带TGC访问系统二，</li><li>系统检测用户未登录，携带自己的参数跳转到CAS Server进行认证</li><li>CAS Server通过以TGC查询到TGT存在，则用此TGT签发一个ST返回给用户，并重定向到系统二</li><li>用户携带ST访问系统二，系统一请求CAS Server的检验接口对ST进行校验，通过后登录成功，此票据失效</li></ol><ul><li>登出过程</li></ul><ol><li>用户向系统一发出登出请求，系统一携带TGC向CAS Server发起登出请求</li><li>CAS Server根据TGC查询到TGT，销毁TGT信息。同时向所有系统发出登出请求，每个系统的登出接口就是登录接口，只是请求方法不一样，登录是get，登出是post，因此系统需要判断这个接口的请求方法，get就是登录，而post是登出。每一个有效的ticket对应其它系统的一个会话，因此一个ticket会调用一次登出</li><li>各系统接收到登出请求，注销局部会话信息</li><li>CAS Serve重定向到系统一的登录界面，用户需要重新进行登录</li></ol><h3 id="1-3、最佳实践"><a href="#1-3、最佳实践" class="headerlink" title="1.3、最佳实践"></a>1.3、最佳实践</h3><p>网关其实相当于一个cas client，我们以openresty举例子，登录主要过程如下：</p><p>1、客户端发起一个普通请求到openresty，openresty检测到会话无效（过期或者未登录），重定向到cas进行登录。</p><p>2、重定向时，需要组装location，在cas的登录uri后，需要添加service的参数，这个参数的值是openresty本身的地址+登录的uri，这个值非常重要，会有3个作用。</p><p>3、浏览器接收到302的响应会自动跳转，前端其实是不能介入的，这时会引发跨域的问题，需要cas服务端做适配，返回Access-Control-Allow-Origin，但是这也会引发一些问题，HTTP协议具有限制，80以上的浏览器禁止跨域携带cookie。解决的办法很多，架构设计为不跨域的形式或者前端做改造，这里我们采取了前端做改造。</p><p>4、输入用户名和密码cas登录登录成功以后，cas会set-cookie，其中包含TGC，并且会302跳转到service的地址，并在参数携带ticket</p><p>5、这时openresty接收到这个请求，将会去cas校验ticket的真实性，这时也需要组装service，cas校验ticket时也会校验service是否与登录时一致，如果验证通过，则认为该用户已经登录成功。验证时，cas会返回ticket对应的用户，这里其实就有一个高阶用法，不同系统不同用户的映射，可以在这里做设计。</p><p>6、当票据验证成功以后，网关就可以生成会话，同时将会话票据返回到客户端，此时登录成功。</p><p>登出也类似，区别在于cas登出以后，会将登录过的系统都登出，调用的接口就是登录时传递的service，不过此时是post请求。</p><h3 id="1-4、具体分析"><a href="#1-4、具体分析" class="headerlink" title="1.4、具体分析"></a>1.4、具体分析</h3><p>本节具体分析一下1.3中的步骤</p><p>1、首先一个请求触发cas，location会是cas服务端的地址</p><p><img src="/img/cas-01.png" alt="cas-01"></p><p>2、重定向到cas，参数携带service（我们采用另外一种方式避免跨域，所以这里并不是location，只要知道这是前端做了改造即可）</p><p><img src="/img/cas-02.png" alt="cas-02"></p><p>3、此时跳转到cas的登录界面，输入用户和密码以后，进行登录，成功后cas在cookie返回了TGC，并且location跳转了service的地址，里面包含票据</p><p><img src="/img/cas-03.png" alt="cas-03"></p><p>4、接着前端跳转了这个地址（需要注意的是这个请求一定是GET，登出时，cas会调用这个接口，为POST）</p><p><img src="/img/cas-04.png" alt="cas-04"></p><p>此时网关会校验票据，如果登录成功会生成该系统的会话。</p><h3 id="1-5、实际遇到的问题"><a href="#1-5、实际遇到的问题" class="headerlink" title="1.5、实际遇到的问题"></a>1.5、实际遇到的问题</h3><p>要实现一个cas单点登录功能，还是稍微复杂的，大体流程很容易懂，但是具体细节有很多，比如如何解决跨域、service的作用、网关和cas的网络问题、有了域名怎么办、网关前面有代理节点怎么办，如果跳转取host，但是前面的节点不传递host，如何登出等等，这些问题都需要在实践中遇到并解决。</p><h2 id="2、saml"><a href="#2、saml" class="headerlink" title="2、saml"></a>2、saml</h2><p>待补充</p><h2 id="3、oauth-2-0"><a href="#3、oauth-2-0" class="headerlink" title="3、oauth 2.0"></a>3、oauth 2.0</h2><p>待补充</p>]]></content>
    
    
    
    <tags>
      
      <tag>SSO</tag>
      
      <tag>cas</tag>
      
      <tag>单点登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次ngx_slab内存泄露问题</title>
    <link href="/2024/07/30/%E4%B8%80%E6%AC%A1ngx_slab%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2024/07/30/%E4%B8%80%E6%AC%A1ngx_slab%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1、问题"><a href="#1、问题" class="headerlink" title="1、问题"></a>1、问题</h2><p>根据现场描述，隔几天就会出现nginx无法访问的情况，场景为正常使用状态，出现异常时，日志报大量  ngx_slab_free() : chunk is already free的错误，出现core dump，进程会不端重新拉起，不断core。此情况下，需要重启nginx才能恢复正常。</p><p>现场使用了访问控制功能，其中配置了几百条对客户端ip的访问控制规则。</p><h2 id="2、现象分析"><a href="#2、现象分析" class="headerlink" title="2、现象分析"></a>2、现象分析</h2><p>1、调试core，首先发现core的原因是释放slab内存块时，重复释放了一块内存，ngx_slab_free_locked(shpool,f-&gt;k);关键问题是在释放f-&gt;k时，没有保护f-&gt;k为NULL的场景。但是问题是，为什么会重复释放？其他那个地方已经释放了这块内存，为什么还会走到这块逻辑，或者说这块内存一直为NULL？</p><p>2、调用释放共享内存的函数的地方只有2处</p><ul><li>启动阶段 </li><li>更新访问控制模块的动态配置时</li></ul><p>因此需要着重排查这2块的问题</p><h2 id="3、复现过程"><a href="#3、复现过程" class="headerlink" title="3、复现过程"></a>3、复现过程</h2><p>考虑到现场配置了几百条访问控制规则，于是测试环境配置了1000多条，在重复更新动态配置后，可以复现该问题，nginx出现core，进程会不断被拉起，又崩溃，循环这个过程。在这种异常发生时，nginx不能正常工作，与现场的现象一致。</p><p>可以确认是内存导致的异常，只有重启才能恢复。复现的关键要素是：</p><p>1、访问控制的规则数据量大</p><p>2、重复调用动态配置更新</p><h2 id="4、代码排查"><a href="#4、代码排查" class="headerlink" title="4、代码排查"></a>4、代码排查</h2><h3 id="4-1、初步结论"><a href="#4-1、初步结论" class="headerlink" title="4.1、初步结论"></a>4.1、初步结论</h3><p>nginx是多进程，实现访问控制、限流功能时，进程需要共享数据，比如一个uri的多笔请求，可能由多个进程处理，此时进程需要判断这个uri是否达到了限制次数，因此访问控制模块和限流模块使用共享内存进行进程间的通信，slab共享内存。</p><p>同时，异常时，日志中会出现ngx_slab_alloc() failed:no memory，因此怀疑是共享内存溢出了。目前访问控制模块的slab共享内存大小只有1M，当数据量过大时，1M的内存池会很快用完，后续访问控制模块在处理ip的规则时，会为每一个ip规则申请内存，内存池满时内存申请会失败，但是并不会直接阻断代码逻辑。</p><p>而每次更新配置时，会先清除访问控制模块的内存，因为上次申请内存时没有得到有效的地址，因此在释放时，释放了未知地址，导致core。当work  core时，master会尝试拉起一个新的work，初始化访问控制模块时，会初始化共享内存，又会尝试释放上一次的内存，又会导致core，不断循环。</p><p>本质是共享内存用完了，导致模块申请内存时失败，后续又释放了该随机地址，导致core dump。</p><h3 id="4-2、内存泄露"><a href="#4-2、内存泄露" class="headerlink" title="4.2、内存泄露"></a>4.2、内存泄露</h3><p>疑问是，1M的内存，为什么多调用几次就不够用了？所以我怀疑有内存泄漏，如果真的是内存泄露，那么增大多少内存都没有用，因为不重启的情况下，总有一天内存又会满。</p><p>因此需要继续排查，Tengine有一个非常好用的模块，ngx_slab_stat，这个模块的作用与火焰图的ngx-shm类似，可以展示nginx使用的每块共享内存的具体情况（模块地址：<a href="https://www.bookstack.cn/read/nginx-official-doc/29.md%EF%BC%89">https://www.bookstack.cn/read/nginx-official-doc/29.md）</a> 。简单编译使用后，我发现确实有内存泄露，具体测试数据如下：</p><table><thead><tr><th align="center">调用次数&#x2F;次</th><th align="center">调用接口</th><th align="center">访问控制规则条数&#x2F;条</th><th align="center">共享内存内存剩余&#x2F;KB</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">xxx</td><td align="center">823</td><td align="center">896</td></tr><tr><td align="center">2</td><td align="center">xxx</td><td align="center">823</td><td align="center">884</td></tr><tr><td align="center">3</td><td align="center">xxx</td><td align="center">823</td><td align="center">872</td></tr><tr><td align="center">4</td><td align="center">xxx</td><td align="center">823</td><td align="center">860</td></tr><tr><td align="center">5</td><td align="center">xxx</td><td align="center">823</td><td align="center">844</td></tr></tbody></table><p>1、第一次调用</p><p><img src="/img/slab-%E5%9B%BE1.png" alt="slab-图1"></p><p>2、第二次</p><p><img src="/img/slab-%E5%9B%BE2.png" alt="slab-图2"></p><p>3、第三次</p><p><img src="/img/slab-%E5%9B%BE3.png" alt="slab-图3"></p><p>4、第四次</p><p><img src="/img/slab-%E5%9B%BE4.png" alt="slab-图4"></p><p>5、第五次</p><p><img src="/img/slab-%E5%9B%BE5.png" alt="slab-图5"></p><p>823条的访问控制数据，每次会泄露12KB左右的内存，所以内存使用确实是有问题的。</p><h3 id="4-3、代码定位"><a href="#4-3、代码定位" class="headerlink" title="4.3、代码定位"></a>4.3、代码定位</h3><p>slab内存申请主要是2个函数ngx_slab_calloc与ngx_slab_calloc_locked，前者也是调用后者，只不过上了锁。</p><p>访问控制模块申请内存的地方只有3处，但是不确定是哪一处，所以这里取巧一下，这3处申请内存时，分别乘以3、6、9，然后再看泄露的内存是12KB的几倍，实际测试为6倍，因此很快就定位了代码</p><p>最后发现是ip-&gt;data申请的内存没有释放，ip是一个ngx_str_t结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">size_t</span>  len;<br>u_char  *data;<br>&#125; <span class="hljs-type">ngx_str_t</span>;<br></code></pre></td></tr></table></figure><p>ip本身和data都申请了内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_str_t</span>  *ip;<br>ip = ngx_slab_calloc_locked(xxxxx,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_str_t</span>));<br>ip-&gt;data = ngx_slab_calloc_locked(xxxxx,xxxxxx);<br></code></pre></td></tr></table></figure><p>但是释放时，只释放了ip本身，并没有释放ip-&gt;data，因此每次都会有内存泄露。</p><p>因此修复代码缺陷，正确释放ip-&gt;data，再进行测试，发现没有了内存泄露问题，可用内存一直处于固定值。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>这个问题很有意思，借着这次的问题对slab有了一些了解，看了陶辉的《深入理解Nginx模块开发与架构解析》第16章感觉受益匪浅，然后简单看了下linux关于slab的原理，整体有一定的理解，具体总结在另外一篇文章，会持续更新。</p><p>这次还使用了火焰图辅助排查，章亦春的2个脚本，不过只有ngx-shm执行成功了，不过效果不如Tengine的ngx_slab_stat，这个确实很好很好的模块，后续我会编译到我们的产品中去，而且我发现Tengine还有一些有意思的模块，后续可以研究一下。</p><p>其实看了陶辉的《深入理解Nginx模块开发与架构解析》第16章，ngx_slab_stat的实现原理就很容易理解，后续有时间可以写一篇分析文章。</p><p>最后找到问题，其实发现是c语言指针、内存的问题，c语言确实容易出现这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>slab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ngx_slab共享内存</title>
    <link href="/2024/07/09/ngx_slab/"/>
    <url>/2024/07/09/ngx_slab/</url>
    
    <content type="html"><![CDATA[<p>nginx是多进程，实现访问控制、限流功能时，进程需要共享数据，比如一个uri的多笔请求，可能由多个进程处理，此时进程需要判断这个uri是否达到了限制次数，因此访问控制模块和限流模块使用共享内存进行进程间的通信，nginx实现了ngx_shm_t共享内存，但是如果要共享一些复杂的数据结构，ngx_shm_t很难满足这种需求，因此在这个基础上实现了slab共享内存。</p><h2 id="1、初始化共享内存"><a href="#1、初始化共享内存" class="headerlink" title="1、初始化共享内存"></a>1、初始化共享内存</h2><p>模块在配置初始化时，将会申请一块slab内存池，开发者可以通过ngx_slab_alloc向这个内存池申请内存，当内存池用尽时，这个函数就会返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_shm_zone_t</span> *<br><br><span class="hljs-title function_">ngx_shared_memory_add</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">ngx_str_t</span> *name, <span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* *tag)</span><br></code></pre></td></tr></table></figure><ul><li>ngx_conf_t *cf            &#x2F;&#x2F;全局配置文件</li><li>ngx_str_t *name        &#x2F;&#x2F;这块slab共享内存的名字</li><li>size_t size                   &#x2F;&#x2F;这块共享内存的大小</li><li>void *tag                    &#x2F;&#x2F;防止2个不同模块定义的内存池具有相同的名字，一般传入本模块结构体的地址</li></ul><p>本模块结构体的地址通常为全局变量，因此在reload，nginx重读配置时，因为tag没有变化，所以不会重新申请内存。还有一个好处是，如果之前共享内存是有数据的，这样不会丢掉之前共享内存中的数据，因此使用的思想是，尽可能使用旧的共享内存，当然前提是旧的存在。</p><h2 id="2、操作slab共享内存"><a href="#2、操作slab共享内存" class="headerlink" title="2、操作slab共享内存"></a>2、操作slab共享内存</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化共享内存</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_slab_init</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool)</span><br><br><span class="hljs-comment">//加锁的内存申请方法</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">ngx_slab_alloc</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool, <span class="hljs-type">size_t</span> size)</span><br><br><span class="hljs-comment">//不加锁的内存申请方法</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">ngx_slab_alloc_locked</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool, <span class="hljs-type">size_t</span> size)</span><br><br><span class="hljs-comment">//加锁的内存释放方法</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_slab_free</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool, <span class="hljs-type">void</span> *p)</span><br><br><span class="hljs-comment">//不加锁的内存释放方法</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_slab_free_locked</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool, <span class="hljs-type">void</span> *p)</span><br> <br><br></code></pre></td></tr></table></figure><p>nginx多进程结构，需要使用同步锁才能操作共享数据。那为什么还有ngx_slab_alloc_locked？事实上，nginx的代码可能存在多层锁的嵌套，如果外层已经加锁，那么内存是没有必要上锁的，毕竟上锁会增加开销，降低效率。</p><p>需要注意的是，当slab内存池的内存用完时，ngx_slab_alloc会直接返回NULL，因此需要合理评估模块使用的内存大小，如果slab共享内存设置的太小会导致异常。</p><p>以ssl模块为例，共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">sscf-&gt;shm_zone = ngx_shared_memory_add(cf, &amp;name, n,<br>                                                   &amp;ngx_http_ssl_module);<br></code></pre></td></tr></table></figure><h2 id="3、API详解"><a href="#3、API详解" class="headerlink" title="3、API详解"></a>3、API详解</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_slab_free_locked</span><span class="hljs-params">(<span class="hljs-type">ngx_slab_pool_t</span> *pool, <span class="hljs-type">void</span> *p)</span><br>&#123;<br>    <span class="hljs-comment">// 定义局部变量，用于计算和存储内存页和slab信息。</span><br>    <span class="hljs-type">size_t</span>            size;<br>    <span class="hljs-type">uintptr_t</span>         slab, m, *bitmap;<br>    <span class="hljs-type">ngx_uint_t</span>        i, n, type, slot, shift, <span class="hljs-built_in">map</span>;<br>    <span class="hljs-type">ngx_slab_page_t</span>  *slots, *page;<br><br>    <span class="hljs-comment">// 记录调试信息，显示正在释放的内存地址。</span><br>    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;slab free: %p&quot;</span>, p);<br><br>    <span class="hljs-comment">// 检查释放的内存地址是否在slab pool的范围内。</span><br>    <span class="hljs-keyword">if</span> ((u_char *) p &lt; pool-&gt;start || (u_char *) p &gt; pool-&gt;end) &#123;<br>        <span class="hljs-comment">// 如果不在范围内，记录错误日志并退出函数。</span><br>        ngx_slab_error(pool, NGX_LOG_ALERT, <span class="hljs-string">&quot;ngx_slab_free(): outside of pool&quot;</span>);<br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算内存页的索引。</span><br>    n = ((u_char *) p - pool-&gt;start) &gt;&gt; ngx_pagesize_shift;<br>    <span class="hljs-comment">// 获取内存页的指针。</span><br>    page = &amp;pool-&gt;pages[n];<br>    <span class="hljs-comment">// 获取slab的地址。</span><br>    slab = page-&gt;slab;<br>    <span class="hljs-comment">// 获取内存页的类型。</span><br>    type = ngx_slab_page_type(page);<br><br>    <span class="hljs-comment">// 根据内存页类型进行不同的处理。</span><br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>    <span class="hljs-comment">// 小对象内存页的处理。</span><br>    <span class="hljs-keyword">case</span> NGX_SLAB_SMALL:<br>        <span class="hljs-comment">// 计算slab的大小和位移。</span><br>        shift = slab &amp; NGX_SLAB_SHIFT_MASK;<br>        size = (<span class="hljs-type">size_t</span>) <span class="hljs-number">1</span> &lt;&lt; shift;<br><br>        <span class="hljs-comment">// 检查p是否是size的整数倍。</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">uintptr_t</span>) p &amp; (size - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">goto</span> wrong_chunk;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算在bitmap中的位置。</span><br>        n = ((<span class="hljs-type">uintptr_t</span>) p &amp; (ngx_pagesize - <span class="hljs-number">1</span>)) &gt;&gt; shift;<br>        m = (<span class="hljs-type">uintptr_t</span>) <span class="hljs-number">1</span> &lt;&lt; (n % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>)));<br>        n /= <span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>);<br>        bitmap = (<span class="hljs-type">uintptr_t</span> *)((<span class="hljs-type">uintptr_t</span>) p &amp; ~((<span class="hljs-type">uintptr_t</span>) ngx_pagesize - <span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">// 检查bitmap对应的位是否被设置，即内存块是否已被分配。</span><br>        <span class="hljs-keyword">if</span> (bitmap[n] &amp; m) &#123;<br>            <span class="hljs-comment">// 释放内存块，更新slab的bitmap和内存页的链表。</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// 省略了释放内存块的代码。</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果内存块已经被释放，则报错。</span><br>        <span class="hljs-keyword">goto</span> chunk_already_free;<br><br>    <span class="hljs-comment">// 精确大小内存页的处理。</span><br>    <span class="hljs-keyword">case</span> NGX_SLAB_EXACT:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略了精确大小内存页的处理代码。</span><br><br>    <span class="hljs-comment">// 大对象内存页的处理。</span><br>    <span class="hljs-keyword">case</span> NGX_SLAB_BIG:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略了大对象内存页的处理代码。</span><br><br>    <span class="hljs-comment">// 特殊内存页的处理，用于存储大于slab可以分配的最大块大小的对象。</span><br>    <span class="hljs-keyword">case</span> NGX_SLAB_PAGE:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 省略了特殊内存页的处理代码。</span><br><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 未处理的case，不应该到达这里。</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 函数结束，正常释放内存后会执行到这里。</span><br>    <span class="hljs-keyword">return</span>;<br><br>fail:<br>    <span class="hljs-comment">// 释放失败，记录错误日志。</span><br>    <span class="hljs-keyword">return</span>;<br><br>done:<br>    <span class="hljs-comment">// 正常释放内存后更新使用的统计信息，并填充释放的内存以避免重复使用。</span><br>    pool-&gt;stats[slot].used--;<br>    ngx_slab_junk(p, size);<br>    <span class="hljs-keyword">return</span>;<br><br>wrong_chunk:<br>    <span class="hljs-comment">// 释放的内存块地址不正确，记录错误日志。</span><br>    ngx_slab_error(pool, NGX_LOG_ALERT, <span class="hljs-string">&quot;ngx_slab_free(): pointer to wrong chunk&quot;</span>);<br>    <span class="hljs-keyword">goto</span> fail;<br><br>chunk_already_free:<br>    <span class="hljs-comment">// 尝试释放一个已经被释放的内存块，记录错误日志。</span><br>    ngx_slab_error(pool, NGX_LOG_ALERT, <span class="hljs-string">&quot;ngx_slab_free(): chunk is already free&quot;</span>);<br>    <span class="hljs-keyword">goto</span> fail;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、释放问题"><a href="#4、释放问题" class="headerlink" title="4、释放问题"></a>4、释放问题</h2><p>ngx_slab_free_locked 函数释放通过 slab 分配器分配的内存时，不会改变指针本身的值，而是将指针指向的内存块标记为可用。这个很关键，因此当一个指针是否持有合理内存时，不能判断是否为NULL。</p><p>内存分配器（如 slab 分配器）负责管理内存块的分配和释放。当一个内存块被分配时，内存分配器会记录该内存块的状态（已分配）。当这个内存块被释放时，内存分配器会更新该内存块的状态（可用）。</p><p>在 C 语言中，指针是用来存储内存地址的变量。指针本身只是一个变量，存储了一个内存地址。在调用 ngx_slab_free_locked 函数时，传递的是指针的值（即内存地址），而不是指针本身。因此，函数内部对内存的操作不会改变传入指针的值。</p><p>指针传递： 当调用 ngx_slab_free_locked(shpool, h) 时，传递的是 h 的值（内存地址）。<br>内存释放： 函数 ngx_slab_free_locked 使用 h 指向的内存地址，在内存池中找到对应的内存块，并将其标记为可用。这涉及到更新 slab 分配器内部的数据结构，但不改变 h 本身的值。</p><p><strong>指针保持不变： 函数调用结束后，h 仍然持有原来的内存地址值。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>slab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡算法解析</title>
    <link href="/2024/06/02/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/06/02/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1、nginx-轮询"><a href="#1、nginx-轮询" class="headerlink" title="1、nginx-轮询"></a>1、nginx-轮询</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_http_upstream_rr_peer_t</span> *<br><span class="hljs-title function_">ngx_http_upstream_get_peer</span><span class="hljs-params">(<span class="hljs-type">ngx_http_upstream_rr_peer_data_t</span> *rrp)</span><br>&#123;<br>    <span class="hljs-type">time_t</span>                        now;            <span class="hljs-comment">// 当前时间</span><br>    <span class="hljs-type">uintptr_t</span>                     m;              <span class="hljs-comment">// 位掩码</span><br>    <span class="hljs-type">ngx_int_t</span>                     total;          <span class="hljs-comment">// 总权重</span><br>    <span class="hljs-type">ngx_uint_t</span>                    i, n, p;       <span class="hljs-comment">// 循环计数器和索引</span><br>    <span class="hljs-type">ngx_http_upstream_rr_peer_t</span>  *peer, *best;  <span class="hljs-comment">// 指向当前和最佳服务器的指针</span><br><br>    now = ngx_time();<br><br>    <span class="hljs-comment">// 初始化最佳服务器为 NULL 和总权重为 0</span><br>    best = <span class="hljs-literal">NULL</span>;<br>    total = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 避免编译器警告，如果未使用变量 p</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_SUPPRESS_WARN)</span><br>    p = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 遍历所有后端服务器</span><br>    <span class="hljs-keyword">for</span> (peer = rrp-&gt;peers-&gt;peer, i = <span class="hljs-number">0</span>;<br>         peer;<br>         peer = peer-&gt;next, i++)<br>    &#123;<br>        <span class="hljs-comment">// 计算位数组索引和位掩码</span><br>        n = i / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>)); <span class="hljs-comment">// 索引为当前服务器编号除以每个 uintptr_t 能存储的位数</span><br>        m = (<span class="hljs-type">uintptr_t</span>) <span class="hljs-number">1</span> &lt;&lt; i % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>)); <span class="hljs-comment">// 计算位掩码</span><br><br>        <span class="hljs-comment">// 如果当前服务器已经被尝试过，则跳过</span><br>        <span class="hljs-keyword">if</span> (rrp-&gt;tried[n] &amp; m) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果服务器处于宕机状态，则跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;down) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果服务器的失败次数超过了允许的最大失败次数，并且当前时间距离上次检查时间小于失败超时时间，则跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;max_fails<br>            &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails<br>            &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果服务器达到最大连接数限制，则跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;max_conns &amp;&amp; peer-&gt;conns &gt;= peer-&gt;max_conns) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 增加服务器的当前权重，并将其加入总权重</span><br>        peer-&gt;current_weight += peer-&gt;effective_weight;<br>        total += peer-&gt;effective_weight;<br><br>        <span class="hljs-comment">// 如果服务器的有效权重小于其声明的权重，则增加有效权重</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;effective_weight &lt; peer-&gt;weight) &#123;<br>            peer-&gt;effective_weight++;<br>        &#125;<br><br>        <span class="hljs-comment">// 选择当前权重最高的服务器作为最佳服务器</span><br>        <span class="hljs-keyword">if</span> (best == <span class="hljs-literal">NULL</span> || peer-&gt;current_weight &gt; best-&gt;current_weight) &#123;<br>            best = peer;<br>            p = i; <span class="hljs-comment">// 记录最佳服务器的索引</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有找到合适的服务器，返回 NULL</span><br>    <span class="hljs-keyword">if</span> (best == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置当前选择的服务器</span><br>    rrp-&gt;current = best;<br><br>    <span class="hljs-comment">// 更新位数组以记录已尝试的服务器</span><br>    n = p / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>));<br>    m = (<span class="hljs-type">uintptr_t</span>) <span class="hljs-number">1</span> &lt;&lt; p % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>));<br>    rrp-&gt;tried[n] |= m;<br><br>    <span class="hljs-comment">// 从最佳服务器的当前权重中减去总权重，为下一次选择做准备</span><br>    best-&gt;current_weight -= total;<br><br>    <span class="hljs-comment">// 如果当前时间距离最佳服务器的上次检查时间超过失败超时时间，则更新检查时间</span><br>    <span class="hljs-keyword">if</span> (now - best-&gt;checked &gt; best-&gt;fail_timeout) &#123;<br>        best-&gt;checked = now;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回选择的最佳服务器</span><br>    <span class="hljs-keyword">return</span> best;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、nginx-ip-hash"><a href="#2、nginx-ip-hash" class="headerlink" title="2、nginx-ip_hash"></a>2、nginx-ip_hash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">upstream rrBackend &#123;<br>    ip_hash;<br>    server localhost:<span class="hljs-number">8001</span> weight=<span class="hljs-number">1</span>;<br>    server localhost:<span class="hljs-number">8002</span> weight=<span class="hljs-number">2</span>;<br>    server localhost:<span class="hljs-number">8003</span> weight=<span class="hljs-number">3</span>;<br>&#125;<br><br>location /rr &#123;<br>    proxy_pass http:<span class="hljs-comment">//rrBackend;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_upstream_get_ip_hash_peer(<span class="hljs-type">ngx_peer_connection_t</span> *pc, <span class="hljs-type">void</span> *data)<br>&#123;<br>    <span class="hljs-type">ngx_http_upstream_ip_hash_peer_data_t</span>  *iphp = data;<br><br>    <span class="hljs-type">time_t</span>                        now;<br>    <span class="hljs-type">ngx_int_t</span>                     w;<br>    <span class="hljs-type">uintptr_t</span>                     m;<br>    <span class="hljs-type">ngx_uint_t</span>                    i, n, p, hash;<br>    <span class="hljs-type">ngx_http_upstream_rr_peer_t</span>  *peer;<br><br>    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                   <span class="hljs-string">&quot;get ip hash peer, try: %ui&quot;</span>, pc-&gt;tries);<br><br>    <span class="hljs-comment">// 对轮询节点的peers进行读锁定</span><br>    ngx_http_upstream_rr_peers_rlock(iphp-&gt;rrp.peers);<br><br>    <span class="hljs-comment">// 如果尝试次数超过20次或者只有一个后端节点，则直接返回轮询算法的结果</span><br>    <span class="hljs-keyword">if</span> (iphp-&gt;tries &gt; <span class="hljs-number">20</span> || iphp-&gt;rrp.peers-&gt;single) &#123;<br>        ngx_http_upstream_rr_peers_unlock(iphp-&gt;rrp.peers);<br>        <span class="hljs-keyword">return</span> iphp-&gt;get_rr_peer(pc, &amp;iphp-&gt;rrp);<br>    &#125;<br><br>    now = ngx_time();<br><br>    pc-&gt;cached = <span class="hljs-number">0</span>;<br>    pc-&gt;connection = <span class="hljs-literal">NULL</span>;<br><br>    hash = iphp-&gt;hash;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">// 计算哈希值，这里只取地址的前三位</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">ngx_uint_t</span>) iphp-&gt;addrlen; i++) &#123;<br>            hash = (hash * <span class="hljs-number">113</span> + iphp-&gt;addr[i]) % <span class="hljs-number">6271</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对总权重取余，使得请求更加均匀的分散到server</span><br>        w = hash % iphp-&gt;rrp.peers-&gt;total_weight;<br>        peer = iphp-&gt;rrp.peers-&gt;peer;<br>        p = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 遍历peers，找到权重匹配的peer，权重值越大，越容易得到这个请求</span><br>        <span class="hljs-keyword">while</span> (w &gt;= peer-&gt;weight) &#123;<br>            w -= peer-&gt;weight;<br>            peer = peer-&gt;next;<br>            p++;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查这个peer是否被尝试过</span><br>        n = p / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>));<br>        m = (<span class="hljs-type">uintptr_t</span>) <span class="hljs-number">1</span> &lt;&lt; p % (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uintptr_t</span>));<br><br>        <span class="hljs-comment">// 如果已经尝试过这个peer，则跳过</span><br>        <span class="hljs-keyword">if</span> (iphp-&gt;rrp.tried[n] &amp; m) &#123;<br>            <span class="hljs-keyword">goto</span> next;<br>        &#125;<br><br>        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                       <span class="hljs-string">&quot;get ip hash peer, hash: %ui %04XL&quot;</span>, p, (<span class="hljs-type">uint64_t</span>) m);<br><br>        <span class="hljs-comment">// 对选定的peer进行加锁</span><br>        ngx_http_upstream_rr_peer_lock(iphp-&gt;rrp.peers, peer);<br><br>        <span class="hljs-comment">// 如果peer处于down状态，则解锁并跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;down) &#123;<br>            ngx_http_upstream_rr_peer_unlock(iphp-&gt;rrp.peers, peer);<br>            <span class="hljs-keyword">goto</span> next;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果peer失败次数超过阈值并且检查时间在失败超时时间内，则解锁并跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;max_fails<br>            &amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails<br>            &amp;&amp; now - peer-&gt;checked &lt;= peer-&gt;fail_timeout)<br>        &#123;<br>            ngx_http_upstream_rr_peer_unlock(iphp-&gt;rrp.peers, peer);<br>            <span class="hljs-keyword">goto</span> next;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果peer的连接数超过最大连接数限制，则解锁并跳过</span><br>        <span class="hljs-keyword">if</span> (peer-&gt;max_conns &amp;&amp; peer-&gt;conns &gt;= peer-&gt;max_conns) &#123;<br>            ngx_http_upstream_rr_peer_unlock(iphp-&gt;rrp.peers, peer);<br>            <span class="hljs-keyword">goto</span> next;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果没有上述情况，则选择此peer</span><br>        <span class="hljs-keyword">break</span>;<br><br>    next:<br><br>        <span class="hljs-comment">// 如果尝试次数超过20次，则返回轮询算法的结果</span><br>        <span class="hljs-keyword">if</span> (++iphp-&gt;tries &gt; <span class="hljs-number">20</span>) &#123;<br>            ngx_http_upstream_rr_peers_unlock(iphp-&gt;rrp.peers);<br>            <span class="hljs-keyword">return</span> iphp-&gt;get_rr_peer(pc, &amp;iphp-&gt;rrp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置当前选择的peer</span><br>    iphp-&gt;rrp.current = peer;<br><br>    <span class="hljs-comment">// 设置pc结构体的字段，以反映选定的peer</span><br>    pc-&gt;sockaddr = peer-&gt;sockaddr;<br>    pc-&gt;socklen = peer-&gt;socklen;<br>    pc-&gt;name = &amp;peer-&gt;name;<br><br>    <span class="hljs-comment">// 增加peer的连接数</span><br>    peer-&gt;conns++;<br><br>    <span class="hljs-comment">// 更新peer的检查时间</span><br>    <span class="hljs-keyword">if</span> (now - peer-&gt;checked &gt; peer-&gt;fail_timeout) &#123;<br>        peer-&gt;checked = now;<br>    &#125;<br><br>    <span class="hljs-comment">// 解锁选定的peer</span><br>    ngx_http_upstream_rr_peer_unlock(iphp-&gt;rrp.peers, peer);<br>    ngx_http_upstream_rr_peers_unlock(iphp-&gt;rrp.peers);<br><br>    <span class="hljs-comment">// 在trie中标记已经尝试过这个peer</span><br>    iphp-&gt;rrp.tried[n] |= m;<br>    iphp-&gt;hash = hash;<br><br>    <span class="hljs-comment">// 函数返回成功</span><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、hash"><a href="#3、hash" class="headerlink" title="3、hash"></a>3、hash</h2><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">upstream myapp &#123;<br>        hash $http_x_real_ip;  # 使用 X-<span class="hljs-title class_">Real</span>-<span class="hljs-variable constant_">IP</span> 头部的值进行哈希<br>        server backend1.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> weight=<span class="hljs-number">1</span>;<br>        server backend2.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> weight=<span class="hljs-number">2</span>;<br>    &#125;<br><br><span class="hljs-comment">//或者</span><br><br>upstream myapp &#123;<br>        hash $http_x_forwarded_for;  # 使用 $http_x_forwarded_for 头部的值进行哈希<br>        server backend1.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> weight=<span class="hljs-number">1</span>;<br>        server backend2.<span class="hljs-property">example</span>.<span class="hljs-property">com</span> weight=<span class="hljs-number">2</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当在 Nginx 配置中使用 <code>hash $http_x_forwarded_for;</code> 作为负载均衡的键时，hash用的就是真实客户端ip，<code>ngx_http_complex_value</code> 函数将用于计算 <code>X-Forwarded-For</code> HTTP 请求头的值，并将该值赋给 <code>hp-&gt;key</code>。以下是该过程的详细说明：</p><p><img src="/img/%E5%9B%BE3.1.png" alt="图3.1"></p><ol><li><strong>复杂值初始化</strong>:<ul><li>在 Nginx 配置阶段，当遇到 <code>hash $http_x_forwarded_for;</code> 配置时，相关的配置处理函数（如 <code>ngx_http_upstream_hash</code>）将初始化一个 <code>ngx_http_complex_value_t</code> 结构体，这里即 <code>hcf-&gt;key</code>。</li></ul></li><li><strong>请求处理阶段</strong>:<ul><li>当一个请求到达并需要进行上游处理时，<code>ngx_http_upstream_init_hash_peer</code> 函数被调用。</li></ul></li><li><strong>执行复杂值</strong>:<ul><li><code>ngx_http_complex_value</code> 函数被用来执行 <code>hcf-&gt;key</code> 中定义的复杂值，这个复杂值就是 <code>$http_x_forwarded_for</code>。</li></ul></li><li><strong>计算哈希键</strong>:<ul><li><code>ngx_http_complex_value</code> 函数解析 <code>$http_x_forwarded_for</code>，这通常意味着它将获取请求的 <code>X-Forwarded-For</code> 头的值。</li></ul></li><li><strong>值的变化</strong>:<ul><li>在执行 <code>ngx_http_complex_value(r, &amp;hcf-&gt;key, &amp;hp-&gt;key)</code> 之前，<code>hp-&gt;key</code> 是未初始化的。</li><li>执行后，如果函数返回 <code>NGX_OK</code>，则 <code>hp-&gt;key</code> 将包含 <code>X-Forwarded-For</code> 头的值，这可能是一个单一的 IP 地址或者一个 IP 地址列表，具体取决于 <code>X-Forwarded-For</code> 头的内容。</li></ul></li><li><strong>错误处理</strong>:<ul><li>如果 <code>ngx_http_complex_value</code> 函数返回 <code>NGX_ERROR</code>，这通常意味着在尝试获取或计算 <code>X-Forwarded-For</code> 头的值时出现了问题，比如内存分配失败。在这种情况下，<code>ngx_http_upstream_init_hash_peer</code> 函数将返回 <code>NGX_ERROR</code>，导致当前请求的上游处理初始化失败。</li></ul></li><li><strong>调试日志</strong>:<ul><li>如果 <code>ngx_http_complex_value</code> 成功执行，将记录一条调试日志，显示 “upstream hash key” 以及计算出的键值。</li></ul></li><li><strong>继续处理</strong>:<ul><li>如果 <code>ngx_http_complex_value</code> 成功，函数将继续执行，<code>hp-&gt;key</code> 将用于后续的哈希计算和对等体选择过程。</li></ul></li></ol><p>总结来说，<code>if (ngx_http_complex_value(r, &amp;hcf-&gt;key, &amp;hp-&gt;key) != NGX_OK) &#123; return NGX_ERROR; &#125;</code> 这段代码是用来检查 <code>ngx_http_complex_value</code> 函数是否成功执行，并根据执行结果决定是否继续处理请求。如果 <code>X-Forwarded-For</code> 头存在且格式正确，<code>hp-&gt;key</code> 将被赋予相应的值；如果获取头信息失败或在执行过程中遇到错误，请求处理将被中止，并返回错误状态。</p><p>初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">tatic <span class="hljs-type">ngx_command_t</span>  ngx_http_upstream_hash_commands[] = &#123;<br><br>    &#123; ngx_string(<span class="hljs-string">&quot;hash&quot;</span>),<br>      NGX_HTTP_UPS_CONF|NGX_CONF_TAKE12,<br>      ngx_http_upstream_hash,<br>      NGX_HTTP_SRV_CONF_OFFSET,<br>      <span class="hljs-number">0</span>,<br>      <span class="hljs-literal">NULL</span> &#125;,<br><br>      ngx_null_command<br>&#125;;<br></code></pre></td></tr></table></figure><p>设置值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *<br><span class="hljs-title function_">ngx_http_upstream_hash</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">ngx_command_t</span> *cmd, <span class="hljs-type">void</span> *conf)</span><br>&#123;<br>    <span class="hljs-type">ngx_http_upstream_hash_srv_conf_t</span>  *hcf = conf;<br><br>    <span class="hljs-type">ngx_str_t</span>                         *value;<br>    <span class="hljs-type">ngx_http_upstream_srv_conf_t</span>      *uscf;<br>    <span class="hljs-type">ngx_http_compile_complex_value_t</span>   ccv;<br><br>    value = cf-&gt;args-&gt;elts;<br><br>    ngx_memzero(&amp;ccv, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_http_compile_complex_value_t</span>));<br><br>    ccv.cf = cf;<br>    ccv.value = &amp;value[<span class="hljs-number">1</span>];<br>    ccv.complex_value = &amp;hcf-&gt;key;<br><br>    <span class="hljs-keyword">if</span> (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) &#123;   <span class="hljs-comment">//变量替换值，比如：hash $http_x_forwarded_for;</span><br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>    &#125;<br><br>    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);<br><br>    <span class="hljs-keyword">if</span> (uscf-&gt;peer.init_upstream) &#123;<br>        ngx_conf_log_error(NGX_LOG_WARN, cf, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;load balancing method redefined&quot;</span>);<br>    &#125;<br><br>    uscf-&gt;flags = NGX_HTTP_UPSTREAM_CREATE<br>                  |NGX_HTTP_UPSTREAM_WEIGHT<br>                  |NGX_HTTP_UPSTREAM_MAX_CONNS<br>                  |NGX_HTTP_UPSTREAM_MAX_FAILS<br>                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT<br>                  |NGX_HTTP_UPSTREAM_DOWN;<br><br>    <span class="hljs-keyword">if</span> (cf-&gt;args-&gt;nelts == <span class="hljs-number">2</span>) &#123;<br>        uscf-&gt;peer.init_upstream = ngx_http_upstream_init_hash;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_strcmp(value[<span class="hljs-number">2</span>].data, <span class="hljs-string">&quot;consistent&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        uscf-&gt;peer.init_upstream = ngx_http_upstream_init_chash;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;invalid parameter \&quot;%V\&quot;&quot;</span>, &amp;value[<span class="hljs-number">2</span>]);<br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_CONF_OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>应用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_upstream_init_hash_peer</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_srv_conf_t</span> *us)</span><br>&#123;<br>    <span class="hljs-type">ngx_http_upstream_hash_srv_conf_t</span>   *hcf;<br>    <span class="hljs-type">ngx_http_upstream_hash_peer_data_t</span>  *hp;<br><br>    hp = ngx_palloc(r-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_http_upstream_hash_peer_data_t</span>));<br>    <span class="hljs-keyword">if</span> (hp == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    r-&gt;upstream-&gt;peer.data = &amp;hp-&gt;rrp;<br><br>    <span class="hljs-keyword">if</span> (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    r-&gt;upstream-&gt;peer.get = ngx_http_upstream_get_hash_peer;<br><br>    hcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_upstream_hash_module);<br><br>    <span class="hljs-keyword">if</span> (ngx_http_complex_value(r, &amp;hcf-&gt;key, &amp;hp-&gt;key) != NGX_OK) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,  <span class="hljs-comment">//这里日志会输出</span><br>                   <span class="hljs-string">&quot;upstream hash key:\&quot;%V\&quot;&quot;</span>, &amp;hp-&gt;key);<br><br>    hp-&gt;conf = hcf;<br>    hp-&gt;tries = <span class="hljs-number">0</span>;<br>    hp-&gt;rehash = <span class="hljs-number">0</span>;<br>    hp-&gt;hash = <span class="hljs-number">0</span>;<br>    hp-&gt;get_rr_peer = ngx_http_upstream_get_round_robin_peer;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、sticky"><a href="#4、sticky" class="headerlink" title="4、sticky"></a>4、sticky</h2><h3 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h3><p>Sticky（会话粘性）模块的核心目标是在负载均衡场景下，将同一客户端的所有请求“粘”到一台后端服务器上，避免因多次随机或轮询调度引起的会话状态丢失或不一致。它通过在客户端与 Nginx 之间交换一个小巧的标识符（通常是 HTTP Cookie，也可选用 HTTP Header 或 URL 参数）来实现这一机制。</p><ul><li>模块演进<ul><li>最早的实现往往基于客户端 IP（IP Hash），但在 NAT、代理大量存在的环境里，IP 并不能准确区分用户，且不支持同一用户多设备切换场景。</li><li>基于 Cookie 的 Sticky 引入后端可控的标识符（SID），无需共享后端 session 存储，也不会因客户端 IP 变化而失效。</li></ul></li><li>工作范式<ol><li>初始化阶段：为每台后端 server 生成一个唯一的 SID（MD5）；</li><li>请求阶段：检查客户端是否携带有效 SID，无则走正常负载均衡并记下所选 server；</li><li>响应阶段：向客户端下发 <code>Set-Cookie: &lt;name&gt;=&lt;SID&gt;</code>，或同等手段；</li><li>后续请求：客户端自动携带该 SID，Nginx 直接根据 SID 映射到固定的后端 server。</li></ol></li><li>优缺点对比<ul><li>优点：无需后端共享存储、可精确控制；支持 HTTPS 下的 Secure、HttpOnly；可与健康检查一起使用；兼容多路径、多子域场景。</li><li>缺点：Cookie 丢失或被清除后会重新分配；首次请求仍然有调度抖动；对 Cookie 攻击（Rebinding）需加签名或加密。</li></ul></li></ul><hr><h3 id="4-2、使用示例"><a href="#4-2、使用示例" class="headerlink" title="4.2、使用示例"></a>4.2、使用示例</h3><p>示例 1：基础 Cookie 粘性</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.1:8080</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.2:8080</span>;<br>    <span class="hljs-attribute">session_sticky</span> cookie=session_id expires=<span class="hljs-number">24h</span> path=/;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>说明：使用名为 <code>session_id</code> 的 Cookie，实现 24 小时粘性。</li></ul><p>示例 2：基于自定义变量的路由</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">map</span> <span class="hljs-variable">$remote_addr</span> <span class="hljs-variable">$route_hash</span> &#123;<br>    <span class="hljs-attribute">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    192.168.0.0/16  backend1;<br>    10.10.0.0/16     backend2;<br>&#125;<br><br><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.1:8080</span> route=backend1;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">10.0.0.2:8080</span> route=backend2;<br>    <span class="hljs-attribute">session_sticky</span> cookie=sb route=<span class="hljs-variable">$route_hash</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>说明：通过 <code>map</code> 指令自定义 $route_hash，客户端 IP 在特定网段下直接粘到指定后端。</li></ul><p>示例 3：多子应用共存</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx">nginx复制编辑<span class="hljs-section">upstream</span> appA &#123;<br>    <span class="hljs-attribute">server</span> a1:<span class="hljs-number">8000</span>; <span class="hljs-attribute">server</span> a2:<span class="hljs-number">8000</span>;<br>    <span class="hljs-attribute">session_sticky</span> cookie=appA_sid path=/appA domain=.example.com;<br>&#125;<br><span class="hljs-section">upstream</span> appB &#123;<br>    <span class="hljs-attribute">server</span> b1:<span class="hljs-number">9000</span>; <span class="hljs-attribute">server</span> b2:<span class="hljs-number">9000</span>;<br>    <span class="hljs-attribute">session_sticky</span> cookie=appB_sid path=/appB domain=.example.com;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> example.com;<br><br>    <span class="hljs-section">location</span> /appA/ &#123; <span class="hljs-attribute">proxy_pass</span> http://appA; &#125;<br>    <span class="hljs-section">location</span> /appB/ &#123; <span class="hljs-attribute">proxy_pass</span> http://appB; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>说明：不同子应用使用不同 Cookie 名与 Path，互不干扰。</li></ul><h3 id="4-3、原理分析"><a href="#4-3、原理分析" class="headerlink" title="4.3、原理分析"></a>4.3、原理分析</h3><p>3.1 配置解析与初始化</p><p>当 Nginx 启动或执行热加载时，会依次解析所有配置文件中的指令。对于 <code>session_sticky</code> 指令，Nginx 会调用模块中定义的处理函数 <code>ngx_http_upstream_session_sticky</code>，将用户在 <code>upstream &#123;&#125;</code> 块中指定的参数（如 <code>cookie</code> 名称、<code>route</code> 变量、<code>domain</code>、<code>path</code>、<code>expires</code> 等）存入相应的配置结构体（<code>ngx_http_upstream_ss_srv_conf_t</code>）。</p><p>随后，Nginx 会在整体 HTTP 模块的主初始化函数 <code>ngx_http_upstream_init_main_conf</code> 中，遍历每一个 <code>upstream</code> 块，并对其调用 <code>peer.init_upstream</code> 回调。由于 <code>session_sticky</code> 在上一步已将 <code>uscf-&gt;peer.init_upstream</code> 指向了 <code>ngx_http_upstream_session_sticky_init_upstream</code>，此时就会执行该函数。</p><p>在 <code>ngx_http_upstream_session_sticky_init_upstream</code> 中，模块会为当前 <code>upstream</code> 下的每一个后端 <code>server</code> 调用 <code>ngx_http_upstream_session_sticky_set_sid</code>，利用服务器名称（或自定义的 <code>route</code> 参数）生成并缓存一个唯一的 SID（Session ID），并完成内部哈希表或链表等数据结构的初始化，以便后续快速查找与路由。整个流程确保：</p><ol><li>指令参数 在配置阶段被正确解析并保存在模块配置里；</li><li>回调注册 在解析完成后被挂载到 Nginx upstream 的初始化流程中；</li><li>SID 生成 和相关数据结构在配置加载时一次性完成，不再在请求路径上重复计算。</li></ol><p>3.2 SID 的生成与作用</p><p>SID（Session ID）用于唯一标识后端服务器，确保同一用户的请求被路由到相同的服务器。在 <code>ngx_http_upstream_session_sticky_set_sid</code> 函数中，SID 是通过对服务器名称进行 MD5 哈希计算生成的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_md5_init(&amp;md5);<br>ngx_md5_update(&amp;md5, s-&gt;name-&gt;data, s-&gt;name-&gt;len);<br>ngx_md5_final(buf, &amp;md5);<br>ngx_hex_dump(s-&gt;sid.data, buf, <span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>生成的 SID 是一个 32 字节的十六进制字符串，与服务器绑定，确保在服务器重启或配置重载后保持不变。这种设计保证了在 Nginx 重启或热加载配置时，相同服务器始终对应相同的 SID，而不同服务器则拥有不同的 SID，从而实现稳定的一一绑定。</p><p> SID 会存储在 <code>ngx_http_ss_server_t</code> 结构的 <code>sid</code> 字段中，用于后续请求的快速匹配。在请求处理阶段，模块无需再次进行哈希计算，只需将客户端 Cookie 中传回的 SID 与各后端 <code>sid</code> 字段进行对比，即可迅速定位到目标服务器，实现高效的粘性路由。</p><p>3.3 请求中的 Cookie 读取</p><p>当客户端发送请求时，模块会在 <code>ngx_http_session_sticky_get_cookie</code> 中处理整个 <code>Cookie</code> 头部（HTTP 请求头中的单行，包含多对 <code>name=value</code>），并 从中查找键名与配置中一致的项（默认为 <code>session</code>，也可通过 <code>cookie=xxx</code> 自定义）。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">GET</span> /resource <span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span><br><span class="hljs-title class_">Host</span>: www.<span class="hljs-property">example</span>.<span class="hljs-property">com</span><br><span class="hljs-title class_">Cookie</span>: session=dcf207e1a28a5e6f4b2d9fc0d1e5e6c3; userid=<span class="hljs-number">42</span>; theme=light<br></code></pre></td></tr></table></figure><ul><li>按照 RFC 6265 的定义，<code>Cookie</code> 头部由以分号+空格分隔的 <code>cookie-pair</code> 列表组成；服务器解析时会拆分此头部，获得各个 <code>name=value</code> 对</li><li>模块代码会遍历所有 <code>cookie-pair</code>，比较键名（<code>session</code>）与配置值，一旦匹配便提取该项的 值 作为 SID </li><li>若客户端未携带该键名的 Cookie，或提取到的值与任何后端服务器的预生成 SID 不匹配，则视为“无有效 SID”。</li></ul><hr><p>3.4 使用 Cookie 值进行路由</p><p>在 <code>ngx_http_upstream_session_sticky_get_peer</code> 中，模块根据提取到的 SID：</p><ol><li>在内部维护的服务器列表（每个元素保存了启动时由 <code>ngx_http_upstream_session_sticky_set_sid</code> 计算好的固定 SID）中进行查找。</li><li>若找到了与该 SID 完全相同的条目，则直接将请求路由到对应的后端服务器，实现会话粘性。</li><li>若未找到匹配项（可能因为后端下线、SID 被篡改或过期），模块会退回到默认的负载均衡算法（如轮询 round‑robin），并在后续响应阶段下发新的 SID</li></ol><p>这种基于从整体 <code>Cookie</code> 头部提取特定字段并直接映射到服务器的方式，既符合 HTTP 状态管理规范，也保证了高效的请求转发。</p><hr><p>3.5 响应中的 Cookie 设置</p><p>在响应阶段，若检测到“无有效 SID”或首次访问，模块会在 <code>ngx_http_session_sticky_header_filter</code> 中插入一个 <code>Set-Cookie</code> 头，将所选服务器的 SID 返回给客户端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: application/json<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: session=dcf207e1a28a5e6f4b2d9fc0d1e5e6c3; <span class="hljs-title class_">Path</span>=/; <span class="hljs-title class_">Domain</span>=.<span class="hljs-property">example</span>.<span class="hljs-property">com</span>; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">15</span> <span class="hljs-title class_">May</span> <span class="hljs-number">2025</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span><br></code></pre></td></tr></table></figure><ul><li>根据Set-Cookie 规范，每个 <code>Set-Cookie</code> 头仅设置一对 <code>cookie-pair</code> 并可附加属性，如 <code>Path</code>、<code>Domain</code>、<code>Expires</code> 等</li><li>浏览器在后续同域且满足路径匹配的请求中，会自动在请求头 <code>Cookie</code> 中包含此 <code>session=...</code> 项（仅发送 <code>name=value</code> 部分，属性不会带回）</li><li>这就完成了从“无 SID → 选 server → 下发 SID → 客户端携带 SID → 再次路由”的完整闭环。</li></ul><h3 id="4-4、总结"><a href="#4-4、总结" class="headerlink" title="4.4、总结"></a>4.4、总结</h3><p>Tengine 的 <code>session_sticky</code> 模块通过以下三步实现会话粘性路由：</p><ol><li>配置初始化阶段：为每个后端 server 生成并固定一个唯一的 SID（MD5 哈希）</li><li>请求阶段：从整体 <code>Cookie</code> 头部中提取与配置键名一致的项（如 <code>session</code>），将其值作为 SID，与后端列表匹配，实现“粘性”路由。</li><li>响应阶段：在首次或失效情况下，通过 <code>Set-Cookie</code> 下发选中服务器的 SID，确保客户端在后续请求中带上正确的 <code>session</code> 项</li></ol><p>这种设计既遵循了 HTTP 状态管理机制，又在 Nginx 的高性能代理框架中保证了极低的路由开销和高度的可扩展性。只需合理配置 <code>cookie</code>、<code>path</code>、<code>domain</code>、<code>expires</code> 等参数，即可满足大多数有状态应用的会话粘性需求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">                客户端请求进来<br>                        │<br>                        ▼<br>          ┌────────────────────────────┐<br>          │ 检查请求中是否带有 sticky cookie │<br>          └────────────────────────────┘<br>                        │<br>          ┌─────────────┴─────────────┐<br>          ▼                           ▼<br>  有 cookie                        没有 cookie<br>          │                           │<br>          ▼                           ▼<br>  提取 cookie 中的 sid        从 upstream 选择后端（如 round-robin）<br>          │                           │<br>          ▼                           ▼<br>  查找 sid 是否匹配某个 server       为选中的 server 计算 sid<br>          │                           │<br>    ┌─────┴──────┐                    │<br>    ▼            ▼                   ▼<br>  匹配成功     匹配失败       设置 sid 到响应 <span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span><br>    │            │                   │<br>    ▼            ▼                   ▼<br>请求被转发到对应 server     fallback 转发        响应客户端<br>                                  │<br>                                  ▼<br>                         客户端保存 sticky cookie<br><br></code></pre></td></tr></table></figure><h3 id="4-5、实际的问题"><a href="#4-5、实际的问题" class="headerlink" title="4.5、实际的问题"></a>4.5、实际的问题</h3><p><strong>1、 SID 生成原理</strong></p><p>在<code>session_sticky</code> 模块中，每台后端服务器的 SID 在配置初始化阶段一次性生成，不再在请求处理时重复计算。生成逻辑为：将服务器名称（<code>s-&gt;name</code>，既可以是 <code>IP:端口</code>，也可以是自定义的 <code>route</code> 值）作为输入，调用 Nginx 自带的 MD5 接口计算哈希，然后将 16 字节的二进制哈希转换为 32 字节的十六进制字符串，存入 <code>s-&gt;sid</code> 字段。这种设计保证了，只要配置不变，同一服务器永久对应同一 SID，即便 Nginx 重启或热加载配置，SID 也保持不变，便于后续快速匹配 </p><p><strong>2、 多 <code>upstream</code> + 同名 Cookie 导致的覆盖场景</strong></p><p>当在同一域名下为多个不同路径或业务的 <code>upstream</code> 块都启用了相同 Cookie 名称（如 <code>session</code>），且未做任何作用域区分时，会在浏览器端出现 “不断被覆盖” 的问题：</p><ol><li><p>**首次访问 <code>/A</code>**：</p><ul><li><p>后端组 <code>backendA</code> 随机选取一台服务器，响应中下发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: session=cf9b71f0c789b0ae845b65e5e3a171a5; <span class="hljs-title class_">Path</span>=/; <span class="hljs-title class_">Domain</span>=example.<span class="hljs-property">com</span>; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">15</span> <span class="hljs-title class_">May</span> <span class="hljs-number">2025</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>**随后访问 <code>/B</code>**：</p><ul><li><p>后端组 <code>backendB</code> 随机选取一台服务器，响应中也下发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> <span class="hljs-variable constant_">OK</span><br><span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>: text/html<br><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>: session=cf9b71f0c789b0ae845b65e5e3a171a5; <span class="hljs-title class_">Path</span>=/; <span class="hljs-title class_">Domain</span>=example.<span class="hljs-property">com</span>; <span class="hljs-title class_">Expires</span>=<span class="hljs-title class_">Wed</span>, <span class="hljs-number">15</span> <span class="hljs-title class_">May</span> <span class="hljs-number">2025</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-variable constant_">GMT</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>浏览器行为</strong>：</p><ul><li>若两条 <code>Set-Cookie</code> 指令同名同域同路径，则后者直接覆盖前者；若路径不同，浏览器会分别存储两条条目，但在请求时只发送与当前路径最匹配的那一条。</li></ul></li><li><p><strong>结果</strong>：</p><ul><li>访问 <code>/A</code>、<code>/B</code> 时 Cookie 值交替覆盖或切换，粘性路由无法生效</li></ul></li></ol><p><strong>3、 解决办法</strong></p><p>方案一：不同 Cookie 名称</p><p>为不同 <code>upstream</code> 指定互不干扰的 Cookie 名称，确保浏览器分别存储：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backendA &#123;<br>    <span class="hljs-attribute">session_sticky</span> cookie=SESSION_A route=<span class="hljs-variable">$route_hash</span>;<br>    <span class="hljs-attribute">server</span> a1:<span class="hljs-number">8081</span> route=a1;<br>    <span class="hljs-attribute">server</span> a2:<span class="hljs-number">8081</span> route=a2;<br>&#125;<br><span class="hljs-section">upstream</span> backendB &#123;<br>    <span class="hljs-attribute">session_sticky</span> cookie=SESSION_B route=<span class="hljs-variable">$route_hash</span>;<br>    <span class="hljs-attribute">server</span> b1:<span class="hljs-number">8082</span> route=b1;<br>    <span class="hljs-attribute">server</span> b2:<span class="hljs-number">8082</span> route=b2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>backendA</code> 下发 <code>SESSION_A=…</code>，<code>backendB</code> 下发 <code>SESSION_B=…</code>，互不覆盖</li></ul><p>方案二：同名 Cookie + 不同 Path</p><p>在同一个域名下，用相同名称但为不同路径设置 <code>path</code> 属性，浏览器会区分存储：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backendA &#123;<br>    <span class="hljs-attribute">session_sticky</span> cookie=session path=/A domain=example.com expires=<span class="hljs-number">1h</span>;<br>    <span class="hljs-attribute">server</span> a1:<span class="hljs-number">8081</span>;<br>    <span class="hljs-attribute">server</span> a2:<span class="hljs-number">8081</span>;<br>&#125;<br><span class="hljs-section">upstream</span> backendB &#123;<br>    <span class="hljs-attribute">session_sticky</span> cookie=session path=/B domain=example.com expires=<span class="hljs-number">1h</span>;<br>    <span class="hljs-attribute">server</span> b1:<span class="hljs-number">8082</span>;<br>    <span class="hljs-attribute">server</span> b2:<span class="hljs-number">8082</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>访问 <code>/A</code> 时只发送 <code>session</code>（Path&#x3D;&#x2F;A）；访问 <code>/B</code> 时只发送对应的那条。</li></ul><p>方案三：合并 upstream + 变量路由</p><p>将所有后端合并到一个组，通过 <code>map</code> 或 <code>route</code> 变量决定路由，然后用单一 Sticky 管理会话：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">map</span> <span class="hljs-variable">$request_uri</span> <span class="hljs-variable">$target</span> &#123;<br>    ~^/<span class="hljs-attribute">A</span>    backendA;<br>    ~^/<span class="hljs-attribute">B</span>    backendB;<br>&#125;<br><span class="hljs-section">upstream</span> backend &#123;<br>    <span class="hljs-attribute">server</span> a1:<span class="hljs-number">8081</span> route=a1;<br>    <span class="hljs-attribute">server</span> a2:<span class="hljs-number">8081</span> route=a2;<br>    <span class="hljs-attribute">server</span> b1:<span class="hljs-number">8082</span> route=b1;<br>    <span class="hljs-attribute">server</span> b2:<span class="hljs-number">8082</span> route=b2;<br>    <span class="hljs-attribute">session_sticky</span> cookie=session route=<span class="hljs-variable">$route_hash</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://backend;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过 <code>$route_hash</code>（可以映射自 <code>$request_uri</code> 或其他变量）实现对不同路径的路由，再由同一 Cookie 维护粘性 。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>负载均衡</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析nginx实现websocket原理</title>
    <link href="/2024/04/12/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/12/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​传统的HTTP协议是一种无状态的请求&#x2F;响应协议，每次请求都需要重新建立连接。在一些特殊的业务场景下，服务端需要主动发送数据到客户端，例如行情推送、监控告警推送等。然而，HTTP协议不支持双向通信，因此需要将HTTP协议“升级”为WebSocket协议。WebSocket协议可以在建立连接后保持连接状态，双方可以通过一个持久的连接通道进行实时通信。WebSocket连接在建立时通过HTTP协议进行握手，之后的数据传输就可以使用WebSocket协议进行。</p><p>Nginx作为中间层的Web服务器，支持使用多种协议与上下游进行通信，包括TCP、HTTP、WebSocket等协议，如下图所示。</p><p><img src="/img/%E5%9B%BE1.png" alt="图1"></p><h2 id="1、nginx升级http为websocket的过程"><a href="#1、nginx升级http为websocket的过程" class="headerlink" title="1、nginx升级http为websocket的过程"></a>1、nginx升级http为websocket的过程</h2><p>​HTTP&#x2F;1.1提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。具体过程如下：</p><p><img src="/img/%E5%9B%BE2.png" alt="图2"></p><p>1.客户端发起 WebSocket 连接请求到 Nginx，Nginx 作为反向代理服务器，将请求转发给上游 WebSocket 服务器。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">GET ws://<span class="hljs-number">10.40</span>.xx.xx:<span class="hljs-number">58088</span>/wss/socket.io HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">10.40</span>.xx.xx:<span class="hljs-number">58088</span><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: <span class="hljs-number">13</span><br>Sec-WebSocket-Key: <span class="hljs-number">3</span>baOagQNXoc1Cd1dJ4pBiA==<br>Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits<br></code></pre></td></tr></table></figure><p>2.上游 WebSocket 服务器响应连接请求并完成握手协议，如果允许升级，将响应状态码101返回给 Nginx。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> Switching Protocols<br>Server:xxx<br>Date:Wed,<span class="hljs-number">22</span> Feb <span class="hljs-number">2023</span> <span class="hljs-number">06</span>:<span class="hljs-number">23</span>:<span class="hljs-number">49</span> GMT<br>connection:upgrade<br>upgrade:websocket<br>Sec-WebSocket-accept:VVN2Pd9jkG7b8ur3otAk+Ah3bsg=<br>Sec-WebSocket-Extensions:permessage-deflate<br></code></pre></td></tr></table></figure><p>3.Nginx 收到上游 WebSocket 服务器的响应结果后，将其转发给客户端，建立起客户端与上游 WebSocket 服务器的连接。</p><p>4.客户端和上游 WebSocket 服务器之间开始进行实时数据传输。</p><p>5.当客户端或上游 WebSocket 服务器需要发送数据时，数据将通过 WebSocket 协议封装成帧（frame）并发送到对方。</p><p>6.数据通过 Nginx 进行转发时，Nginx 会根据实际情况选择合适的负载均衡算法，将数据传输到适当的上游 WebSocket 服务器。</p><p>7.上游 WebSocket 服务器收到数据后，解析数据帧并处理数据，然后将响应结果封装成帧并发送回客户端。</p><p>8.客户端收到上游 WebSocket 服务器的响应结果后，解析数据帧并处理数据，完成一次数据交互。</p><h2 id="2、nginx核心代码实现"><a href="#2、nginx核心代码实现" class="headerlink" title="2、nginx核心代码实现"></a>2、nginx核心代码实现</h2><h3 id="2-1、连接升级"><a href="#2-1、连接升级" class="headerlink" title="2.1、连接升级"></a>2.1、连接升级</h3><p>​当服务端同意升级为 WebSocket 时，会将响应状态码设置为 “101 Switching Protocols”，表示服务器正在切换协议。如下代码所示，在处理 HTTP 协议时，首先会检查连接是否已升级到另一个协议。其中，NGX_HTTP_SWITCHING_PROTOCOLS 是一个宏，值为 101。然后，会检查客户端的请求是否携带 Upgrade 头部。如果请求携带了该头部，就会将 u-&gt;upgrade 的值设为 1，表示该连接是一个升级连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查响应的状态码</span><br><span class="hljs-keyword">if</span> (u-&gt;headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) &#123;<br>                u-&gt;keepalive = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//客户端请求头是否含有upgrade头部</span><br>                <span class="hljs-keyword">if</span> (r-&gt;headers_in.upgrade) &#123;<br>                    u-&gt;upgrade = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、上下游数据处理"><a href="#2-2、上下游数据处理" class="headerlink" title="2.2、上下游数据处理"></a>2.2、上下游数据处理</h3><p>​nginx基于事件驱动模型，当有事件触发时，就会调用对应的回调函数。</p><p>下游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>    r-&gt;write_event_handler(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    r-&gt;read_event_handler(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>上游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>        u-&gt;write_event_handler(r, u);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        u-&gt;read_event_handler(r, u);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​每个连接都根据类型(http、websocket等)的不同，设置不同的回调，下面的代码展示了当连接的u-&gt;upgrade &#x3D; 1，即为websocket协议时，设置的上下游读写回调函数。当此连接再有读写事件时，就会回调下面设置的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//接收来自upstream的数据 </span><br>u-&gt;read_event_handler = ngx_http_upstream_upgraded_read_upstream;<br><span class="hljs-comment">//向upstream发送数据</span><br>u-&gt;write_event_handler = ngx_http_upstream_upgraded_write_upstream;<br><span class="hljs-comment">//接收来自客户端的数据</span><br>r-&gt;read_event_handler = ngx_http_upstream_upgraded_read_downstream;<br><span class="hljs-comment">//向客户端发送数据</span><br>r-&gt;write_event_handler = ngx_http_upstream_upgraded_write_downstream;<br></code></pre></td></tr></table></figure><p>​实际上，这四个回调函数都调用了同一个处理函数。但是，它们分别传入了不同的参数，因此函数的处理方式也不同，对应四种不同的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​此处的设计非常巧妙（部分代码），使用了不同参数复用了同一个函数。下面的核心代码展示了 Nginx 如何处理事件。</p><p>当数据来自于服务端时，from_upstream 为真，do_write 表示需要发送数据。根据下面的代码，可以看出 src 表示服务端的连接，dst 表示客户端的连接。当 do_write 为 1 且 dst 准备好写入操作（并且需要发送的数据长度不为 0）时，dst 就会发送数据；当 src 准备好读取操作时，src 就会读取数据。</p><p>比较有意思的是，当数据来自于客户端时，只需要将 dst 和 src 交换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_process_upgraded</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_uint_t</span> from_upstream, <span class="hljs-type">ngx_uint_t</span> do_write)</span><br>&#123;<br>    <span class="hljs-comment">//客户端连接</span><br>    downstream = r-&gt;connection;<br>    <span class="hljs-comment">//服务端连接</span><br>    upstream = r-&gt;upstream-&gt;peer.connection;<br>    <br>    <span class="hljs-comment">// 如果数据来自于后端服务器</span><br>    <span class="hljs-keyword">if</span> (from_upstream) &#123;<br>        src = upstream;<br>        dst = downstream;<br>        b = &amp;u-&gt;buffer;<br>    <span class="hljs-comment">// 如果数据来自于客户端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        src = downstream;<br>        dst = upstream;<br>        b = &amp;u-&gt;from_client;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        <span class="hljs-comment">// 判断是否需要发送数据</span><br>        <span class="hljs-keyword">if</span> (do_write) &#123;<br>            <span class="hljs-comment">// 获取当前要发送的数据长度</span><br>            size = b-&gt;last - b-&gt;pos;<br>            <span class="hljs-comment">// 如果要发送的数据长度不为 0，且连接已经准备好进行写操作</span><br>            <span class="hljs-keyword">if</span> (size &amp;&amp; dst-&gt;write-&gt;ready) &#123;<br>                <span class="hljs-comment">// 发送数据</span><br>                n = dst-&gt;send(dst, b-&gt;pos, size);<br>            &#125;<br>        &#125;<br>        size = b-&gt;end - b-&gt;last;<br>        <span class="hljs-comment">// 如果要接收的数据长度不为 0，且连接已经准备好读操作</span><br>        <span class="hljs-keyword">if</span> (size &amp;&amp; src-&gt;read-&gt;ready) &#123;<br>            <span class="hljs-comment">// 接收数据</span><br>            n = src-&gt;recv(src, b-&gt;last, size);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、使用实例"><a href="#3、使用实例" class="headerlink" title="3、使用实例"></a>3、使用实例</h2><p>本节将通过 Nginx 和 WebSocket 客户端&#x2F;服务端的实例，展示如何在实际业务中使用 WebSocket 进行消息推送。</p><p>首先，需要对 Nginx进行路由配置，如下图所示。即，所有以 uri 前缀为 wss 的 HTTP 客户端请求都会被升级为 WebSocket。在代理过程中，HSIAR 还需要将 Connection 和 Upgrade 头部携带给后端服务，告知后端需要将 Nginx 与后端的连接升级为 WebSocket。</p><p><img src="/img/%E5%9B%BE3.png" alt="图3"></p><p>2、建立连接的过程如下图所示，可以看到与2.1节所述过程一致</p><p><img src="/img/%E5%9B%BE4.png" alt="图4"></p><p>3、连接建立成功后，点击订阅，即接收消息的推送</p><p><img src="/img/%E5%9B%BE5.png" alt="图5"></p><p>4、后端推送消息</p><p>可以看到消息由后端成功推送到了客户端</p><p><img src="/img/%E5%9B%BE6.png" alt="图6"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>在实际的生产中，消息推送是一种常用的技术。然而，如果在 WebSocket 客户端和服务端之间的链路中加入代理，尤其是多级代理后，情况就会变得更加复杂。为了确保链路上的每一条连接都是 WebSocket 长连接，需要避免中间出现 HTTP 短链接。否则，推送就可能因连接提前断开而失败。了解该技术的原理和细节，可以帮助快速排查问题并进行修复。同时，研究 Nginx 对 WebSocket 的支持技术实现，不仅能够提高对该技术的理解，也能够为今后开发相关系统提供有益的借鉴。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>websocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协商缓存在nginx的应用与实践</title>
    <link href="/2024/04/12/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/04/12/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>缓存是一个高效减轻网络与服务器压力的机制，具有减少冗余数据传输、缓解网络瓶颈以及降低时延等优点。通常客户端在请求数据时，会发送请求到原始服务器获取，重复的数据可能会在网络中多次传输，但是如果有缓存，客户端就可以直接从缓存中获取数据，减少重复的流量。例如在浏览器首次请求某些静态资源时，状态码会是200 ok，但是刷新页面，状态码就会变为200 ok ( from memory cache)，这是因为浏览器对这些资源进行了缓存，客户端的数据并不是发送请求到原始服务器获取的，而是从缓存中获取的。</p><p><img src="/img/%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="缓存流程图"></p><p>但是问题也是显而易见的，如果原始服务器的数据发生了改变，而缓存并没有及时更新数据，在客户端请求时返回了过期的数据，这就会导致了数据的不准确。已缓存的数据应当与原始服务器的数据保持一致，更准确的来说，是缓存返回的数据应当与原始服务器的数据保持一致。那么如何在缓存的基础上，避免这个问题呢？事实上，HTTP协议是提供了多种机制来保证数据一致性的。</p><h2 id="2、“使用期”与“新鲜度“"><a href="#2、“使用期”与“新鲜度“" class="headerlink" title="2、“使用期”与“新鲜度“"></a>2、“使用期”与“新鲜度“</h2><p>使用期是指数据在服务器响应返回后的总时间，可以简单理解为数据在缓存使用的时间，从服务器将数据发出去开始计时；新鲜度是指数据在服务器响应发出去后，缓存可以使用的时间。如果使用期小于新鲜度，说明数据是“新鲜的”，缓存可以继续使用。反之，缓存需要判断数据是否发生了更新，是否需要重新拉取数据，如何更新这取决于服务端采用的HTTP缓存策略。</p><p><strong>使用期：</strong></p><p>服务器用HTTP协议的响应头部date表示发送数据时的时间，如果客户端与服务端使用同样的、完全精确的时钟，已缓存数据的使用期（data_age）就可以是当前时间（current_time）减去服务器发送数据时（Date_header_value）的时间。</p><p>data_age &#x3D; current_time – date_header_value</p><p>但是并不是所有的计算机都实现了时钟同步，当服务器和客户端的时钟不同步时，使用期可能是很大或者甚至是负的，如果是负的，就需要将其设置为零。</p><p>data_age &#x3D; max(0，current_time – date_header_value)</p><p>date_header_value的值代表着原始服务器发出数据的时间，所以在经过代理时，一定不能进行修改。</p><p><strong>新鲜度：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Expires : Fri, <span class="hljs-number">09</span> Sep <span class="hljs-number">2022</span>, <span class="hljs-number">05</span>:<span class="hljs-number">27</span>:<span class="hljs-number">57</span> GMT<br><br>Cache-Control : max-age=<span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>服务器用HTTP&#x2F;1.0+的Expires或HTTP&#x2F;1.1的Cache-Control:max-age响应头部指定数据的过期时间。Expires指定的是绝对时间，即数据到这个时间就过期了。而Cache-Control:max-age指定的是相对时间，表示缓存收到数据后可以在缓存存活的时间。由于Expires依靠于时钟的准确性，因此目前更多的使用后者。</p><p>通过比对使用期与新鲜度，缓存可以判断当前存储的数据是否足够新鲜，如果足够新鲜，则直接返回缓存中的数据，不然就只能重新从原始服务器拉取数据。但是数据在缓存中已经过期，而原始服务器中并未发生更新，缓存依旧需要发送请求获取数据，这会消耗大量不必要的网络资源。对于网络传输而言，应当遵守以最小数据量传输而保证最大信息量传输的原则，因此为了减少冗余数据的传输，HTTP协议提供了协商缓存机制，用以减少数据的传输。</p><p><img src="/img/%E4%BD%BF%E7%94%A8%E6%9C%9F%E4%B8%8E%E6%96%B0%E9%B2%9C%E5%BA%A6.png" alt="使用期与新鲜度"></p><h2 id="3、协商缓存：no-store、no-cache与must-revalidate"><a href="#3、协商缓存：no-store、no-cache与must-revalidate" class="headerlink" title="3、协商缓存：no-store、no-cache与must-revalidate"></a>3、协商缓存：no-store、no-cache与must-revalidate</h2><figure class="highlight https"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs https">HTTP/1.0:<br><br>    Pragma: no-cache<br><br>HTTP/1.1:<br><br>    Cache-Control: no-store<br><br>    Cache-Control: no-cache<br><br>    Cache-Control: must-revalidate<br></code></pre></td></tr></table></figure><p>服务器可以通过no-store来禁止缓存对数据进行存储，因此每次客户端请求数据时，缓存都需要发送请求到原始服务器获取，这样就可以保证客户端获取数据的新鲜度。</p><p>no-cache与no-store不同，no-cache允许缓存对数据进行存储，缓存需要在原始服务器验证新鲜度之后，才能将数据返回给客户端。通常，如果数据发生了更新，原始服务器会返回更新后的数据；反之，会返回304，表示缓存的数据并没有发生改变，可以把缓存的数据返回给客户端。</p><p>而must-revalidate与no-cache类似，同样允许缓存对数据进行存储。如果缓存的数据过期，则must-revalidate与no-cache的行为一致；但是如果数据未过期，则可以直接返回给客户端数据而无需验证。因此must-revalidate通常需要与Expires、max-age进行配合使用。例如：</p><p><img src="/img/cache-%E5%9B%BE3.png" alt="Cache-Control的使用"></p><p>现在让我们总结一下这3种缓存机制的特点：</p><p>no-store：缓存不可以存储数据，每次请求都需要到服务器获取数据，因此可以保证数据的新鲜度，但是大量冗余数据的传输，会增大网络与服务器的压力，降低系统的整体性能。</p><p>no-cache：缓存可以存储数据，每次请求都需要到服务器进行新鲜度的验证，因此可以保证数据的新鲜度。相比于no-store，减少了大量数据的传输。</p><p>must-revalidate：缓存可以存储数据，如果数据过期，则需要到服务器进行新鲜度的验证，反之，则可以直接返回给客户端数据。相比于no-cache，减少一定数量的新鲜度验证请求，进一步减少网络与服务器的压力，但是不能保证数据的新鲜度，有一定时间的误差，这取决于新鲜度的设置。</p><p>3种机制各有优劣，应该根据具体的业务需求选择合适的缓存机制，但整体来看，no-cache适合绝大部分的场景。 </p><h3 id="3-1、no-cache验证新鲜度：if-modified-since与if-none-match"><a href="#3-1、no-cache验证新鲜度：if-modified-since与if-none-match" class="headerlink" title="3.1、no-cache验证新鲜度：if-modified-since与if-none-match"></a>3.1、no-cache验证新鲜度：if-modified-since与if-none-match</h3><p>当原始服务器采用no-cache缓存模式时，缓存请求数据，服务器的响应会返回响应头Last-Modified与Etag。Last-Modified表示原始服务器修改该数据的最后时间，Etag是一个字符串，不同的系统生成方式也是不同的。缓存在验证新鲜度时，会将这2个值通过2个请求头If-Modified-Since与If-None-Match传送到原始服务器，而原始服务器通过比对这2个值，就可以判断缓存的数据与本地数据是否一致，也就可以决定是否需要返回数据。</p><p>响应：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Last-Modified : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>ETag : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><p>请求：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">If-Modified-Since : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>If-None-Match : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><h2 id="4、协商缓存在nginx的应用"><a href="#4、协商缓存在nginx的应用" class="headerlink" title="4、协商缓存在nginx的应用"></a>4、协商缓存在nginx的应用</h2><h3 id="4-1、应用no-cache对前端的优化"><a href="#4-1、应用no-cache对前端的优化" class="headerlink" title="4.1、应用no-cache对前端的优化"></a>4.1、应用no-cache对前端的优化</h3><p>nginx提供流量分发、协议转换、静态资源代理等功能。本节以HUI前端为例，围绕静态资源代理这一功能，分析nginx何应用no-cache优化前端。</p><p>可以对协商缓存进行设置，最后落地到配置文件nginx.conf，具体配置如下图所示，可以设置单个文件采用协商缓存模式如： sysconfig.js；也可以根据文件类型后缀设置协商缓存模式如：html或js。</p><p><img src="/img/cache-4.png" alt="cache-4"></p><p>首先在浏览器访问前端，可以看到首次访问时，静态资源的状态码是200 ok，这代表数据是从服务器获取到的。</p><p><img src="/img/cache-5.png" alt="cache-5"></p><p>接着刷新界面，可以看到状态码变为304 Not Modified，nginx的日志信息也可以看到客户端是发起了一次请求到nginx获取数据，判断到数据并未发生更新返回304。</p><p><img src="/img/cache-6.png" alt="cache-6"></p><p><img src="/img/cache-7.png" alt="cache-7"></p><p>此时，如果对sysconfig.js进行修改，再次刷新界面，如下图所示，可以看到状态码变为200 ok，修改的内容及时返回到了客户端。</p><p>修改前：</p><p><img src="/img/cache-8.png" alt="cache-8"></p><p>修改：</p><p><img src="/img/cache-9.png" alt="cache-9"></p><p>接着刷新界面，可以看到状态码变为200 ok，而且数据已经更新：</p><p><img src="/img/cache-10.png" alt="cache-10"></p><p><img src="/img/cache-11.png" alt="cache-11"></p><p>   这样既可以保证数据的及时更新，又可以减少大量数据的传输，唯一的网络开销是进行新鲜度的再次验证。</p><h3 id="4-2、nginx源码分析If-Modified-Since与If-None-Match"><a href="#4-2、nginx源码分析If-Modified-Since与If-None-Match" class="headerlink" title="4.2、nginx源码分析If-Modified-Since与If-None-Match"></a>4.2、nginx源码分析If-Modified-Since与If-None-Match</h3><p><strong>etag的生成</strong></p><p>nginx的etag的生成方式比较简单，由last-modified_time与content_length_n转换为十六进制组合而成。其中last-modified_time是通过系统调用，获取的文件最后修改时间，对应操作系统文件结构stat中st_mtime; content-length_n是文件的大小，对应操作系统文件结构stat中st_size;</p><p><img src="/img/cache-12.png" alt="cache-12"></p><p>缓存请求数据时，在响应头返回给缓存。</p><p><img src="/img/cache-13.png" alt="cache-13"></p><p><strong>If-Modified-Since</strong>与<strong>If-None-Match</strong>的校验</p><p>缓存向nginx验证数据新鲜度时，需要携带If-Modified-Since与If-None-Match请求头。</p><p><img src="/img/cache-14.png" alt="cache-14"></p><p>nginx在判断缓存数据的新鲜度时，会先后对If-Modified-Since和If-None-Match与当前数据的last-modified和etag进行比对，只要2者有1个发生了改变，则判断本地数据发生更新，缓存中的数据已过期，就会直接返回更新后的数据，如果都没有变，则会返回304。源码与流程图如下。</p><p><img src="/img/cache-15.png" alt="cache-15"></p><p><img src="/img/cache-16.png" alt="cache-16"></p><h2 id="5、实践出真知"><a href="#5、实践出真知" class="headerlink" title="5、实践出真知"></a>5、实践出真知</h2><h3 id="5-1、抓包分析-协商缓存验证新鲜度"><a href="#5-1、抓包分析-协商缓存验证新鲜度" class="headerlink" title="5.1、抓包分析-协商缓存验证新鲜度"></a>5.1、抓包分析-协商缓存验证新鲜度</h3><p>1、首先用nginx代理一个js文件，浏览器第一次请求资源时，状态码为200 ok，刷线界面，状态码变为304，如下图</p><p><img src="/img/cache-17.png" alt="cache-17"></p><p>为了兼容http1.0，pragma也设置了no-cache</p><p><img src="/img/cache-18.png" alt="cache-18"></p><p><img src="/img/cache-19.png" alt="cache-19"></p><p>2、抓包查看第一次请求的网络包，可以看到服务端返回了静态资源的数据</p><p><img src="/img/cache-20.png" alt="cache-20"></p><p>3、查看第二次请求，可以看到服务端没有返回任何静态资源，只有响应头这些数据</p><p><img src="/img/cache-21.png" alt="cache-21"></p><p>4、符合协商缓存的现象</p><p>当请求的If-Modified-Since、If-None-Match与服务端不一致时，服务端会返回静态资源</p><p><img src="/img/cache-22.png" alt="cache-22"></p><p>但是当请求的If-Modified-Since、If-None-Match与服务端一致时，服务端验证新鲜度足够，就只会返回304</p><p><img src="/img/cache-23.png" alt="cache-23"></p><h3 id="5-2、一个GET请求被缓存导致的登录异常"><a href="#5-2、一个GET请求被缓存导致的登录异常" class="headerlink" title="5.2、一个GET请求被缓存导致的登录异常"></a>5.2、一个GET请求被缓存导致的登录异常</h3><p>首先来看下定义：</p><p>在HTTP规范中，GET请求通常用于从服务器检索数据，而不改变服务器的状态。这种操作被认为是安全的和幂等的，因此响应是可以缓存的。</p><p>HTTP规范规定，POST请求是用来提交数据的，可能会导致服务器状态的改变，因此其响应不应被缓存。</p><p>我们的网关层实现了cas单点登录，其中登录过程会调用一个免密接口，主要用于从权限系统获取权限数据以及一些会话数据，这个请求是get请求。</p><p>问题：当登录成功以后，点击浏览器的回退，这时由于浏览器的TGC没有过期，照理应该重新登录进系统，但是登录后发现，页面空白，请求出现401权限丢失的情况，我发现浏览器并没有真实发起免密接口的调用，而是获取了缓存的数据，这时问题就很明确了。</p><p><img src="/img/cache-24.png" alt="cache-24"></p><p>1、接口的设计不好，这个接口会改变服务器的状态，应该设计为post，但是被错误的设计为get</p><p>2、如果是get也可以兼容，这个接口在返回响应时，增加no-store的响应头，禁止前端缓存，需要注意的是，这个时候用no-cache是不行的。</p><p>照理，接口改为post是最正确的做法，但是现实是要考虑兼容的问题，我们网关层也是需要做修改的。</p><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>协商缓存不只是一种简单的缓存机制，更是一种很好的理念。对于客户端与服务端数据同步、性能优化都是很好的借鉴，尤其是服务端不能主动向客户端发送请求的场景。例如当有服务以域名的形式注册到nginx时，nginx需要向DNS查询真实ip，为了避免每次请求都会向DNS查询，会对查询到的结果进行缓存，并启动定时器查询真实ip是否发生改变。而定时器的时间就类似于协商缓存的新鲜度，在实际的生产中没有完美的方案，因此需要根据具体的需求偏重来调整可靠性与性能。</p><p>本文从HTTP缓存原理出发，介绍了缓存对系统性能优化的意义，并讲解了HTTP缓存发展过程中存在冗余数据多次传输的问题，以及为了解决这个问题而出现的协商缓存机制。通过对协商缓存的原理与nginx实现协商缓存的源码分析，希望大家可以对HTTP缓存有一定的理解。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>协商缓存</tag>
      
      <tag>no cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssl双向验证— ssl_verify_depth的作用</title>
    <link href="/2024/04/12/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/04/12/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关键词</strong>：根证书、中间证书、验证深度、ssl_verify_depth</p><h2 id="根证书与中间证书"><a href="#根证书与中间证书" class="headerlink" title="根证书与中间证书"></a>根证书与中间证书</h2><p>在进行ssl验证前，服务器一般会向CA申请公钥证书，即将自己的公开密钥交给CA，CA用自己的私钥向服务器的公钥数字签名并返回公钥证书，在数字签名的过程中，CA一般会用根目录颁发证书，这种证书叫做根证书。</p><p>问题是，万一根目录颁发错了证书，或者需要撤销根，这时所有根目录颁发的证书都将失效，这样代价是巨大的，因此出现了<strong>中间根</strong>，顾名思义，CA用私钥对中间根进行签名，使它可信，因此由中间根颁发的证书也是可信的，即中间证书。当发生撤销时，只需要撤销中间根颁发的证书就可以。</p><p>这里需要解释一下根证书，个人理解为客户端在验证服务器的公钥证书时，需要拿CA的公钥来解密服务器公钥证书的签名，CA的<strong>根公钥</strong>需要提前拿到手，一般内置到浏览器中，存放的地方视为根目录，存放中间证书即为中间目录。有中间证书的情况下，应该是先从中间目录取到对应<strong>中间公钥</strong>解密，然后循环此过程，直到从根目录拿到公钥验证成功，这时可以算是验证通过。</p><p>同时，在实际生产中，我们拥有私有协议，会存在私有协议的客户端，这些客户端也支持<strong>私有协议</strong>+<strong>ssl</strong>，因此这些客户端也需要内置根证书。</p><h2 id="验证深度"><a href="#验证深度" class="headerlink" title="验证深度"></a>验证深度</h2><p>在CA的证书体系中，证书从根目录出发，像一条链一样，有很多的中间根，也叫做证书链，我觉得更像一棵二叉树。</p><p>在ssl验证的过程中，直接尝试中间证书进行客户端认证是无法通过的，需要一层一层回溯验证，直到找到根。</p><p>这个验证深度就相当于当前中间证书在整棵树中的深度。</p><h2 id="ssl-verify-depth"><a href="#ssl-verify-depth" class="headerlink" title="ssl_verify_depth"></a>ssl_verify_depth</h2><p>上面已经提到了，验证需要层层回溯，向上可以回溯多少次由ssl_verify_depth决定，当<code>ssl_verify_depth = 1</code>时，回溯层数为0，即任何中间证书都不会通过验证，除非是根证书。简而言之，中间证书的深度要小于ssl_verify_depth的值，才会验证通过。</p><p>在nginx中<code>ssl_verify_depth</code>的值默认是为1的。所以如果使用了中间证书，就需要适当调整这个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">句法：    ssl_verify_depth number;<br>默认：    ssl_verify_depth <span class="hljs-number">1</span>;<br>语境：    http， server<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SOCKET.IO最佳实践-代理篇</title>
    <link href="/2024/04/12/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/"/>
    <url>/2024/04/12/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在传统的轮询中，客户端定期向服务器发送请求，询问是否有新的数据可用。这会导致很多不必要的空请求，尤其是在没有新数据可用的时候。而且如果使用的是HTTP&#x2F;1.0版本，每个请求&#x2F;响应都需要打开一个新连接，考虑到连接的建立、关闭、TCP慢启动机制等因素，这是一个很大的开销。因此HTTP&#x2F;1.1引入了2个头部:Connection头部和Upgrade头部，用于协议升级。</p><p>其中Connection: keep-alive可以将HTTP短链接升级为长连接，这意味着在一个 TCP 连接上可以传输多个 HTTP 请求和响应，这样就减少大量请求建立、关闭等因素的开销，并且依靠这个机制，可以实现一种长轮询的模式，进一步减少空请求的损耗。需要注意的是，HTTP&#x2F;1.0也可以使用Connection: keep-alive，但是服务端并不一定支持，因此尽可能使用HTTP&#x2F;1.1版本，同时本文后续出现的HTTP，默认指的都是HTTP&#x2F;1.1。</p><p>同样，可以使用Connection: Upgrade与Upgrade: websocket将HTTP连接升级为websocket，具体可以参考本人另外一篇文章《浅析nginx实现websocket原理》。</p><h2 id="1、HTTP-长轮询："><a href="#1、HTTP-长轮询：" class="headerlink" title="1、HTTP 长轮询："></a>1、HTTP 长轮询：</h2><p>HTTP长轮询通过使用Connection: keep-alive实现服务端消息的“推送”。具体过程如下：</p><p>1.客户端发送一个HTTP请求到服务器，但服务器不立即响应。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">GET /socket<span class="hljs-selector-class">.io</span>/?EIO=<span class="hljs-number">4</span>&amp;transport=polling&amp;t=OtBbTrW HTTP/<span class="hljs-number">1.1</span><br>Cache-Control: no-cache<br>Connection: keep-alive<br>Host: <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3001</span><br>Pragma: no-cache<br></code></pre></td></tr></table></figure><p>2.服务器保持请求打开，等待有新的数据或事件发生。</p><p>3.一旦有新的数据或事件发生，服务器立即响应请求，将数据传输给客户端。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content</span>-Type: text/plain; charset=UTF-<span class="hljs-number">8</span><br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">118</span><br>cache-control: no-store<br>Date: Wed, <span class="hljs-number">21</span> Feb <span class="hljs-number">2024</span> <span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">32</span> GMT<br>Connection: keep-alive<br>Keep-Alive: timeout=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Keep-Alive: timeout&#x3D;5 表示服务器愿意在响应后保持连接打开，等待可能的进一步请求，而这个连接将在5秒钟后自动关闭，除非另外有新的请求。</p><p>4.客户端收到响应后，立即再次发起新的HTTP请求，重复上述过程。</p><p>相比于传统轮询，HTTP长轮询减少了不必要的空请求，因为服务器只在有新数据时才会响应。并且这种方式可以降低通信的延迟，因为服务器在有数据时立即将其传输给客户端，而不需要等到下一次定期轮询。</p><p>但是服务器必须维护大量的打开连接，这可能导致服务器资源的浪费。而且在某些情况下，中间代理（如代理服务器或防火墙）可能会中断长轮询连接，导致不稳定的通信。</p><p>所以对于服务端推送消息的场景，websocket是一种更好的方式，HTTP长轮询只是提供了一种在不支持WebSocket的环境中实现实时通信的方法。</p><h2 id="2、Socket-io"><a href="#2、Socket-io" class="headerlink" title="2、Socket.io"></a>2、Socket.io</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现低延迟, 双向和基于事件的通信。Socket.IO在普通的websocket上提供一些功能，如自动重新连接、广播、HTTP长轮询回退（无法与服务端建立websocket连接，将回退为HTTP长轮询）等功能。因此一个socket.io客户端和服务端的交互过程中，可能会同时存在HTTP长轮询与websocket协议的请求。在存在代理的链路中，不当的配置会导致通信失败，本文将着重分析在多级代理中，如何正确配置使得socket.io客户端与服务端正常通信。</p><h3 id="2-1、会话id"><a href="#2-1、会话id" class="headerlink" title="2.1、会话id"></a>2.1、会话id</h3><p>在 Socket.IO 中，每个客户端连接都会被分配一个唯一的标识符，通常被称为会话id，会话id在服务端会关联客户端的连接。所有后续HTTP请求的参数中必需携带这个值，这个标识符可以用于在服务器端跟踪和识别特定的客户端连接。</p><p>通过这种标识符，服务器可以维护一个连接池，用于管理和处理来自不同客户端的实时通信。这对于实现诸如广播消息、单播消息、断线重连等功能都非常有用。</p><p>在 Socket.IO 中，连接建立时会触发一个事件（通常是 <strong>connection</strong> 事件），服务器会分配一个唯一的 sid给客户端连接，一个HTTP长轮询请求如下图所示。</p><p><img src="/img/socket-%E5%9B%BE1.png" alt="socket-图1"></p><h3 id="2-2、socket-io集群"><a href="#2-2、socket-io集群" class="headerlink" title="2.2、socket.io集群"></a>2.2、socket.io集群</h3><p>Socket.IO客户端和服务端是靠会话id一一对应的，所以客户端请求到了错误的Socket.IO服务端时，就会报错，因为服务端识别不了。</p><p>因此，当socket.io为集群时，nginx做代理，如果负载策略是轮询，那么客户端和服务端会有概率不匹配。下图的场景，client-A的请求必须路由到第二个socket.io节点，因为nginx是轮询，因此每3笔会有一笔失败，在浏览器的现象就是，刷新2次界面后，系统恢复正常。</p><p>因此，需要在nginx开启会话保持，即ip_hash，这样一个客户端的ip会固定路由到一个Socket.IO服务端，这样就不会出现不匹配的问题。</p><p><img src="/img/socket-%E5%9B%BE2.png" alt="socket-图2"></p><h2 id="3、websocket"><a href="#3、websocket" class="headerlink" title="3、websocket"></a>3、websocket</h2><p>websocket很明显是优于HTTP长轮询的，只要维持一条长连接，就可以实现全双工通信，避免了频繁的建立连接。通常Socket.IO首先会发起HTTP长轮询请求，服务端会在响应中返回upgrades 数组，表示服务器支持更好的传输协议，如下所示。然后，socket.io客户端就会将协议升级为upgrades 数组中的一种。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;sid&quot;</span>: <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span>,<br>  <span class="hljs-string">&quot;upgrades&quot;</span>: [<span class="hljs-string">&quot;websocket&quot;</span>],<br>  <span class="hljs-string">&quot;pingInterval&quot;</span>: <span class="hljs-number">25000</span>,<br>  <span class="hljs-string">&quot;pingTimeout&quot;</span>: <span class="hljs-number">20000</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>sid 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</p></li><li><p>upgrades 数组包含服务器支持的所有“更好”传输的列表</p></li><li><p>pingInterval 和 pingTimeout 值用于心跳</p></li></ul><h3 id="3-1、socket-io升级websocket的过程"><a href="#3-1、socket-io升级websocket的过程" class="headerlink" title="3.1、socket.io升级websocket的过程"></a>3.1、socket.io升级websocket的过程</h3><p>1、 最开始客户端的请求</p><p><img src="/img/socket-%E5%9B%BE3.png" alt="socket-图3"></p><p>2、服务端响应</p><p><img src="/img/socket-%E5%9B%BE4.png" alt="socket-图4"></p><p>3、客户端发送请求建立websocket连接</p><p><img src="/img/socket-%E5%9B%BE5.png" alt="socket-图5"></p><p>其中请求头为</p><p><img src="/img/socket-%E5%9B%BE6.png" alt="socket-图6"></p><p>响应头为</p><p><img src="/img/socket-%E5%9B%BE7.png" alt="socket-图7"></p><p>4、心跳</p><p>心跳间隔为25s，与”pingInterval”: 25000是一致的</p><p><img src="/img/socket-%E5%9B%BE8.png" alt="socket-图8"></p><h3 id="3-2、此websocket非常规的websocket"><a href="#3-2、此websocket非常规的websocket" class="headerlink" title="3.2、此websocket非常规的websocket"></a>3.2、此websocket非常规的websocket</h3><p>Socket.IO 可以使用 WebSocket 协议，但它为每个数据包添加了额外的元数据。所以 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p><p>我们团队提供的wss组件，虽然支持了socket.io与普通的websocket，但是同一时刻也只能支持其中的一种，即使用socket.io的客户端和websocket客户端连接wss，总有一个会失败。</p><h2 id="4、代理"><a href="#4、代理" class="headerlink" title="4、代理"></a>4、代理</h2><p>由于会话id的存在，每个携带唯一会话id的HTTP请求都必须路由到对应的socket.io服务端，尤其是socket.io服务端为多节点时。本节着重讲解如何正确配置代理节点，使得socket.io客户端与服务端可以使用HTTP长轮询与websocket进行正常通信。</p><h3 id="1、socket-io为单节点"><a href="#1、socket-io为单节点" class="headerlink" title="1、socket.io为单节点"></a>1、socket.io为单节点</h3><ul><li>HTTP长轮询</li></ul><p>socket.io为单节点时，客户端和服务端肯定是对应的，所以不管中间代理怎么路由，都没有问题。</p><ul><li>websocket</li></ul><p>中间节点都需要升级HTTP协议为websocket，如果是四层负载，那就不需要做任何改动，websocket只针对<strong>七层负载。</strong></p><h3 id="2、socket-io多节点"><a href="#2、socket-io多节点" class="headerlink" title="2、socket.io多节点"></a>2、socket.io多节点</h3><h4 id="1、一级代理"><a href="#1、一级代理" class="headerlink" title="1、一级代理"></a>1、一级代理</h4><p>1、代理为单节点</p><p><img src="/img/socket-%E5%9B%BE9.png" alt="socket-图9"></p><ul><li>HTTP长轮询</li></ul><p>由于client使用session id和socket.io端一一对应，因此需要保证同一client的请求一直路由到同一socket.io服务端，否则会报400的错误（其他服务端识别不了未知的sid)。所以nginx需要配置会话保持，即ip_hash，其他负载均衡器类似。</p><p><img src="/img/socket-%E5%9B%BE10.png" alt="socket-图10"></p><ul><li>websocket</li></ul><p>如果nginx配置了协议升级，client到nginx、nginx到socket.io的连接都是websocket协议的连接，即长连接，nginx保证了client与服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE11.png" alt="socket-图11"></p><h4 id="2、多级代理"><a href="#2、多级代理" class="headerlink" title="2、多级代理"></a>2、多级代理</h4><h5 id="1、单-单"><a href="#1、单-单" class="headerlink" title="1、单-单"></a>1、单-单</h5><p>l HTTP长轮询</p><p>如果代理是单节点-单节点，如下图。为了保证客户端与服务端一一对应，那么需要在<strong>第二个nginx配置会话保持</strong>。</p><p><img src="/img/socket-%E5%9B%BE12.png" alt="socket-图12"></p><ul><li>Websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="2、单-多"><a href="#2、单-多" class="headerlink" title="2、单-多"></a>2、单-多</h5><ul><li>HTTP长轮询</li></ul><p>如果代理节点是单节点-多节点，为了保证客户端与服务端一一对应，那么需要<strong>多级nginx都需要配置会话保持</strong>。这时我们应该发现了一个规律，<strong>只要某个节点后面的节点是集群，那么当前节点就需要配置会话保持</strong>，这其实就是HTTP长轮询在多级代理场景下的核心</p><p><img src="/img/socket-%E5%9B%BE13.png" alt="socket-图13"></p><p>深度思考二个问题：</p><p>1、上图第一个nginx真的需要配置ip_hash吗？</p><p>2、下图，哪些nginx需要配置ip_hash?</p><p>答案将会放在第5节，如果你能回答正确，那么你就真正理解了如何代理长轮询</p><p><img src="/img/socket-%E5%9B%BE14.png" alt="socket-图14"></p><ul><li>websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="3、多-多"><a href="#3、多-多" class="headerlink" title="3、多-多"></a>3、多-多</h5><p>这种场景和单-多的场景没有任何区别，因为集群前面肯定有一个单节点的负载均衡器做负载，本质也是单-多。有些人可能好奇，双活难道不是每个节点都是集群吗，整条链路如果存在单节点，这个单节点挂掉之后，整条链路随之挂掉，事实上就是这样的，所以在负载的最前面，都是用DNS做分发。</p><h5 id="4、多-单"><a href="#4、多-单" class="headerlink" title="4、多-单"></a>4、多-单</h5><p>同上，本质和单-多没有区别</p><h4 id="3、HTTP长轮询与websocket同时存在"><a href="#3、HTTP长轮询与websocket同时存在" class="headerlink" title="3、HTTP长轮询与websocket同时存在"></a>3、HTTP长轮询与websocket同时存在</h4><p>Socket.io的机制会同时存在HTTP长轮询与websocket协议的请求，所以代理节点需要<strong>同时配置会话保持与协议升级的配置</strong>。</p><h2 id="5、问题解答"><a href="#5、问题解答" class="headerlink" title="5、问题解答"></a>5、问题解答</h2><p>1、首先回答第4节的2个问题</p><p>1、第一个nginx真的需要配置ip_hash吗？</p><p>ip_hash是将某一ip的客户端，固定路由到后台的某一台服务器。所以假设client-A、client-B与某个socket.io建立了会话,，那么后续请求也需要一一对应，我们可以推测nginx-M是否设置ip_hash的路由场景</p><ul><li>nginx-M设置了ip_hash</li></ul><p>因为client-A与client-B的ip不一样，nginx-M又设置了ip_hash，所以client-A的请求都会走到nginx-A（这是假设，事实上不走A，就会走B，这里假设走A），client-B的请求都会走到nginx-B。重点来了，<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端（ip_hash的算法决定），假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong></p><ul><li>nginx-M没有设置ip_hash</li></ul><p>如果nginx-M没有设置ip_hash，client的请求，nginx-M会轮询分发到ngina-A和nginx-B，但是由于<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端，假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong>，我们发现和上面一模一样，所以结论是nginx-M是不需要设置ip_hash的。</p><p><img src="/img/socket-%E5%9B%BE15.png" alt="socket-图15"></p><p>2、哪些nginx需要配置ip_hash?</p><p>2个问题的本质是一样的，事实上，只要nginx-M、nginx-C、nginx-D设置了ip_hash就可以保证客户端和服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE16.png" alt="socket-图16"></p><p>2、结论</p><p>其实为了简单化问题，我们可以对每个nginx都设置ip_hash，但是需要注意的是，总会有一层的集群变成了”单点”，有节点总是处于空闲状态!，导致集群变成了单点</p><h2 id="6、socket-io集群同步"><a href="#6、socket-io集群同步" class="headerlink" title="6、socket.io集群同步"></a>6、socket.io集群同步</h2><p>试想，如果socket.io集群间能同步数据，那么是不是客户端可以随意对应哪个socket.io了？</p><p>答案是的</p><p>由于客户端可能连接到集群中不同的节点，为了在集群中不同的节点之间传递消息，socket.io官方以redis的发布订阅功能为基础做了消息路由分发：<strong>socket.io-redis</strong>。<strong>socket.io-redis</strong>在节点向客户端群发消息时会将该消息发布到redis的订阅队列中，让其他节点能够订阅到该消息，从而实现节点间消息推送。不过这有额外的开发工作量，目前来看，公司内部的socket.io并没有做集群的数据共享</p><h2 id="7、sticky-哈希-一致性哈希"><a href="#7、sticky-哈希-一致性哈希" class="headerlink" title="7、sticky&amp;&amp;哈希 &amp;&amp; 一致性哈希"></a>7、sticky&amp;&amp;哈希 &amp;&amp; 一致性哈希</h2><h3 id="1、不能使用ip-hash，要使用hash"><a href="#1、不能使用ip-hash，要使用hash" class="headerlink" title="1、不能使用ip_hash，要使用hash"></a>1、不能使用ip_hash，要使用hash</h3><p>nginx的ngx_http_upstream_ip_hash_module.c包含了具体hash负载策略的实现，在另外一篇文章会分析nginx的几大负载策略，这里简要概括一下，nginx会使用r-&gt;connection的地址，即取上一个节点的ip进行负载，也就是第5节说的问题，多级代理下，会导致集群退化成单节点。</p><p>同时nginx提供了hash，因此需要使用hash，而不是ip_hash，且要这么配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">upstream myapp &#123;<br>        hash $http_x_real_ip;  # 使用 X-Real-IP 头部的值进行哈希<br>        server backend1.example.com weight=<span class="hljs-number">1</span>;<br>        server backend2.example.com weight=<span class="hljs-number">2</span>;<br>    &#125;<br><br><span class="hljs-comment">//或者</span><br><br>upstream myapp &#123;<br>        hash $http_x_forwarded_for;  # 使用 $http_x_forwarded_for 头部的值进行哈希<br>        server backend1.example.com weight=<span class="hljs-number">1</span>;<br>        server backend2.example.com weight=<span class="hljs-number">2</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">//ingress-nginx<br>nginx<span class="hljs-selector-class">.ingress</span><span class="hljs-selector-class">.kubernetes</span><span class="hljs-selector-class">.io</span>/upstream-hash-by: <span class="hljs-string">&quot;$http_x_forwarded_for&quot;</span><br></code></pre></td></tr></table></figure><p><strong>如果使用$http_x_forwarded_for，会将第一个地址进行哈希，还是所有地址呢？</strong></p><p>这里先来理解一下X-Forwarded-For，X-Forwarded-For包含了经过的所有代理服务器的IP地址。同样在多级代理下，每级代理（包括最初始的客户端）都需要传递X-Forwarded-For头部，并添加自身的ip .X-Forwarded-For头部的值由多个IP地址组成，以逗号分隔。例如，如果请求经过了三个代理服务器，则X-Forwarded-For头部的值为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">X-Forwarded-For: client_ip, proxy1_ip, proxy2_ip<br></code></pre></td></tr></table></figure><p>其中，client_ip代表客户端的真实IP地址，proxy1_ip和proxy2_ip分别代表两个中间代理服务器的IP地址。</p><p>从逻辑来讲来看，应该取第一个地址，因为如果在多级代理下，比如client -&gt;  F5  -&gt; (A&#x2F;B)  -&gt;server，同一个client可能会走A或者B，这就会导致hash值发生变化。简单搭个环境，打开debug测试一下，<strong>hash模块用的确实是真实客户端ip，也就是第一个ip</strong>，这样就是没有问题的。</p><p><img src="/img/socket-%E5%9B%BE17.png" alt="socket-图17"></p><p>​有意思的是，如果客户端后的第一个节点没有获取到client_ip，第二个节点获取到了第一个节点的ip，就会导致X-Forwarded-For的client_ip始终是客户端后第一个节点的ip，ip固定了，hash直接就无效了，因为不管客户端再怎么变化，client_ip始终是第一个代理节点。所以要保证整个链路支持X-Forwarded-For。</p><p>事实证明，生产根本不是这样的，尤其是你的客户用了各种各样的负载均衡器，7层还好一般都支持，4层就够呛了（第一层代理节点要从tcp连接获取客户端的ip），如果客户买了F5，就一定会配置，或者愿意配置吗？</p><p>对比一下几种算法</p><table><thead><tr><th>功能&#x2F;支持</th><th>使用真实客户端ip进行ip_hash</th><th>一致性哈希</th></tr></thead><tbody><tr><td>ip_hash</td><td>否</td><td>否</td></tr><tr><td>hash</td><td>是</td><td>是</td></tr><tr><td>sticky</td><td>否，使用cookie的router值路由</td><td>否</td></tr></tbody></table><p>1、使用不同的算法会有什么问题？</p><p>1、使用ip_hash代理，退化成单节点</p><p>如果停掉在用的，当前会话直接挂掉，nginx会重新选取一个节点。根据socket.io的特性，会出现报错，停掉空闲节点，不会有影响。</p><p>另外补充一个点，如果   client  –   nginx   –   后端服务，这种模式下，nginx开启ip_hash后，如果停掉一个节点，nginx会重新计算权值，这个值影响最终请求被路由到哪台机器，也就是粘性会话失效了。</p><p>也就是ip_hash的2个缺点，<strong>集群退化单节点</strong>与<strong>不支持一致性哈希</strong></p><p>2、使用hash</p><p>首先肯定是使用真实客户端ip进行hash路由，这样可以避免使后端集群退化成单节点</p><p>而且现在因为后端服务是多节点，停止掉一个节点后，数据项的hash值会发生变化，客户端的请求会路由到其他的节点，且这个服务的数据丢失。</p><p>但是使用一致性哈希后，数据会同步到顺时针的下一个节点，整个集群不会因为增删节点，影响对外提供功能</p><p>以ingress-nginx举例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nginx<span class="hljs-selector-class">.ingress</span><span class="hljs-selector-class">.kubernetes</span><span class="hljs-selector-class">.io</span>/upstream-hash-by: <span class="hljs-string">&quot;$http_x_forwarded_for&quot;</span><br></code></pre></td></tr></table></figure><h2 id="8、实际问题"><a href="#8、实际问题" class="headerlink" title="8、实际问题"></a>8、实际问题</h2><h3 id="1、实际问题-1"><a href="#1、实际问题-1" class="headerlink" title="1、实际问题 1"></a>1、实际问题 1</h3><p>1、业务背景</p><p>某系统使用socket.io做数据推送，架构如下图，打开F12，这个前端同时存在polling和websocket的请求，有了上面的经验，这个很容易，我们在Nginx，针对socket.io的请求，配置<strong>会话保持</strong>和<strong>websocket升级</strong>的配置就可以，但是有问题，这主要是业务的使用方式。</p><p><img src="/img/socket-%E5%9B%BE18.png" alt="socket-图18"></p><p>2、 业务的使用</p><p>1、client首先会发送一个post请求，告知后台微服务，客户端想获取什么数据。</p><p>2、服务端组装好数据后，通过Socket.io将就绪的通知，通过websocket的请求推送到客户端。</p><p>3、客户端接收到数据就绪的通知后，再次发送一个get请求，下载数据 。</p><p>业务只是对socket.io的请求配置了ip_hash，那么试想，</p><p>1、如果客户端的websocket请求是和第一个Socket.io服务端建立的</p><p>2、post请求没有配置ip_hash，所以是轮询负载的，每2笔会有一笔发给了第二个Socket.io。</p><p>3、第二个Socket.io服务端收到了前端的请求，但是它没法通知客户端数据已经准备好了，因为没有websocket的连接，所以客户端一直不会发起下载的请求。</p><p>4、请求卡住了，导致整个系统卡住了</p><p>所以将这2个请求也配置为ip_hash，事实证明，问题解决。</p><p>3、 提问环节</p><p>本文一直没有提七层负载和四层负载的区别，刚好这里有个四层负载，那么有2个问题需要留给读者</p><p>1、上图的四层负载没有做任何改动，如果换成七层负载，需要加什么配置？</p><p>提示：对于polling的请求，上图的负载均衡器是四层和七层其实没区别（只限于这种架构，其他架构可能会有区别，具体问题具体分析），那么我们需要考虑的就是websocket协议了，可以参考另外一篇文章，《浅析nginx实现websocket原理》</p><p>2、哪个集群退化成了单点？</p><h3 id="2、实际问题-2"><a href="#2、实际问题-2" class="headerlink" title="2、实际问题 2"></a>2、实际问题 2</h3><p>为了建立一个WebSocket连接，客户端需要建立一个tcp连接并且发送一个握手协议。连接最初状态为CONNECTING，但是客户端最多有一条连接可以处于CONNECTING状态。如果多个连接尝试同时与一个相同的IP地址建立连接，客户端必须把他们进行排序。如果是web端，Chrome浏览器最多允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别。</p><p>因此某客户遇到了一个问题，使用的socket.io服务总是连接不成功，且浏览器会直接卡死，严重影响业务的正常运转。排查问题是要讲究步骤的，因此</p><p>1、首先，查看了现场的现象，发现浏览器卡死，且发送了很多socket.io的请求，刚好是6条，但是请求一直处于pending状态。</p><p>2、然后，确认了现场的架构拓扑，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">client -&gt;  F5  -&gt;  Nginx（集群） -&gt;  socket.io（集群）<br></code></pre></td></tr></table></figure><p>3、确认了F5的负载模式是7层负载，且没有配置websocket协议升级，Nginx倒是配置了会话保持（现场的实施根据部署文档进行配置），但是配置还存在问题。</p><p>4、如果确认了上面的信息，那么我们可以清晰的发现，问题解决很简单。先来解答一下异常现象</p><ul><li>为什么请求处于pengding状态？</li></ul><p>因为F5使用了7层负载，但是没有配置websocket协议升级，而客户端是同时存在polling和websocket请求的，所以客户端和F5之间的websocket请求一直是建立失败的，只是建立了HTTP1.1的连接，虽然也是长连接，但是属于HTTP，数据的传输格式不一样，报错是肯定的。但是先不要着急，现在还没到这个报错的时候，HTTP的请求如果一直没有响应，那么就是pengding的状态，所以这就是为什么请求都处于pengding的状态。</p><ul><li>浏览器为什么会卡死？</li></ul><p>如果websocket的连接建立不成功，它会一直重复发，直到浏览器的上限，6条tcp连接。</p><p>5、这个架构其实我们已经很熟了，上面也有例子，F5配置websocket协议升级，HSIAR配置会话保持+websocket协议升级即可，但是F5支不支持websocket呢？有版本限制，且配置比较复杂，客户不想研究，那么直接将7层负载变为4层负载，这样问题就解决了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>websocket</tag>
      
      <tag>socket.io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openresty---lua调用c原理分析</title>
    <link href="/2024/04/12/openresty---lua%E8%B0%83%E7%94%A8c%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/12/openresty---lua%E8%B0%83%E7%94%A8c%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="openresty—lua调用c模块原理分析"><a href="#openresty—lua调用c模块原理分析" class="headerlink" title="openresty—lua调用c模块原理分析"></a>openresty—lua调用c模块原理分析</h1><h2 id="1、lua基础"><a href="#1、lua基础" class="headerlink" title="1、lua基础"></a>1、lua基础</h2><h3 id="1、lua虚拟机"><a href="#1、lua虚拟机" class="headerlink" title="1、lua虚拟机"></a>1、lua虚拟机</h3><p><code>lua</code>是解释型语言，需要虚拟机对象。不同的<code>lua</code>虚拟机之间的工作是线程安全的，因为一切和虚拟机相关的内存操作都被关联到虚拟机对象中，而没有利用任何其它共享变量。<code>lua</code>的虚拟机核心部分，没有任何的系统调用，是一个纯粹的黑盒子，正确的使用<code>lua</code>，不会对系统造成任何干扰。这其中最关键的一点是，<code>lua</code>让用户自行定义内存管理器，在创建<code>lua</code>虚拟机时传入，这保证了<code>lua</code>的整个运行状态是用户可控的。</p><h3 id="2、状态机"><a href="#2、状态机" class="headerlink" title="2、状态机"></a>2、状态机</h3><p><code>global_State</code>：全局状态机</p><p><code>lua_State</code>：协程状态机</p><p>从<code>lua</code>的使用者的角度看，<code>global_State</code>是不可见的。我们无法用公开的API取到它的指针，也不需要引用它。<code>global_State</code>里面有对主线程的引用，有注册表管理所有全局数据，有全局字符串表，有内存管理函数，有<code>GC</code>需要的把所有对象串联起来的相关信息，以及一切<code>lua</code>在工作时需要的工作内存。<br>通过<code>lua_newstate</code>创建一个新的<code>lua</code>虚拟机时，第一块申请的内存将用来保存主线程和这个全局状态机。<code>lua</code>的实现尽可能的避免内存碎片，同时也减少内存分配和释放的次数。它采用了一个小技巧，利用一个<code>LG</code>结构，把主线程<code>lua_State</code>和<code>global_State</code>分配在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LX</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined ( luaI_EXTRASPACE )</span><br><span class="hljs-type">char</span> buff [ luaI_EXTRASPACE ];<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>lua_State l;<br>&#125; LX;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LG</span> &#123;</span><br>LX l;<br>global_State g;<br>&#125; LG;<br></code></pre></td></tr></table></figure><p><code>lua_newstate</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_API lua_State * <span class="hljs-title function_">lua_newstate</span> <span class="hljs-params">( lua_Alloc f, <span class="hljs-type">void</span> *ud)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    lua_State *L;    <span class="hljs-comment">//创建一个主线程状态机</span><br>    global_State *g; <span class="hljs-comment">//创建一个全局状态机</span><br>    LG *l = cast (LG *, (*f)(ud , <span class="hljs-literal">NULL</span> , lua_TTHREAD , <span class="hljs-keyword">sizeof</span> (LG)));  <span class="hljs-comment">//申请内存</span><br>    ................................................................................<br><span class="hljs-keyword">return</span> L; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、version"><a href="#3、version" class="headerlink" title="3、version"></a>3、version</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">luaL_checkversion</span> <span class="hljs-params">(lua_State *L)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_API <span class="hljs-type">const</span> lua_Number * <span class="hljs-title function_">lua_version</span> <span class="hljs-params">( lua_State *L)</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> lua_Number version = lua_VERSION_NUM ;<br><span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> ) <span class="hljs-keyword">return</span> &amp; version ;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> G(L) -&gt; version ;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查调用它的内核是否是创建这个 <code>lua</code> 状态机的内核。以及调用它的代码是否使用了相同的 <code>lua</code> 版本。同时也检查调用它的内核与创建该 <code>lua</code> 状态机的内核是否使用了同一片地址空间。</p><ol><li><strong>检查调用它的内核是否是创建这个 <code>lua</code> 状态机的内核</strong>：假设你正在编写一个 <code>lua</code> 插件，这个插件将被加载到不同的 <code>lua</code> 程序中。这些程序可能使用了不同版本的 <code>lua</code> 内核。在这种情况下，你的插件需要确保它能在所有这些程序中正常工作。你可以在插件的初始化代码中调用 <code>luaL_checkversion</code> 来确保插件被加载的 <code>lua</code> 程序使用的是和插件编译时相同版本的 <code>lua</code> 内核。</li><li><strong>调用它的代码是否使用了相同的 <code>lua</code> 版本</strong>：假设你正在维护一个 <code>lua</code> 库，这个库被不同的项目使用，而这些项目可能使用了不同版本的<code>lua</code>。在这种情况下，你需要确保你的库在所有这些项目中都能正常工作。你可以在库的初始化代码中调用 <code>luaL_checkversion</code> 来确保使用库的项目使用的是和库编译时相同版本的 <code>lua</code>。</li><li><strong>检查调用它的内核与创建该 lua 状态机的内核是否使用了同一片地址空间</strong>：这通常发生在你的 <code>lua</code> 代码需要和其他语言（如 <code>C</code> 或 <code>C++</code>）的代码交互时。例如，你的 <code>lua</code> 代码调用了一个 <code>C</code> 函数，这个 <code>C</code> 函数创建了一个新的 <code>lua</code> 状态机，并尝试在这个新的状态机上执行一些 <code>lua</code> 代码。在这种情况下，你需要确保这个新的状态机和原来的状态机在同一片地址空间，否则可能会导致内存错误。你可以在 C 函数中调用 <code>luaL_checkversion</code> 来进行这个检查。</li></ol><h3 id="4、元表"><a href="#4、元表" class="headerlink" title="4、元表"></a>4、元表</h3><p><code>lua</code>语言的元表类似于<code>c++</code>的类与对象，c++的每个类都可以绑定成员函数、成员变量，还可以对成员方法进行重载等等，通过实例化一个对象，可以对对象进行一系列的操作。c++是面向对象的语言，当有一个函数需要共用，又不想对类进行继承，可以使用static关键字，定义为一个全局的函数。从这些外在表现的方面看，c++和lua其实很像，但是显然lua更加轻量</p><p>lua 中的每一个值都可以绑定一个元表。这个元表是一个普通的table，它可以定义与该值相关的某些操作。你可以通过设置元表中特定域的值来改变Lua 值的行为。比如当一个非数字型的值作为加法操作的操作数时，Lua 会检查该值是否绑定了元表并且元表设置了域“__add”的值为一个函数，如果是，那么Lua 就会调用这个函数来进行该值的加法操作。</p><p>每个table 和full userdata 类型的值都可以有自己单独的元表（但多个table 和userdata可以共享一个元表）。其它的每一种类型对应地只能绑定一个元表。也就是说，<strong>所有的数字类型只能绑定同一个元表</strong>，<strong>所有的字符串类型只能绑定同一个元表</strong>，等等。除了字符串类型的值默认有一个元表外，其它的值默认是没有元表的。</p><p>一个元表控制了一个对象的算术、比较、连接，取长度操作和索引操作的行为。原理可以去看《lua官方文档》，这里主要关注2个有意思的元方法，索引和赋值</p><ul><li><p>index:索引操作。当使用一个不存于table 中的键去索引table 中的内容时会尝试调用此元方法。（当索引操作作用于的对象不是一个table 时，那么所有键都是不存在的，所以元方法一定会被尝试调用。）</p></li><li><p>newindex: table 赋值操作table[key] &#x3D; value。使用一个不存在于table 中的键来给table 中的域赋值时会尝试调用此元方法。</p></li></ul><p><code>index：</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gettable_event</span> <span class="hljs-params">(table, key)</span></span><br><span class="hljs-keyword">local</span> h<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">table</span>) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> v = <span class="hljs-built_in">rawget</span>(<span class="hljs-built_in">table</span>, key)<br><span class="hljs-comment">-- 如果键存在，返回原始的值</span><br><span class="hljs-keyword">if</span> v ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> v <span class="hljs-keyword">end</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__index</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__index</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(···)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(h) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> (h(<span class="hljs-built_in">table</span>, key)) <span class="hljs-comment">-- 调用元方法</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> h[key] <span class="hljs-comment">-- 或者把元方法当作一个table 来使用</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>newindex：</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">settable_event</span> <span class="hljs-params">(table, key, value)</span></span><br><span class="hljs-keyword">local</span> h<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">table</span>) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> v = <span class="hljs-built_in">rawget</span>(<span class="hljs-built_in">table</span>, key)<br><span class="hljs-comment">-- 如果键存在，那就做原始赋值</span><br><span class="hljs-keyword">if</span> v ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">rawset</span>(<span class="hljs-built_in">table</span>, key, value); <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__newindex</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">rawset</span>(<span class="hljs-built_in">table</span>, key, value); <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__newindex</span><br>    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(···)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(h) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">then</span><br>h(<span class="hljs-built_in">table</span>, key,value) <span class="hljs-comment">-- 调用元方法</span><br><span class="hljs-keyword">else</span> h[key] = value   <span class="hljs-comment">--或者把元方法当作一个table 来使用</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="2、请求与lua-state的关系"><a href="#2、请求与lua-state的关系" class="headerlink" title="2、请求与lua_state的关系"></a>2、请求与lua_state的关系</h2><h3 id="1、lua-State是什么"><a href="#1、lua-State是什么" class="headerlink" title="1、lua_State是什么"></a>1、lua_State是什么</h3><p>在 <code>lua</code> 中，<code>lua_State</code> 是一个代表 lua 解释器状态的结构体指针，它包含了 lua 解释器的所有状态信息，例如当前的全局环境、栈状态等。可以把<code>lua_State</code> 理解为 lua 的一个线程或者执行环境。</p><p>在 lua 中，每个线程都有自己的独立的执行栈，局部变量，错误处理函数等。这些都被封装在 <code>lua_State</code> 结构体中。当在 lua 中创建一个新的线程（或者协程）时，lua 会为这个线程创建一个新的 <code>lua_State</code>。这个 <code>lua_State</code> 包含了这个线程的所有状态信息，使得这个线程可以独立于其他线程运行。这是 lua 中线程和协程实现的基础，也是 lua 能够支持并发编程的关键。</p><h3 id="2、openresty的协程"><a href="#2、openresty的协程" class="headerlink" title="2、openresty的协程"></a>2、openresty的协程</h3><p>lua 的协程（<code>coroutine</code>）是一种用户级的线程，它们不同于操作系统的线程，切换由程序自身控制，因此开销小，使用灵活。</p><p>在 OpenResty 中，lua 协程用于实现非阻塞 I&#x2F;O。当一个请求需要进行 I&#x2F;O 操作（如访问数据库）时，当前的 lua 协程会挂起，将控制权交给其他的协程。等到 I&#x2F;O 操作完成后，原来的协程再恢复执行。这样，即使 I&#x2F;O 操作是阻塞的，也不会影响到整个程序的执行。</p><h3 id="3、请求与协程的关系"><a href="#3、请求与协程的关系" class="headerlink" title="3、请求与协程的关系"></a>3、请求与协程的关系</h3><p>在 OpenResty 中，每个 worker 进程使用一个 lua VM（lua 虚拟机），并创建一个新的 <code>lua_State</code>（即主线程）来执行 lua 代码。当请求被分配到 worker 时，将在这个 lua VM 中创建一个协程，协程之间数据隔离，每个协程都具有独立的全局变量。</p><p>具体来讲，对于每个请求，Openresty都会创建一个协程来处理，<code>co = ngx_http_lua_new_thread(r, L, &amp;co_ref);</code> 而这个创建的协程是系统协程，是主协程，用户无法控制它。而用户通过<code>ngx.thread.spawn</code>创建的协程是通过 <code>ngx_http_lua_coroutine_create_helper</code>创建出来的，用户创建的协程是主协程的子协程。并通过<code>ngx_http_lua_co_ctx_s</code>保存协程的相关信息。协程通过 <code>ngx_http_lua_run_thread</code> 函数来运行与调度，当前待执行的协程为 <code>ngx_http_lua_ctx_t-&gt;cur_co_ctx</code> 。</p><p>当 lua 代码调用 I&#x2F;O 操作等异步接口时，<code>ngx_lua</code> 会挂起当前协程（并保护上下文数据），而不阻塞 worker 进程]。I&#x2F;O 等异步操作完成时，<code>ngx_lua</code> 会恢复上下文，程序继续执行。这些操作对用户程序都是透明的，使得每个请求都在一个独立的 lua 线程中处理，各个请求之间互不影响，可以并发处理大量的请求，从而提高了系统的吞吐量。</p><h2 id="3、源码分析"><a href="#3、源码分析" class="headerlink" title="3、源码分析"></a>3、源码分析</h2><h3 id="1、lua与c模块的交互"><a href="#1、lua与c模块的交互" class="headerlink" title="1、lua与c模块的交互"></a>1、lua与c模块的交互</h3><p>1、预加载的注册方式，通常自己实现一个模块，采用这种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_lua_add_package_preload<br><br>    <br><span class="hljs-comment">//在OpenResty（基于Nginx的扩展）中，ngx_http_lua_add_package_preload 是一个用于预加载 lua 模块的函数。这个函数的主要作用是将 lua 模块预加载到 Nginx 工作进程的全局环境中，从而避免在每次请求时重新加载 lua 模块。</span><br><span class="hljs-comment">//具体而言，ngx_http_lua_add_package_preload 用于将 lua 模块与一个预定义的路径关联，以便在需要时可以快速地加载。这对于提高性能和减少模块加载时间非常有用，特别是在处理大量并发请求时。</span><br><span class="hljs-comment">//原型如下：</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_http_lua_add_package_preload</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *package, lua_CFunction func)</span>;<br><br><span class="hljs-comment">//cf: ngx_conf_t 结构，用于获取配置信息。</span><br><span class="hljs-comment">//package: lua 模块的名称，通常是点分隔的路径，例如 &quot;resty.foo&quot;。</span><br><span class="hljs-comment">//func: 一个 lua C 函数，用于加载并返回 lua 模块。这个函数在第一次加载模块时被调用，并且加载成功后，其返回值会被缓存，以便后续请求可以直接使用。</span><br></code></pre></td></tr></table></figure><p>如 <code>ngx_http_lua_upstream_module</code> 模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_upstream_init</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ngx_http_lua_add_package_preload(cf, <span class="hljs-string">&quot;ngx.upstream&quot;</span>,<br>                                         ngx_http_lua_upstream_create_module)<br>        != NGX_OK)<br>    &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>ngx_http_lua_add_package_preload</code>具体实现为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_add_package_preload</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *package,</span><br><span class="hljs-params">    lua_CFunction func)</span><br>&#123;<br>    lua_State                     *L;<br>    <span class="hljs-type">ngx_http_lua_main_conf_t</span>      *lmcf;<br>    <span class="hljs-type">ngx_http_lua_preload_hook_t</span>   *hook;<br><br>    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);<br><br>    L = lmcf-&gt;lua;<br>    <br><span class="hljs-comment">//lua_getglobal(L, &quot;package&quot;): 获取全局变量 &quot;package&quot;。</span><br><span class="hljs-comment">//lua_getfield(L, -1, &quot;preload&quot;): 获取 &quot;package&quot; 表中的 &quot;preload&quot; 字段，这是一个用于存放预加载函数的表。</span><br><span class="hljs-comment">//lua_pushcfunction(L, func): 将 C 函数推入 lua 栈。</span><br><span class="hljs-comment">//lua_setfield(L, -2, package): 将 C 函数设置为 &quot;preload&quot; 表中的字段，字段名为 lua 模块的名称。</span><br><span class="hljs-comment">//lua_pop(L, 2): 弹出栈上的两个元素，即 &quot;package&quot; 表和 &quot;preload&quot; 表。</span><br><br><span class="hljs-comment">//很重要！！！！！*******//相当于建立了一个ngx.upstream的表，里面preload存放对应的函数----ngx_http_lua_upstream_module</span><br><br><br>    <span class="hljs-keyword">if</span> (L) &#123;<br>        lua_getglobal(L, <span class="hljs-string">&quot;package&quot;</span>);<br>        lua_getfield(L, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;preload&quot;</span>);<br>        lua_pushcfunction(L, func);<br>        lua_setfield(L, <span class="hljs-number">-2</span>, package);<br>        lua_pop(L, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we always register preload_hooks since we always create new Lua VMs</span><br><span class="hljs-comment">     * when lua code cache is off. */</span><br><br>    <span class="hljs-keyword">if</span> (lmcf-&gt;preload_hooks == <span class="hljs-literal">NULL</span>) &#123;<br>        lmcf-&gt;preload_hooks =<br>            ngx_array_create(cf-&gt;pool, <span class="hljs-number">4</span>,<br>                             <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_http_lua_preload_hook_t</span>));<br><br>        <span class="hljs-keyword">if</span> (lmcf-&gt;preload_hooks == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    hook = ngx_array_push(lmcf-&gt;preload_hooks);<br>    <span class="hljs-keyword">if</span> (hook == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    hook-&gt;package = (u_char *) package;<br>    hook-&gt;loader = func;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ngx_http_lua_upstream_create_module</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">ngx_http_lua_upstream_create_module</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_upstreams);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_upstreams&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_servers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_servers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_primary_peers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_primary_peers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_backup_peers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_backup_peers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_set_peer_down);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;set_peer_down&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_current_upstream_name);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;current_upstream_name&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、非预加载的注册方式，openresty官方内置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span>  <span class="hljs-title function_">ngx_http_lua_inject_xxx_api</span><span class="hljs-params">(lua_State *L)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>如：<code>ngx_http_lua_inject_resp_header_api</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_lua_inject_resp_header_api</span><span class="hljs-params">(lua_State *L)</span><br>&#123;   <span class="hljs-comment">//创建一个新的lua表，并将其推入lua堆栈。这个表将用于存储HTTP响应头的键值对</span><br>    lua_newtable(L);    <span class="hljs-comment">/* .header */</span><br>    <span class="hljs-comment">//创建一个新的lua表，并设置它的元表。元表是一个普通的lua表，它定义了一些特殊的操作，比如当在表中查找一个不存在的键时，会通过元表的__index元方法来获取值。在这里，我们为.header表创建了一个元表。</span><br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">/* metatable for .header */</span><br>    <br>    <span class="hljs-comment">//将C函数ngx_http_lua_ngx_header_get推入堆栈，并将它作为值与键__index关联起来。这样，当在.header表中查找一个不存在的键时，将会调用ngx_http_lua_ngx_header_get函数来获取相应的值。</span><br>    lua_pushcfunction(L, ngx_http_lua_ngx_header_get);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__index&quot;</span>);<br>    <br>    <span class="hljs-comment">//将C函数ngx_http_lua_ngx_header_set推入堆栈，并将它作为值与键__newindex关联起来。这样，当在.header表中设置一个不存在的键时，将会调用ngx_http_lua_ngx_header_set函数来设置相应的值。</span><br>    lua_pushcfunction(L, ngx_http_lua_ngx_header_set);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    <br>    <span class="hljs-comment">//将刚刚创建的元表设置为.header表的元表，从而实现了对HTTP响应头的读写操作。</span><br>    lua_setmetatable(L, <span class="hljs-number">-2</span>);<br>    <br>    <span class="hljs-comment">//将.header表保存在全局环境中，命名为header，这样在lua脚本中可以通过ngx.header来访问和操作HTTP响应头。</span><br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;header&quot;</span>);<br><br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">/* .resp */</span><br><br>    lua_pushcfunction(L, ngx_http_lua_ngx_resp_get_headers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_headers&quot;</span>);<br>    <br>    <span class="hljs-comment">//ngx.resp</span><br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;resp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>openresty在nginx的配置阶段统一注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_lua_inject_ngx_api</span><span class="hljs-params">(lua_State *L, <span class="hljs-type">ngx_http_lua_main_conf_t</span> *lmcf,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>)</span><br>&#123;<br>    lua_createtable(L, <span class="hljs-number">0</span> <span class="hljs-comment">/* narr */</span>, <span class="hljs-number">115</span> <span class="hljs-comment">/* nrec */</span>);    <span class="hljs-comment">/* ngx.* */</span><br><br>    lua_pushcfunction(L, ngx_http_lua_get_raw_phase_context);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;_phase_ctx&quot;</span>);<br><br>    ngx_http_lua_inject_arg_api(L);<br><br>    ngx_http_lua_inject_http_consts(L);<br>    ngx_http_lua_inject_core_consts(L);<br><br>    ngx_http_lua_inject_resp_header_api(L);   <span class="hljs-comment">//注册到线程中</span><br>    <br>    .......................................<br></code></pre></td></tr></table></figure><p>将lua与c代码关联起来，这样就可以在lua中调用ngx.header，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local cookie = &#123;&#125;<br>ngx.header[<span class="hljs-string">&quot;Set-cookie&quot;</span>] = cookie<br></code></pre></td></tr></table></figure><p>3、关于__index</p><p>当尝试从表中获取不存在的值时，那么就会调用  <code>ngx_http_lua_ngx_header_get</code></p><p>在lua中，<code>__index</code> 是一种特殊的元方法（metamethod），用于表的访问控制。当你尝试从一个表中获取一个不存在的键时，lua会在表的元表中查找是否定义了<code>__index</code>元方法。如果找到了<code>__index</code>元方法，lua会调用它，并将表本身和要访问的键作为参数传递给该元方法。</p><p>在这段代码中，我们创建了一个名为 <code>.header</code> 的新表，并为该表创建了一个元表。然后，我们通过 <code>lua_setfield(L, -2, &quot;__index&quot;)</code> 将名为 <code>__index</code> 的 C 函数（<code>ngx_http_lua_ngx_header_get</code>）与该元表中的 <code>__index</code> 键关联起来。这样，当在 <code>.header</code> 表中查找一个不存在的键时，lua 就会调用 <code>ngx_http_lua_ngx_header_get</code> 函数来获取相应的值。</p><p>换句话说，这个代码片段通过设置 <code>__index</code> 元方法，为 <code>.header</code> 表提供了一种自定义的行为：当访问 <code>.header</code> 表中不存在的键时，会调用 <code>ngx_http_lua_ngx_header_get</code> 函数进行处理。这在某种程度上实现了对 <code>.header</code> 表的动态访问控制。</p><h3 id="2、协程"><a href="#2、协程" class="headerlink" title="2、协程"></a>2、协程</h3><ol><li>nginx master初始化时，会创建一个lua_state，并初始化一个cached_lua_threads。      </li><li>master在fork   work时，每个work会拥有各自的lua_state，即主协程</li><li>主协程会维护cached_lua_threads，存放这个work（也就是这个lua_state主协程）创建出的所有协程，可以重复使用。 </li><li>当有请求时，先检查         请求是否在这个虚拟机处理   &amp;&amp;  协程队列是否为空 。    </li><li>如果满足条件，那么从队列取一个协程，绑定该请求的上下文    </li><li>如果不满足条件，说明此时没有主协程，或者没有可用的协程了，那就新建协程</li></ol><p>1、master进程初始化虚拟机，创建lua_state</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化ngx_http_lua_module模块              //初始化虚拟机,lmcf-&gt;lua为创建成功的虚拟机实例</span><br>ngx_http_lua_init               -&gt;         rc = ngx_http_lua_init_vm(&amp;lmcf-&gt;lua, <span class="hljs-literal">NULL</span>, cf-&gt;cycle, cf-&gt;pool, lmcf, cf-&gt;<span class="hljs-built_in">log</span>,<span class="hljs-literal">NULL</span>); <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_init_vm</span><span class="hljs-params">(lua_State **new_vm, lua_State *parent_vm,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_cycle_t</span> *cycle, <span class="hljs-type">ngx_pool_t</span> *pool, <span class="hljs-type">ngx_http_lua_main_conf_t</span> *lmcf,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>, <span class="hljs-type">ngx_pool_cleanup_t</span> **pcln)</span><br>&#123;<br>    ..............................................<br><br>    <span class="hljs-comment">/* create new lua VM instance */</span><br>    L = ngx_http_lua_new_state(parent_vm, cycle, lmcf, <span class="hljs-built_in">log</span>);  <span class="hljs-comment">//创建lua_state</span><br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    .....................................<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化协程队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化配置                                       //初始化队列</span><br>ngx_http_lua_init_main_conf          -&gt;           ngx_queue_init(&amp;lmcf-&gt;cached_lua_threads);<br></code></pre></td></tr></table></figure><p>2、lmcf-&gt;cached_lua_threads</p><p><code>lmcf-&gt;cached_lua_threads</code> 是一个队列，用于缓存 <strong>lua</strong> 协程（线程）。</p><ol><li>这个队列是在 <strong>Nginx</strong> 的 <strong>lua</strong> 模块中使用的，用于管理 <strong>lua</strong> 协程的生命周期。</li><li>具体作用包括但不限于：<ul><li>缓存已经创建的 <strong>lua</strong> 协程，以便在请求处理过程中重复使用。</li><li>避免频繁地创建和销毁协程，提高性能和效率。</li></ul></li><li>当需要执行 <strong>lua</strong> 脚本时，可以从这个队列中获取一个已经存在的协程，而不必每次都重新创建。</li></ol><p><code>lmcf-&gt;cached_lua_threads</code> 是一个用于缓存 <strong>lua</strong> 协程的队列，以优化请求处理性能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_State *<br><span class="hljs-title function_">ngx_http_lua_new_thread</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r, lua_State *L, <span class="hljs-type">int</span> *ref)</span><br>&#123;<br>    ................................<br><br>    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);<br><br>    <span class="hljs-keyword">if</span> (L == lmcf-&gt;lua &amp;&amp; !ngx_queue_empty(&amp;lmcf-&gt;cached_lua_threads)) &#123;   <span class="hljs-comment">//L和lmcf-&gt;lua有可能不相等吗   &amp;&amp;  协程队列不为空</span><br>        q = ngx_queue_head(&amp;lmcf-&gt;cached_lua_threads);<br>        tref = ngx_queue_data(q, <span class="hljs-type">ngx_http_lua_thread_ref_t</span>, <span class="hljs-built_in">queue</span>);<br>    &#125; <span class="hljs-keyword">else</span>   <span class="hljs-comment">//走到这里，说明  协程队列为空 </span><br>    &#123;<br>        lua_pushlightuserdata(L, ngx_http_lua_lightudata_mask(<br>                              coroutines_key));<br>        lua_rawget(L, lua_REGISTRYINDEX); <span class="hljs-comment">//从主协程获取线程队列</span><br>        co = lua_newthread(L);    <span class="hljs-comment">//新创建协程</span><br>        lua_pushvalue(L, <span class="hljs-number">-1</span>);     <span class="hljs-comment">//新创建的协程推入栈中</span><br>        co_ref = luaL_ref(L, <span class="hljs-number">-3</span>);   <span class="hljs-comment">//新协程的引用存储在注册表</span><br><br>        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                       <span class="hljs-string">&quot;lua ref lua thread %p (ref %d)&quot;</span>, co, co_ref);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OPENRESTY_luaJIT      <span class="hljs-comment">//如果是jit，设置全局变量</span></span><br>        <span class="hljs-keyword">if</span> (set_globals) &#123;<br>            lua_createtable(co, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* the new globals table */</span><br><br>            <span class="hljs-comment">/* co stack: global_tb */</span><br><br>            lua_createtable(co, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">/* the metatable */</span><br>            ngx_http_lua_get_globals_table(co);<br>            lua_setfield(co, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__index&quot;</span>);<br>            lua_setmetatable(co, <span class="hljs-number">-2</span>);<br><br>            <span class="hljs-comment">/* co stack: global_tb */</span><br><br>            ngx_http_lua_set_globals_table(co);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    ................................<br></code></pre></td></tr></table></figure><p>3、请求与协程创建关联的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_lua_content_by_chunk(lua_State *L, <span class="hljs-type">ngx_http_request_t</span> *r)<br>&#123;<br>     ................................<br><br>    <span class="hljs-comment">/*  &#123;&#123;&#123; new coroutine to handle request */</span><br>    co = ngx_http_lua_new_thread(r, L, &amp;co_ref);   <span class="hljs-comment">//主线程的创建</span><br><br>    <span class="hljs-keyword">if</span> (co == <span class="hljs-literal">NULL</span>) &#123;<br>        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                      <span class="hljs-string">&quot;lua: failed to create new coroutine to handle request&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;<br>    &#125; <br>   ....................................<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h2><p>1、L和lmcf-&gt;lua有可能不相等吗？</p><ol><li><strong>多线程环境</strong>：如果你的应用程序在多线程环境中运行，每个线程可能有自己的 Lua 解释器状态。在这种情况下，如果 <code>L</code> 被设置为当前线程的 Lua 解释器状态，而 <code>lmcf-&gt;lua</code> 仍然引用主线程的 Lua 解释器状态，那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li><li><strong>Lua 解释器状态切换</strong>：在某些复杂的应用程序中，可能需要动态地切换 Lua 解释器状态。例如，一个请求可能需要在多个 Lua 解释器状态之间切换。在这种情况下，如果 <code>L</code> 被设置为当前需要的 Lua 解释器状态，而 <code>lmcf-&gt;lua</code> 仍然引用之前的 Lua 解释器状态，那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li><li><strong>Lua 解释器状态重新分配</strong>：如果 <code>L</code> 指向的 Lua 解释器状态被重新分配（例如，由于内存管理或垃圾收集），那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li></ol><p>以目前的认识来看，上述3种情况不会发生，这取决于openresty框架怎么设置L和lmcf-&gt;lua</p><blockquote><p>1、《lua源码剖析-云风》<br>2、<a href="https://segmentfault.com/a/1190000038878724">https://segmentfault.com/a/1190000038878724</a><br>3、openresty-1.25.3.1</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>lua虚拟机</tag>
      
      <tag>global_State</tag>
      
      <tag>lua_State</tag>
      
      <tag>元表</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx的reuseport特性分析</title>
    <link href="/2024/04/12/nginx%E7%9A%84reuseport%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <url>/2024/04/12/nginx%E7%9A%84reuseport%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1、奇怪的现象"><a href="#1、奇怪的现象" class="headerlink" title="1、奇怪的现象"></a>1、奇怪的现象</h2><h3 id="1-1、断崖问题"><a href="#1-1、断崖问题" class="headerlink" title="1.1、断崖问题"></a>1.1、断崖问题</h3><p>业务进行性能测试，发现一个奇怪的现象，整个压测过程中总会有断崖的情况。本来TPS在2万8左右，会直接掉到1500左右，然后又马上恢复，但是只能恢复到2万2，损耗了20%。</p><p>现场架构：</p><p><img src="/img/%E7%A7%81%E6%9C%89%E5%8D%8F%E8%AE%AE%E5%8E%8B%E6%B5%8B.jpg" alt="私有协议压测"></p><p>现场XXX、nginx、服务都部署在一个机器，配置为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">机器：海光麒麟v10  sp4  x86<br><br>性能指标：128c  512G<br><br>nginx配置：16个work进程，句柄数40960<br><br>客户端与nginx建立的长连接：16个<br></code></pre></td></tr></table></figure><p>问题在于nginx调大进程为64，或者客户端通道数调大为64，就没有问题。即16-64，64-16没问题，但是16-16有问题，100%复现断崖。</p><p>排查步骤：现场没有监控，所以排查过程比较困难，不过还是确认了一些问题</p><p>1、整个压测过程中，瓶颈不在nginx，因为最大cpu压力才到45%，主要排查问题是断崖。</p><p>2、查看nginx的日志，没有任何报错，但是发现断崖时，客户端给的流量下降了，根据日志绘出曲线后，与压力机的曲线一致</p><p>3、所以着重分析为什么此时客户端给的压力会突降低。但是整个链路的节点都有可能有问题，客户端队列阻塞？nginx处理变慢？服务端处理变慢？</p><p>重点是，这是私有协议，没有做access.log日志，根本看不到请求的耗时、数量等信息，从压力机看，64个进程和16个进程的平均时延没有差距。2中查看的流量还是打开debug，数的日志条数🙂，苦力活。因此开始tcpdump抓包，一个包抓了21个G，现场内网环境拷贝需要经过2层网络，现场还有其他的测试计划，只能见缝插针压测一把，第一天就这样过去了</p><p>第二天包终于拷贝出来了，在看包之前，我想起是信创系统，看了一下nginx的版本，不适配😬，赶快换了对应版本，16-16的模式没有再出现断崖，而且TPS上升了4千，到了3万2，一个数据库的分区直接被打满，断崖问题解决，但是因为操作系统不适配导致的断崖<strong>来日待查</strong>。紧急的问题是，压测的过程中，nginx的各个进程压力不均匀？进程的压力呈递减状态？</p><h3 id="1-2、每个work的连接数不均衡"><a href="#1-2、每个work的连接数不均衡" class="headerlink" title="1.2、每个work的连接数不均衡"></a>1.2、每个work的连接数不均衡</h3><p>我们拥有2种私有协议，可以理解为tcp+xxx数据格式、tcp+json。这类协议的客户端和服务端会建立一条长连接，通常成为通道，后续的请求都是依靠这个通道传输。</p><p>因此为了更加直观的复现，nginx开启了64个进程，xxx应用与nginx建立64条连接。使用netstat命令统计连接数，得以下结果，nginx共有64条连接（其中39个nginx进程有连接，25个进程处于空闲，没有连接。其中1个进程的连接数为4条；5个进程的连接数分别为3条；14个进程的连接数为2条；19个进程的连接数为1条；25个进程的连接数为0条；</p><p><img src="/img/nginx%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%88%86%E5%B8%83%E5%9B%BE.png" alt="nginx各个进程连接数分布图"></p><p>压测过程中，发现共有39个nginx进程有压力，且压力大小与该进程数的连接数成正比，即nginx进程的连接数越多，压力越大，一个进程拿到了4个连接，一个进程拿到了1个连接，压力比是4：1。现场反馈的“递减”现象，其实就是这个现象。那么为什么连接数不一致？</p><p>2、HTTP协议的不均衡</p><p>既然私有协议的连接数不一致，那么来试试HTTP，直接使用HTTP协议连接nginx，配置做了更新，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">128个work进程<br><br>keepalive_request默认值为100<br><br>服务每个增加到3个节点<br><br>数据库增加到3个分区<br></code></pre></td></tr></table></figure><p>架构如下：</p><p><img src="/img/HTTP%E7%9B%B4%E8%BF%9E.jpg" alt="HTTP直连"></p><p>发现nginx的压力依旧不均衡，只有十几个进程有压力，维持在60%~90%，此时tps已经达到8万+，依旧是数据库的瓶颈，到这里就需要研究nginx建立连接的机制。</p><h2 id="2、基础知识"><a href="#2、基础知识" class="headerlink" title="2、基础知识"></a>2、基础知识</h2><p>2.1、epoll</p><p>回顾一下4年前写的epoll的例子，<a href="https://github.com/ZJfans/EpollET-Server/blob/master/epollET.c">https://github.com/ZJfans/EpollET-Server/blob/master/epollET.c</a> </p><ul><li>初始化监听套接字</li><li>创建epoll实例</li><li>监听套接字设置到epoll_ctl中</li><li>使用epoll_wait，循环等待事件</li><li>如果触发事件的是监听套接字，那么建立新的连接</li><li>如果触发事件的是客户端的套接字，那么处理读写事件</li></ul><p>2.2、nginx的工作模式  区别于 muduo</p><p>nginx为多进程模式，初始化时，master监听端口，而后master fork多个work进程，此时所有的work监听同一端口</p><p>muduo为多线程的工作方式，main主线程负责处理监听套接字的事件，在建立连接后，将连接分配给work thread，后续的读写事件都由work线程处理</p><p><img src="/img/nginx%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%BB%91%E5%AE%9A%E5%90%8C%E4%B8%80%E4%B8%AAsocket.png" alt="nginx各个进程绑定同一个socket"></p><h2 id="3、reuseport-SO-REUSEPORT"><a href="#3、reuseport-SO-REUSEPORT" class="headerlink" title="3、reuseport  &amp;&amp;  SO_REUSEPORT"></a>3、reuseport  &amp;&amp;  SO_REUSEPORT</h2><h3 id="3-1、惊群效应"><a href="#3-1、惊群效应" class="headerlink" title="3.1、惊群效应"></a>3.1、惊群效应</h3><p>惊群效应（Thundering Herd）是多进程或多线程系统在等待同一事件时可能遇到的问题。在网络编程中，尤其是在使用epoll进行I&#x2F;O多路复用时，惊群效应可能导致性能问题。下面是关于Nginx如何处理惊群效应的详细解释。</p><p>原因</p><p>nginx的多个进程等待新的网络连接请求。当事件发生时（例如，一个新连接到达），所有等待的进程都会被唤醒。但最终只有一个进程能够处理该事件（例如，通过<code>accept</code>系统调用接受连接），其他进程在尝试处理事件失败后会重新进入等待状态。这个过程会导致大量的上下文切换和CPU资源的浪费。</p><p>Nginx采用了几种策略来避免或减少惊群效应的影响：</p><ol><li><strong><code>accept_mutex</code></strong>:<ul><li>Nginx可以使用<code>accept_mutex</code>来同步对<code>accept</code>调用的访问。这意味着在任何给定时间，只有一个工作进程可以处理新的连接请求。这通过在工作进程之间引入互斥锁来实现，从而避免了多个进程同时尝试接受同一个连接的情况。</li><li>通过在配置文件中设置<code>accept_mutex</code>为<code>on</code>，可以启用此功能。这有助于减少因多个进程竞争同一个<code>accept</code>操作而产生的惊群效应。</li></ul></li><li><strong><code>EPOLLEXCLUSIVE</code></strong>:<ul><li>从Linux内核版本4.5开始，引入了<code>EPOLLEXCLUSIVE</code>标志。Nginx从1.11.3版本开始支持这个特性。</li><li>当使用<code>EPOLLEXCLUSIVE</code>标志添加<code>epoll</code>事件时，内核保证在事件发生时只唤醒一个等待的进程。这减少了因多个进程监听同一个文件描述符而产生的惊群效应。</li></ul></li><li><strong><code>SO_REUSEPORT</code></strong>:<ul><li><code>SO_REUSEPORT</code>是Linux内核3.9版本引入的一个选项，允许多个进程绑定到相同的端口上。Nginx从1.9.1版本开始支持这个特性。</li><li>使用<code>SO_REUSEPORT</code>时，内核会在多个监听相同端口的进程之间进行负载均衡。这样，当新的连接请求到达时，内核会根据一定的规则选择一个进程来处理该请求，从而避免了多个进程同时被唤醒的问题。</li></ul></li></ol><h3 id="3-2、SO-REUSEPORT"><a href="#3-2、SO-REUSEPORT" class="headerlink" title="3.2、SO_REUSEPORT"></a>3.2、SO_REUSEPORT</h3><p><code>SO_REUSEPORT</code> 是一个 Linux 内核级别的套接字选项，它允许多个套接字（通常是监听套接字）绑定到相同的网络地址和端口上。这个特性在 Linux 3.9 版本中引入，主要用于解决多进程或多线程环境中的惊群效应问题。以下是 <code>SO_REUSEPORT</code> 的实现原理的详细解释：</p><p>传统的端口绑定</p><p>在 <code>SO_REUSEPORT</code> 出现之前，根据 POSIX 标准，一个网络端口在同一时间内只能被一个套接字绑定。如果有多个进程想要监听同一个端口，它们必须使用某种同步机制（如互斥锁）来协调对端口的访问，这可能会导致性能问题和复杂的编程模型。</p><p><code>SO_REUSEPORT</code> 的引入</p><p><code>SO_REUSEPORT</code> 选项的引入打破了这个限制，它允许多个套接字监听同一个端口，而不需要特殊的同步机制。当启用 <code>SO_REUSEPORT</code> 时，内核会在内部进行负载均衡，将到达的数据包分发给监听该端口的多个套接字。</p><p>实现原理</p><ol><li><strong>端口复用</strong>：<ul><li>当多个进程或线程的套接字启用了 <code>SO_REUSEPORT</code> 并绑定到同一个端口时，内核会为每个套接字创建一个独立的接收队列。</li><li>所有到达的数据包（例如，新的连接请求）都会根据某种负载均衡算法在这些队列之间进行分配。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>内核使用一种负载均衡算法（通常是轮询或某种形式的哈希算法）来决定哪个套接字应该接收特定的连接请求。</li><li>这意味着即使多个进程在监听同一个端口，每个进程也只会接收到一部分的连接请求，而不是全部。</li></ul></li><li><strong>并发处理</strong>：<ul><li>由于每个进程都有自己的接收队列，它们可以并发地处理连接请求，而不会相互干扰。</li><li>这种方式显著减少了进程间的上下文切换和竞争，提高了系统的并发处理能力。</li></ul></li><li><strong>安全性和隔离</strong>：<ul><li>尽管多个套接字绑定到了同一个端口，但它们之间的通信是隔离的。每个套接字只能处理分配给它的数据包。</li><li>此外，<code>SO_REUSEPORT</code> 选项通常要求所有绑定到同一端口的套接字必须属于同一个用户，以避免潜在的安全问题。</li></ul></li></ol><h3 id="3-3、负载均衡算法"><a href="#3-3、负载均衡算法" class="headerlink" title="3.3、负载均衡算法"></a>3.3、负载均衡算法</h3><p>这是内核从监听的哈希表中查找匹配的套接字，关键函数是compute_score，会给每一个socket算一个权重值，有点类似于nginx的轮询，也是按照算法，得出同一个upstream下每个server的权重，最大的分配请求</p><p>但是当开启SO_REUSEPORT后，其实会直接调用<strong>inet_lookup_reuseport</strong>，这里直接选择socket，选择到就return了。具体分析见第4节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">inet_lhash2_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> inet_listen_hashbucket *ilb2,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-type">int</span> doff,</span><br><span class="hljs-params"><span class="hljs-type">const</span> __be32 saddr, __be16 sport,</span><br><span class="hljs-params"><span class="hljs-type">const</span> __be32 daddr, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> hnum,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dif, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sdif)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>, *<span class="hljs-title">result</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_nulls_node</span> *<span class="hljs-title">node</span>;</span><br><span class="hljs-type">int</span> score, hiscore = <span class="hljs-number">0</span>;<br><br>sk_nulls_for_each_rcu(sk, node, &amp;ilb2-&gt;nulls_head) &#123;<br>score = compute_score(sk, net, hnum, daddr, dif, sdif);<br><span class="hljs-keyword">if</span> (score &gt; hiscore) &#123;<br>result = inet_lookup_reuseport(net, sk, skb, doff,<br>       saddr, sport, daddr, hnum, inet_ehashfn);<br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">return</span> result;<br><br>result = sk;<br>hiscore = score;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4、均衡吗？引发reuseport奇怪的现象"><a href="#3-4、均衡吗？引发reuseport奇怪的现象" class="headerlink" title="3.4、均衡吗？引发reuseport奇怪的现象"></a>3.4、均衡吗？引发reuseport奇怪的现象</h3><p>如果nginx有8个进程监听这个端口，为什么我觉得会很不均匀的分配连接呢？于是用了我们自己的nginx，不开启reuseport的情况下，多个进程都监听了一个socket，但是开启了reuseport后，8个进程每个进程都监听了8个socket？？为什么不是8个进程各自监听自己的socket呢？<br>1、难道是内核版本太低了不支持？或者显示有问题？</p><p>我这个虚拟机的内核是3.1，确实低了，于是找了一个4.19的操作系统，也是这样？</p><p>那就不是linux内核的版本问题</p><p><img src="/img/openresty-1.15.8%E5%BC%80%E5%90%AFreuseport.png" alt="openresty-1.15.8开启reuseport"></p><p>2、nginx的版本的问题？</p><p>我用的是openresty-1.15.8版本，因此nginx的版本也是15.8，因此我下载了最新的openresty-1.25版本，重新编译启动后，结果如下图，work进程完全符合我的预期！！！</p><p><img src="/img/openresty-1.25.3%E5%BC%80%E5%90%AFreuseport.png" alt="openresty-1.25.3开启reuseport"></p><p>因此我去对比了2个版本的代码，发现新版本确实做了优化，<strong>会close多余的socket</strong>。</p><p>而且lsof -i出来的也只是绑定的意思，nginx1.15.8版本的nginx进程虽然绑定了多个socket，但是并没有监听每一个，也就是没有把每一个socket放到epoll里面</p><p>nginx-15</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br>        <span class="hljs-keyword">if</span> (ls[i].reuseport &amp;&amp; ls[i].worker != ngx_worker) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>nginx-25</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_REUSEPORT)</span><br>        <span class="hljs-keyword">if</span> (ls[i].reuseport &amp;&amp; ls[i].worker != ngx_worker) &#123;<br>            ngx_log_debug2(NGX_LOG_DEBUG_CORE, cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;closing unused fd:%d listening on %V&quot;</span>,<br>                           ls[i].fd, &amp;ls[i].addr_text);<br><br>            <span class="hljs-keyword">if</span> (ngx_close_socket(ls[i].fd) == <span class="hljs-number">-1</span>) &#123;<br>                ngx_log_error(NGX_LOG_EMERG, cycle-&gt;<span class="hljs-built_in">log</span>, ngx_socket_errno,<br>                              ngx_close_socket_n <span class="hljs-string">&quot; %V failed&quot;</span>,<br>                              &amp;ls[i].addr_text);<br>            &#125;<br><br>            ls[i].fd = (<span class="hljs-type">ngx_socket_t</span>) <span class="hljs-number">-1</span>;<br><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>问题是master为什么也绑定了4个socket？acceept事件来时，master也会触发？</p><p>事实上不用担心这个问题，因为master根本不会把这些socket放到epoll里面，所以永远不会触发。</p><p>那能不能删除绑定呢？</p><p>nginx的重启依赖于master  fork  work，我在想是不是master的socket不能丢掉，要不然reload的时候，重新创建socket，那之前的一些状态是不是就丢掉了？</p><p>或者停止时，要关掉socket，那么master需要知道当前打开的句柄数，我觉得这个怀疑是最合理的</p><p><strong>有兴趣待查</strong></p><h2 id="4、linux内核源码分析"><a href="#4、linux内核源码分析" class="headerlink" title="4、linux内核源码分析"></a>4、linux内核源码分析</h2><p>现在来看下linux内核是如何实现<code>SO_REUSEPORT</code>，Linux 内核版本 3.9 中引入了这个特性，所以我下载了2个版本的linux内核代码，目前广泛使用的4.19和最新的6.8</p><p>6.8的代码比较清晰直观，直接用ai生成注释😀</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在特定的网络环境中，查找监听哈希桶中与给定条件匹配的套接字。</span><br><span class="hljs-comment"> * 此函数在持有RCU读锁时被调用，不会增加套接字的引用计数。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 参数:</span><br><span class="hljs-comment"> *  - net: 网络环境上下文。</span><br><span class="hljs-comment"> *  - ilb2: 指向当前监听哈希桶的指针。</span><br><span class="hljs-comment"> *  - skb: 数据包缓冲区，可用于查找过程中的某些计算。</span><br><span class="hljs-comment"> *  - doff: 数据包中头部的偏移量。</span><br><span class="hljs-comment"> *  - saddr: 源IP地址。</span><br><span class="hljs-comment"> *  - sport: 源端口号。</span><br><span class="hljs-comment"> *  - daddr: 目标IP地址。</span><br><span class="hljs-comment"> *  - hnum: 目标端口号。</span><br><span class="hljs-comment"> *  - dif: 发送接口索引。</span><br><span class="hljs-comment"> *  - sdif: 源发送接口索引。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 返回值:</span><br><span class="hljs-comment"> *  - 查找到的套接字指针，如果没有找到匹配的套接字则返回NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">inet_lhash2_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> inet_listen_hashbucket *ilb2,</span><br><span class="hljs-params"><span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-type">int</span> doff,</span><br><span class="hljs-params"><span class="hljs-type">const</span> __be32 saddr, __be16 sport,</span><br><span class="hljs-params"><span class="hljs-type">const</span> __be32 daddr, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> hnum,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dif, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sdif)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span>, *<span class="hljs-title">result</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_nulls_node</span> *<span class="hljs-title">node</span>;</span><br><span class="hljs-type">int</span> score, hiscore = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 遍历哈希桶中的所有套接字，计算每个套接字与目标匹配的得分</span><br>sk_nulls_for_each_rcu(sk, node, &amp;ilb2-&gt;nulls_head) &#123;<br>score = compute_score(sk, net, hnum, daddr, dif, sdif);<br><span class="hljs-keyword">if</span> (score &gt; hiscore) &#123;<br><span class="hljs-comment">// 尝试使用ReusePort特性更新结果套接字，如果成功则直接返回</span><br>result = inet_lookup_reuseport(net, sk, skb, doff,<br>       saddr, sport, daddr, hnum, inet_ehashfn);<br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">return</span> result;<br><br><span class="hljs-comment">// 更新最高得分及对应的套接字</span><br>result = sk;<br>hiscore = score;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么重点是2个地方</p><h3 id="4-1、compute-score"><a href="#4-1、compute-score" class="headerlink" title="4.1、compute_score"></a>4.1、compute_score</h3><h4 id="4-1-1、compute-score函数"><a href="#4-1-1、compute-score函数" class="headerlink" title="4.1.1、compute_score函数"></a>4.1.1、<strong>compute_score</strong>函数</h4><p>类似于nginx的轮询算法，算出权重&#x2F;分数，根据 权重&#x2F;分数 分发事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算套接字的得分</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 本函数用于根据给定的网络套接字、网络、目的网络地址、差异接口和源差异接口信息，计算套接字的得分。</span><br><span class="hljs-comment"> * 得分根据套接字的网络匹配、端口号匹配、IPv4/IPv6类型、绑定的设备接口和接收到的数据包的CPU等条件计算。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @param sk 指向当前套接字的指针。</span><br><span class="hljs-comment"> * @param net 指向当前网络的指针。</span><br><span class="hljs-comment"> * @param hnum 当前套接字的端口号。</span><br><span class="hljs-comment"> * @param daddr 目的网络地址。</span><br><span class="hljs-comment"> * @param dif 当前套接字绑定的差异接口索引。</span><br><span class="hljs-comment"> * @param sdif 源差异接口索引。</span><br><span class="hljs-comment"> * @return 返回套接字的得分，匹配不成功返回-1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compute_score</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> net *net,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> hnum, <span class="hljs-type">const</span> __be32 daddr,</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">int</span> dif, <span class="hljs-type">const</span> <span class="hljs-type">int</span> sdif)</span><br>&#123;<br><span class="hljs-type">int</span> score = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化得分为-1分</span><br><br><span class="hljs-comment">// 检查套接字所属的网络是否与指定的网络相同，端口号是否匹配，并且套接字不是IPv6 only类型</span><br><span class="hljs-keyword">if</span> (net_eq(sock_net(sk), net) &amp;&amp; sk-&gt;sk_num == hnum &amp;&amp;<br>!ipv6_only_sock(sk)) &#123;<br><span class="hljs-comment">// 检查套接字的接收地址是否与目的地址不同</span><br><span class="hljs-keyword">if</span> (sk-&gt;sk_rcv_saddr != daddr)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果不同，直接返回-1</span><br><br><span class="hljs-comment">// 检查套接字是否绑定到指定的设备接口，并且设备接口是否匹配差异接口</span><br><span class="hljs-keyword">if</span> (!inet_sk_bound_dev_eq(net, sk-&gt;sk_bound_dev_if, dif, sdif))<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果不匹配，返回-1</span><br><br><span class="hljs-comment">// 根据套接字是否绑定了设备接口，给予1分或2分的奖励</span><br>score =  sk-&gt;sk_bound_dev_if ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 如果套接字是IPv4类型，额外加1分</span><br><span class="hljs-keyword">if</span> (sk-&gt;sk_family == PF_INET)<br>score++;<br><span class="hljs-comment">// 如果一个socket上次处理它的数据包的CPU与当前CPU相同，额外加1分</span><br><span class="hljs-keyword">if</span> (READ_ONCE(sk-&gt;sk_incoming_cpu) == raw_smp_processor_id())<br>score++;<br>&#125;<br><span class="hljs-keyword">return</span> score; <span class="hljs-comment">// 返回计算出的得分</span><br>&#125;<br></code></pre></td></tr></table></figure><p>score是有3个地方会变化，连接会分发给哪个socket，那就是看4个socket哪个点不一样，导致分不一样，也就是4个nginx进程</p><p>1、检查套接字是否绑定到指定的设备接口，并且设备接口是否匹配差异接口</p><p>这个就是网卡，显然对于nginx的4个进程而言，我都是监听所有的网卡，所以这里4个进程的socket得分都是1，也就没有差异</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">server &#123;<br>    listen <span class="hljs-number">38088</span> reuseport;<br>    server_name example.<span class="hljs-property">com</span>;<br><br>    location / &#123;<br>        root /usr/share/nginx/html;<br>        index index.<span class="hljs-property">html</span> index.<span class="hljs-property">htm</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、 如果套接字是IPv4类型，额外加1分<br>这里我只考虑ipv4地址的场景，虽然我也监听了ipv6，因此这里4个进程的socket得分也都加1，没有差异</p><p>3、如果接收到的数据包的CPU与当前CPU相同，额外加1分</p><p>首先先到<strong>sock_reuseport.c</strong>模块，看下<strong>sk_incoming_cpu</strong>的定义</p><ol><li>**<code>sk_incoming_cpu</code>**： 在Linux内核中，<code>sk_incoming_cpu</code>是套接字结构中的一个字段，它记录了最近处理该套接字传入数据的CPU核心。当新的数据包到达时，操作系统会尝试将数据包分配给记录在<code>sk_incoming_cpu</code>中的CPU核心来处理，以此来优化性能。</li></ol><h4 id="4-1-2、CPU和套接字的关系"><a href="#4-1-2、CPU和套接字的关系" class="headerlink" title="4.1.2、CPU和套接字的关系"></a>4.1.2、CPU和套接字的关系</h4><ol><li><strong>数据包到达</strong>： 当一个网络数据包到达时，它首先被网络接口卡（NIC）捕获，并通过中断通知CPU。</li><li><strong>中断处理</strong>： CPU接收到中断后，操作系统的中断处理程序会捕获这个事件，并开始处理数据包。</li><li><strong>套接字绑定</strong>： 操作系统的网络栈会根据数据包的目标地址和端口号，决定将数据包发送到哪个套接字。如果一个套接字已经绑定到了特定的端口，那么所有到达该端口的数据包都会被发送到这个套接字。</li><li><strong>CPU亲和性</strong>： 在多核CPU系统中，操作系统可能会将特定的套接字或网络流量绑定到特定的CPU核心，这种做法称为CPU亲和性（CPU affinity）。这样做的目的是为了提高效率，因为：<ul><li><strong>缓存利用</strong>：如果套接字总是在同一个CPU核心上处理数据，相关的数据结构和状态信息更有可能保留在该核心的CPU缓存中，从而减少内存访问延迟。</li><li><strong>上下文切换</strong>：减少不同CPU核心之间的上下文切换，因为数据包的处理总是在同一个核心上进行。</li><li><strong>负载均衡</strong>：通过将不同的套接字或网络流量分配给不同的CPU核心，可以实现更好的负载均衡。</li></ul></li></ol><p>重要的是第一个网络包达到的时候，那就看看3次握手吧</p><ol><li><strong>客户端发送 SYN 包</strong>: 当客户端想要建立与服务端的 TCP 连接时，它会发送一个 SYN（同步）包给服务端，这个包包含客户端的初始序列号。</li><li><strong>服务端接收 SYN 包并创建 socket</strong>: 服务端收到客户端的 SYN 包后，会分配资源并创建一个用于与客户端通信的 socket，并为该连接分配一个序列号，同时为其分配缓冲区等资源。</li><li><strong>服务端发送 SYN-ACK 包</strong>: 接着，服务端会发送一个 SYN-ACK 包给客户端，该包中包含服务端的序列号以及确认号（即客户端序列号加一），表示服务端已经接收到了客户端的 SYN 包，并愿意建立连接。</li><li><strong>客户端接收 SYN-ACK 包并发送 ACK 包</strong>: 客户端收到服务端的 SYN-ACK 包后，会发送一个 ACK（确认）包给服务端，确认服务端的 SYN 包，并携带服务端的序列号加一的确认号。</li><li><strong>连接建立完成</strong>: 当服务端收到客户端发送的 ACK 包后，连接就建立完成了，服务端和客户端之间可以开始进行数据传输。</li></ol><p><strong>可以看到服务端在接收到客户端的 SYN 包后，会创建一个用于与客户端通信的 socket，这时候就会更新cpu了，也就是sk_incoming_cpu</strong>，下次这个cpu在分配连接的时候，会优先给这个cpu处理过的socket，也就是加一分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 如果一个socket上次处理它的数据包的CPU与当前CPU相同，额外加1分</span><br><span class="hljs-keyword">if</span> (READ_ONCE(sk-&gt;sk_incoming_cpu) == raw_smp_processor_id())<br>score++;<br></code></pre></td></tr></table></figure><h4 id="4-1-3、更新sk-incoming-cpu"><a href="#4-1-3、更新sk-incoming-cpu" class="headerlink" title="4.1.3、更新sk_incoming_cpu"></a>4.1.3、更新sk_incoming_cpu</h4><p>重要的是<strong>reuseport_update_incoming_cpu</strong>，如何设置和更新sk_incoming_cpu</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">reuseport_update_incoming_cpu</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-type">int</span> val)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_reuseport</span> *<span class="hljs-title">reuse</span>;</span><br><span class="hljs-type">int</span> old_sk_incoming_cpu;<br><br><span class="hljs-comment">// 如果reuseport选项未启用，直接更新sk_incoming_cpu值。</span><br><span class="hljs-keyword">if</span> (unlikely(!rcu_access_pointer(sk-&gt;sk_reuseport_cb))) &#123;<br>WRITE_ONCE(sk-&gt;sk_incoming_cpu, val);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 加锁以保护对reuseport相关资源的访问。</span><br>spin_lock_bh(&amp;reuseport_lock);<br><br><span class="hljs-comment">// 在加锁保护下更新sk_incoming_cpu值，以避免并发问题。</span><br>old_sk_incoming_cpu = sk-&gt;sk_incoming_cpu;<br>WRITE_ONCE(sk-&gt;sk_incoming_cpu, val);                <span class="hljs-comment">//这里做更新</span><br><br><span class="hljs-comment">// 安全地访问reuseport_cb，考虑了锁的依赖关系。</span><br>reuse = rcu_dereference_protected(sk-&gt;sk_reuseport_cb,<br>  lockdep_is_held(&amp;reuseport_lock));<br><br><span class="hljs-comment">// 如果reuseport_cb变为NULL，说明套接字已关闭，直接解锁退出。</span><br><span class="hljs-keyword">if</span> (!reuse)<br><span class="hljs-keyword">goto</span> out;<br><br><span class="hljs-comment">// 根据incoming_cpu值的正负变化，调整计数。</span><br><span class="hljs-keyword">if</span> (old_sk_incoming_cpu &lt; <span class="hljs-number">0</span> &amp;&amp; val &gt;= <span class="hljs-number">0</span>)<br>__reuseport_get_incoming_cpu(reuse);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (old_sk_incoming_cpu &gt;= <span class="hljs-number">0</span> &amp;&amp; val &lt; <span class="hljs-number">0</span>)<br>__reuseport_put_incoming_cpu(reuse);<br><br>out:<br><span class="hljs-comment">// 释放锁。</span><br>spin_unlock_bh(&amp;reuseport_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>理解了sk_incoming_cpu，其实就可以理解得分,但是事实上开启了SO_REUSEPORT后，选择的函数是<strong>inet_lookup_reuseport</strong>。</p><h3 id="4-2、inet-lookup-reuseport"><a href="#4-2、inet-lookup-reuseport" class="headerlink" title="4.2、inet_lookup_reuseport"></a>4.2、inet_lookup_reuseport</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 尝试使用ReusePort特性更新结果套接字，如果成功则直接返回</span><br>result = inet_lookup_reuseport(net, sk, skb, doff,<br>       saddr, sport, daddr, hnum, inet_ehashfn);<br><span class="hljs-keyword">if</span> (result)<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>得分完，如果找到了socket，那就直接返回了，让我们看下<strong>inet_lookup_reuseport</strong>做了什么</p><h4 id="4-2-1、inet-lookup-reuseport源码"><a href="#4-2-1、inet-lookup-reuseport源码" class="headerlink" title="4.2.1、inet_lookup_reuseport源码"></a>4.2.1、inet_lookup_reuseport源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">inet_lookup_reuseport</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> sock *sk,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-type">int</span> doff,</span><br><span class="hljs-params">   __be32 saddr, __be16 sport,</span><br><span class="hljs-params">   __be32 daddr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> hnum,</span><br><span class="hljs-params">   <span class="hljs-type">inet_ehashfn_t</span> *ehashfn)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">reuse_sk</span> =</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 默认返回NULL，表示没有找到可重用的套接字 */</span><br>u32 phash;<br><br><span class="hljs-comment">/* 如果当前套接字允许端口复用，则计算哈希值并尝试选择一个可重用的套接字 */</span><br><span class="hljs-keyword">if</span> (sk-&gt;sk_reuseport) &#123;<br><span class="hljs-comment">/* 根据提供的函数指针调用相应的哈希函数计算端口哈希值 */</span><br>phash = INDIRECT_CALL_2(ehashfn, udp_ehashfn, inet_ehashfn,<br>net, daddr, hnum, saddr, sport);<br><span class="hljs-comment">/* 使用计算得到的哈希值从哈希表中选择一个合适的套接字 */</span><br>reuse_sk = reuseport_select_sock(sk, phash, skb, doff);<br>&#125;<br><span class="hljs-keyword">return</span> reuse_sk;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是调用了<strong>reuseport_select_sock</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reuseport_select_sock - 选择合适的socket进行复用</span><br><span class="hljs-comment"> * @sk: 当前的socket结构体</span><br><span class="hljs-comment"> * @hash: 数据包的哈希值</span><br><span class="hljs-comment"> * @skb: 数据包的缓冲区</span><br><span class="hljs-comment"> * @hdr_len: 数据包头的长度</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 此函数根据给定的条件（如BPF程序的结果或哈希值）从复用端口的socket池中选择一个合适的socket。</span><br><span class="hljs-comment"> * 如果有配置的BPF程序，则会先尝试使用BPF程序来决定选择哪个socket。</span><br><span class="hljs-comment"> * 若无BPF程序或BPF程序决策失败，则会基于哈希值来选择socket。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值: 返回选择的socket结构体指针。如果没有合适的socket，则返回NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">reuseport_select_sock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock *sk,</span><br><span class="hljs-params">   u32 hash,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> sk_buff *skb,</span><br><span class="hljs-params">   <span class="hljs-type">int</span> hdr_len)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_reuseport</span> *<span class="hljs-title">reuse</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_prog</span> *<span class="hljs-title">prog</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk2</span> =</span> <span class="hljs-literal">NULL</span>;<br>u16 socks;<br><br>rcu_read_lock();<br>reuse = rcu_dereference(sk-&gt;sk_reuseport_cb);<br><br><span class="hljs-comment">/* 如果内存分配失败或添加调用尚未完成，则直接退出 */</span><br><span class="hljs-keyword">if</span> (!reuse)<br><span class="hljs-keyword">goto</span> out;<br><br>prog = rcu_dereference(reuse-&gt;prog);<br>socks = READ_ONCE(reuse-&gt;num_socks);<br><span class="hljs-keyword">if</span> (likely(socks)) &#123;<br><span class="hljs-comment">/* 配合__reuseport_add_sock()中的smp_wmb()使用 */</span><br>smp_rmb();<br><br><span class="hljs-comment">/* 如果没有配置BPF程序或者skb为空，则直接进行哈希选择 */</span><br><span class="hljs-keyword">if</span> (!prog || !skb)<br><span class="hljs-keyword">goto</span> select_by_hash;<br><br><span class="hljs-comment">/* 根据BPF程序类型执行相应的程序逻辑 */</span><br><span class="hljs-keyword">if</span> (prog-&gt;type == BPF_PROG_TYPE_SK_REUSEPORT)<br>sk2 = bpf_run_sk_reuseport(reuse, sk, prog, skb, <span class="hljs-literal">NULL</span>, hash);<br><span class="hljs-keyword">else</span><br>sk2 = run_bpf_filter(reuse, socks, prog, skb, hdr_len);<br><br>select_by_hash:<br><span class="hljs-comment">/* 如果没有使用BPF程序或BPF程序结果无效，则回退到使用哈希值选择socket */</span><br><span class="hljs-keyword">if</span> (!sk2)<br>sk2 = reuseport_select_sock_by_hash(reuse, hash, socks);<br>&#125;<br><br>out:<br>rcu_read_unlock();<br><span class="hljs-keyword">return</span> sk2;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的选择</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * reuseport_select_sock_by_hash - 根据哈希值选择一个合适的socket</span><br><span class="hljs-comment"> * @reuse: 指向reuseport结构的指针，包含要搜索的socket数组</span><br><span class="hljs-comment"> * @hash: 用于选择socket的哈希值</span><br><span class="hljs-comment"> * @num_socks: socket数组中的socket数量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 描述:</span><br><span class="hljs-comment"> * 此函数用于在给定的socket数组中，根据特定的哈希值选择一个处于TCP_ESTABLISHED状态的socket。</span><br><span class="hljs-comment"> * 如果没有处于该状态的socket，则返回第一个找到的非TCP_ESTABLISHED状态的socket。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 返回值:</span><br><span class="hljs-comment"> * 返回一个指向选择的socket的指针。如果没有找到合适的socket，则返回NULL。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> sock *<span class="hljs-title function_">reuseport_select_sock_by_hash</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sock_reuseport *reuse,</span><br><span class="hljs-params">  u32 hash, u16 num_socks)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">first_valid_sk</span> =</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/* 用于存储第一个找到的有效（非TCP_ESTABLISHED）socket */</span><br><span class="hljs-type">int</span> i, j;<br><br>i = j = reciprocal_scale(hash, num_socks); <span class="hljs-comment">/* 使用哈希值和socket数量计算起始索引 */</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> *<span class="hljs-title">sk</span> =</span> reuse-&gt;socks[i]; <span class="hljs-comment">/* 获取当前索引位置的socket */</span><br><br><span class="hljs-comment">/* 如果socket状态不是TCP_ESTABLISHED，则进行进一步判断 */</span><br><span class="hljs-keyword">if</span> (sk-&gt;sk_state != TCP_ESTABLISHED) &#123;<br><span class="hljs-comment">/* 如果没有设置incoming_cpu，表示没有活动的连接请求，则返回当前socket */</span><br><span class="hljs-keyword">if</span> (!READ_ONCE(reuse-&gt;incoming_cpu))<br><span class="hljs-keyword">return</span> sk;<br><br><span class="hljs-comment">/* 如果当前socket的incoming_cpu与当前CPU一致，表示有活动的连接请求，则返回当前socket */</span><br><span class="hljs-keyword">if</span> (READ_ONCE(sk-&gt;sk_incoming_cpu) == raw_smp_processor_id())<br><span class="hljs-keyword">return</span> sk;<br><br><span class="hljs-comment">/* 如果还没有找到第一个有效的socket，则将当前socket设置为第一个有效socket */</span><br><span class="hljs-keyword">if</span> (!first_valid_sk)<br>first_valid_sk = sk;<br>&#125;<br><br>i++; <span class="hljs-comment">/* 移动到下一个socket */</span><br><span class="hljs-keyword">if</span> (i &gt;= num_socks)<br>i = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 如果超出范围，则从头开始 */</span><br>&#125; <span class="hljs-keyword">while</span> (i != j); <span class="hljs-comment">/* 如果当前索引与起始索引不同，继续循环 */</span><br><br><span class="hljs-keyword">return</span> first_valid_sk; <span class="hljs-comment">/* 返回第一个有效的socket，如果没有找到则返回NULL */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>reuse-&gt;socks[i]，是一个指针数组，它存储了一系列 <code>struct sock</code> 指针。每个 <code>struct sock</code> 指针代表一个网络套接字，这些套接字都绑定到了同一个端口上，并且启用了 <code>SO_REUSEPORT</code> 特性。</p><p><code>num_socks;</code> 字段表示 <code>socks</code> 数组中当前有效的套接字（<code>struct sock</code> 指针）的数量。这个字段用于跟踪监听同一个端口并启用了 <code>SO_REUSEPORT</code> 特性的套接字数量。</p><h4 id="4-2-2、总结"><a href="#4-2-2、总结" class="headerlink" title="4.2.2、总结"></a>4.2.2、总结</h4><ol><li>根据<code>net</code>、<code>daddr</code>、<code>hnum</code>、<code>saddr</code> 和 <code>sport</code> 这几个参数计算一个hash值</li><li>使用哈希值和socket数量计算<strong>reuse-&gt;socks</strong>数组的起始索引</li><li>判断当前socket是否有连接请求在处理，如果没有，说明这个监听socket目前空闲，所以选择这个</li><li>如果上面没有返回，再判断<strong>sk_incoming_cpu</strong>，如果这个socket的上一次数据是当前cpu处理的，那么就选这个socket</li><li>如果这个socket不满足条件，那么作为保底，将这个socket设置为保底选择</li><li>循环3-5步骤</li><li>遍历完<strong>reuse-&gt;socks</strong>数组中的socket后，返回第一个有效的socket，如果没有找到则返回NULL</li></ol><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><h3 id="5-1、原理总结"><a href="#5-1、原理总结" class="headerlink" title="5.1、原理总结"></a>5.1、原理总结</h3><p>对于内核而言，整个过程处于传输层，它不需要关注应用层，因此对于连接的分配，会最大化的优化处理速度，只考虑传输层的属性。主要点在于优先使用空闲的监听socket，并且使监听socket尽量在一个cpu处理，这样有利于cpu缓存的利用。</p><p>因此当开启<code>SO_REUSEPORT</code> 特性后，一个socket是否能拿到连接，取决于3个点</p><p>1、根据哈希值和socket数量计算<strong>reuse-&gt;socks</strong>数组的起始值是多少，第一个当然有优先优势</p><p>2、取决于当前socket是否处于空闲</p><p>3、上一次处理这个socket的数据的cpu，是否是当前cpu</p><h3 id="5-2、均匀吗？"><a href="#5-2、均匀吗？" class="headerlink" title="5.2、均匀吗？"></a>5.2、均匀吗？</h3><h4 id="5-1-1、不会绝对均匀"><a href="#5-1-1、不会绝对均匀" class="headerlink" title="5.1.1、不会绝对均匀"></a>5.1.1、不会绝对均匀</h4><p>当同一个客户端和同一个nginx建立64条长连接时，上面1中的<strong>哈希值和socket数量</strong>是一样的，所以<strong>数组的起始下标</strong>是一样的。</p><p>那么连接分配给哪个进程就取决于2、3。当64条连接<strong>绝对同时</strong>来临时，且nginx的socket此时并没有其它连接来时，也就是处于空闲时，那么第2步会保证每个socket拿到1条连接，但是问题是绝对同时？还要保证没有连接到这些socket，这是不可能的。</p><p>因为连接总会有先后时间，即数据包会先后到，第一个socket处理完第一个连接后，它就又处于空闲了，所以它还会拿到连接，没办法它有优势，起始值算的。</p><h4 id="5-1-2、会发生极限场景吗"><a href="#5-1-2、会发生极限场景吗" class="headerlink" title="5.1.2、会发生极限场景吗"></a>5.1.2、会发生极限场景吗</h4><p>nginx开启64个进程，只有几个进程能拿到连接？</p><p><strong>可能性几乎为0</strong>，因为连接虽然有先后，但是时间差会非常小，所以都会在2中分发。除非客户端隔一段时间发一个请求，事实上客户端如果建立连接会”同时”发的，但是因为有时间差，前面的socket会拿到更多的连接</p><p>同时当连接数量级足够大，那么会近似均匀，但是当只有几十个连接时，也会是近似均匀，但是看着差距会比较大，毕竟有的socket拿不到连接，也就是nginx的进程拿不到连接</p><h4 id="5-1-3、如果想在应用层保证连接数均匀可以实现吗"><a href="#5-1-3、如果想在应用层保证连接数均匀可以实现吗" class="headerlink" title="5.1.3、如果想在应用层保证连接数均匀可以实现吗"></a>5.1.3、如果想在应用层保证连接数均匀可以实现吗</h4><p>这是一个非常意思的想法，我们从2点考虑，可行性与性能。</p><p>1、可行性</p><p>​    最直接的想法，应用层怎么判断进程现在拥有多少个长连接，以及长连接就是T2&#x2F;T3，而不是websocket这种长连接？</p><p>2、性能</p><p>如果每次建立连接都需要判断是否是长连接，且均匀分发到各个进程，性能会断崖式下降</p><p><strong>结论：所以不可能做的到，也没有意义。</strong></p><h4 id="5-1-4、目前这种情况，有必要做连接的均匀分发吗"><a href="#5-1-4、目前这种情况，有必要做连接的均匀分发吗" class="headerlink" title="5.1.4、目前这种情况，有必要做连接的均匀分发吗"></a>5.1.4、目前这种情况，有必要做连接的均匀分发吗</h4><p>​     依据上次实际的统计来看，64个进程会有39个进程拿到连接，也就是39个进程会工作。</p><p>所以cpu只会利用39个？</p><p>根本不是的，因为work进程使用cpu是会切换的，这也是压测到极限，cpu的利用率会超过100%，有些java服务甚至会达到几千。因此cpu的利用率，nginx是最大化的，只不过存在cpu切换的损耗，基本可以忽略不计。</p><p>​     所以，当压力到达nginx极限时，不同的进程的cpu利用率会有不同，但是一定会利用到所有的cpu，也就是可以发挥机器的最大性能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>reuseport</tag>
      
      <tag>linux内核</tag>
      
      <tag>SO_REUSEPORT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie属性之secure、httponly</title>
    <link href="/2024/04/12/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/"/>
    <url>/2024/04/12/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​Cookie是一种用于在Web浏览器和Web服务器之间传递信息的机制，具有多种属性。经常会有安全测试不了解Cookie的属性，而认为某个属性是漏洞，最常见的就是secure，作者就见过很几次漏洞报告，认为http协议下，Cookie的secure为false是一个安全漏洞，这其实是测试没有理解secure的真正作用。那么阅读本文你将得到以下几个问题的答案</p><p>1、Cookie在会话鉴权中扮演什么角色？</p><p>2、secure、httponly的作用是什么？</p><p>3、http协议secure为false，到底是不是漏洞？</p><h2 id="1、首先来了解Cookie的作用"><a href="#1、首先来了解Cookie的作用" class="headerlink" title="1、首先来了解Cookie的作用"></a>1、首先来了解Cookie的作用</h2><p>​Cookie通常被用于存储用户的会话信息、个人偏好设置和其他重要的数据。通过在浏览器中存储小型数据文件的方式，允许Web应用程序在浏览器中存储和检索数据。以下是Cookie的一些常见用途：</p><ol><li>记住用户登录状态：当用户通过用户名和密码进行登录时，服务器会创建一个Cookie，用于记录用户的登录状态。在用户下次访问网站时，Web应用程序可以读取Cookie中的信息，以确认用户已经登录，然后将其自动重定向到其上一次访问的页面。</li><li>存储用户偏好设置：Web应用程序可以使用Cookie来存储用户的偏好设置，例如语言偏好、字体大小、主题颜色等。这样，在用户再次访问网站时，他们的偏好设置就可以自动应用，提高了用户体验。</li><li>跟踪用户活动：通过Cookie，Web应用程序可以追踪用户的活动，例如他们在网站上浏览的页面、使用的功能和购物车内容等。这些信息可以用于分析用户行为、个性化推荐、广告定向等。</li><li>收集统计数据：Cookie也可以用于收集访问网站的用户数量、浏览器类型、设备类型等统计数据。这些数据可以帮助网站优化性能、改进用户体验和制定营销策略。</li></ol><p>总的来说，Cookie是Web应用程序中不可或缺的一部分，它们帮助实现了许多重要的功能，从而提高了用户体验和Web应用程序的效果。</p><p>​我们的产品基于openresty开发，作为互联网接入路由网关，具备会话鉴权的功能。登录时，网关会生成token等会话信息，设置到响应的Cookie头部，返回给浏览器，浏览器会在application存储Cookie信息，当有同域的请求发起时，浏览器会将此域的Cookie（如果有的话）携带并发往服务端进行认证；登出时，网关会设置一个空的Cookie返回给浏览器，相当于删除了application存储Cookie信息。下面为使用https协议登录时的交互：</p><ul><li>登录时</li></ul><p><img src="/img/image-20230305161709819.png" alt="image-20230305161709819"></p><ul><li>登出时：</li></ul><p><img src="/img/image-20230305161752487.png" alt="image-20230305161752487"></p><h2 id="2、Secure与HTTPOnly属性"><a href="#2、Secure与HTTPOnly属性" class="headerlink" title="2、Secure与HTTPOnly属性"></a>2、Secure与HTTPOnly属性</h2><p>​由于Cookie的特殊性质，它们也成为了网络攻击的主要目标之一。在这种情况下，secure和httponly属性成为了确保Cookie安全的重要手段。</p><ol><li>Secure属性是Cookie属性的一种，它用于确保Cookie只在通过安全协议（如HTTPS）的情况下传输。如果将Cookie设置为secure，则只有在使用HTTPS时才会将Cookie发送到服务器，即使用HTTPS协议进行登录，但是后续的请求为HTTP，这样是无法将Cookie携带到服务端的。而且即使攻击者截取了用户的Cookie，也无法使用它们进行会话劫持等攻击。</li><li>HTTPOnly属性是另一种Cookie属性，它可以防止JavaScript代码访问Cookie。JavaScript可以通过document.cookie API来访问Cookie，但是如果将Cookie设置为HTTPOnly，则它们将无法被JavaScript代码获取。这可以防止攻击者通过注入恶意脚本来窃取用户的Cookie，从而提高了Cookie的安全性。</li></ol><p>​综合起来，secure和HTTPOnly属性的结合使用可以大大提高Cookie的安全性，使其更难以被攻击者利用。在设置Cookie时，建议使用这两种属性来确保Cookie的安全性，并且仅在需要将Cookie发送到服务器时才发送它们。需要注意的是，虽然使用secure和HTTPOnly属性可以帮助保护Cookie，但它们并不是完全安全的。攻击者仍然可以使用其他手段来窃取Cookie，例如使用钓鱼攻击来欺骗用户输入他们的凭据。因此，在处理敏感信息时，建议采取其他更全面的安全措施，例如使用多因素身份验证和数据加密等技术来确保数据安全。</p><h2 id="3、结尾"><a href="#3、结尾" class="headerlink" title="3、结尾"></a>3、结尾</h2><p>回到我们的问题，http协议secure为false，到底是不是漏洞？在阅读过第2章后，读者认真思考过应该有了答案。</p><hr><p>显而易见，肯定不是漏洞，HTTP协议根本就不需要secure！！！secure只用于https，在https登录的情况下，限制Cookie被http协议的请求传输。举个实际的例子</p><ul><li>http:</li></ul><p><img src="/img/image-20230305160119214.png" alt="image-20230305160119214"></p><ul><li>https：</li></ul><p><img src="/img/image-20230305160932809.png" alt="image-20230305160932809"></p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
