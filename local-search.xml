<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/06/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/03/06/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>title: 协商缓存在nginx的应用与实践<br>tags: [websocket, nginx]<br>index_img: </p><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>缓存是一个高效减轻网络与服务器压力的机制，具有减少冗余数据传输、缓解网络瓶颈以及降低时延等优点。通常客户端在请求数据时，会发送请求到原始服务器获取，重复的数据可能会在网络中多次传输，但是如果有缓存，客户端就可以直接从缓存中获取数据，减少重复的流量。例如在浏览器首次请求某些静态资源时，状态码会是200 ok，但是刷新页面，状态码就会变为200 ok ( from memory cache)，这是因为浏览器对这些资源进行了缓存，客户端的数据并不是发送请求到原始服务器获取的，而是从缓存中获取的。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif" alt="img"></p><p>但是问题也是显而易见的，如果原始服务器的数据发生了改变，而缓存并没有及时更新数据，在客户端请求时返回了过期的数据，这就会导致了数据的不准确。已缓存的数据应当与原始服务器的数据保持一致，更准确的来说，是缓存返回的数据应当与原始服务器的数据保持一致。那么如何在缓存的基础上，避免这个问题呢？事实上，HTTP协议是提供了多种机制来保证数据一致性的。</p><h2 id="2、“使用期”与“新鲜度“"><a href="#2、“使用期”与“新鲜度“" class="headerlink" title="2、“使用期”与“新鲜度“"></a>2、“使用期”与“新鲜度“</h2><p>使用期是指数据在服务器响应返回后的总时间，可以简单理解为数据在缓存使用的时间，从服务器将数据发出去开始计时；新鲜度是指数据在服务器响应发出去后，缓存可以使用的时间。如果使用期小于新鲜度，说明数据是“新鲜的”，缓存可以继续使用。反之，缓存需要判断数据是否发生了更新，是否需要重新拉取数据，如何更新这取决于服务端采用的HTTP缓存策略。</p><p><strong>使用期：</strong></p><p>服务器用HTTP协议的响应头部date表示发送数据时的时间，如果客户端与服务端使用同样的、完全精确的时钟，已缓存数据的使用期（data_age）就可以是当前时间（current_time）减去服务器发送数据时（Date_header_value）的时间。</p><p>data_age &#x3D; current_time – date_header_value</p><p>但是并不是所有的计算机都实现了时钟同步，当服务器和客户端的时钟不同步时，使用期可能是很大或者甚至是负的，如果是负的，就需要将其设置为零。</p><p>data_age &#x3D; max(0，current_time – date_header_value)</p><p>date_header_value的值代表着原始服务器发出数据的时间，所以在经过代理时，一定不能进行修改。</p><p><strong>新鲜度：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Expires : Fri, <span class="hljs-number">09</span> Sep <span class="hljs-number">2022</span>, <span class="hljs-number">05</span>:<span class="hljs-number">27</span>:<span class="hljs-number">57</span> GMT<br><br>Cache-Control : max-age=<span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>服务器用HTTP&#x2F;1.0+的Expires或HTTP&#x2F;1.1的Cache-Control:max-age响应头部指定数据的过期时间。Expires指定的是绝对时间，即数据到这个时间就过期了。而Cache-Control:max-age指定的是相对时间，表示缓存收到数据后可以在缓存存活的时间。由于Expires依靠于时钟的准确性，因此目前更多的使用后者。</p><p>通过比对使用期与新鲜度，缓存可以判断当前存储的数据是否足够新鲜，如果足够新鲜，则直接返回缓存中的数据，不然就只能重新从原始服务器拉取数据。但是数据在缓存中已经过期，而原始服务器中并未发生更新，缓存依旧需要发送请求获取数据，这会消耗大量不必要的网络资源。对于网络传输而言，应当遵守以最小数据量传输而保证最大信息量传输的原则，因此为了减少冗余数据的传输，HTTP协议提供了协商缓存机制，用以减少数据的传输。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.gif" alt="使用期与新鲜度"></p><h2 id="3、协商缓存：no-store、no-cache与must-revalidate"><a href="#3、协商缓存：no-store、no-cache与must-revalidate" class="headerlink" title="3、协商缓存：no-store、no-cache与must-revalidate"></a>3、协商缓存：no-store、no-cache与must-revalidate</h2><figure class="highlight https"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs https">HTTP/1.0:<br><br>    Pragma: no-cache<br><br>HTTP/1.1:<br><br>    Cache-Control: no-store<br><br>    Cache-Control: no-cache<br><br>    Cache-Control: must-revalidate<br></code></pre></td></tr></table></figure><p>服务器可以通过no-store来禁止缓存对数据进行存储，因此每次客户端请求数据时，缓存都需要发送请求到原始服务器获取，这样就可以保证客户端获取数据的新鲜度。</p><p>no-cache与no-store不同，no-cache允许缓存对数据进行存储，缓存需要在原始服务器验证新鲜度之后，才能将数据返回给客户端。通常，如果数据发生了更新，原始服务器会返回更新后的数据；反之，会返回304，表示缓存的数据并没有发生改变，可以把缓存的数据返回给客户端。</p><p>而must-revalidate与no-cache类似，同样允许缓存对数据进行存储。如果缓存的数据过期，则must-revalidate与no-cache的行为一致；但是如果数据未过期，则可以直接返回给客户端数据而无需验证。因此must-revalidate通常需要与Expires、max-age进行配合使用。例如：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg" alt="img"></p><p>现在让我们总结一下这3种缓存机制的特点：</p><p>no-store：缓存不可以存储数据，每次请求都需要到服务器获取数据，因此可以保证数据的新鲜度，但是大量冗余数据的传输，会增大网络与服务器的压力，降低系统的整体性能。</p><p>no-cache：缓存可以存储数据，每次请求都需要到服务器进行新鲜度的验证，因此可以保证数据的新鲜度。相比于no-store，减少了大量数据的传输。</p><p>must-revalidate：缓存可以存储数据，如果数据过期，则需要到服务器进行新鲜度的验证，反之，则可以直接返回给客户端数据。相比于no-cache，减少一定数量的新鲜度验证请求，进一步减少网络与服务器的压力，但是不能保证数据的新鲜度，有一定时间的误差，这取决于新鲜度的设置。</p><p>3种机制各有优劣，应该根据具体的业务需求选择合适的缓存机制，但整体来看，no-cache适合绝大部分的场景。 </p><h3 id="3-1、no-cache验证新鲜度：if-modified-since与if-none-match"><a href="#3-1、no-cache验证新鲜度：if-modified-since与if-none-match" class="headerlink" title="3.1、no-cache验证新鲜度：if-modified-since与if-none-match"></a>3.1、no-cache验证新鲜度：if-modified-since与if-none-match</h3><p>当原始服务器采用no-cache缓存模式时，缓存请求数据，服务器的响应会返回响应头Last-Modified与Etag。Last-Modified表示原始服务器修改该数据的最后时间，Etag是一个字符串，不同的系统生成方式也是不同的。缓存在验证新鲜度时，会将这2个值通过2个请求头If-Modified-Since与If-None-Match传送到原始服务器，而原始服务器通过比对这2个值，就可以判断缓存的数据与本地数据是否一致，也就可以决定是否需要返回数据。</p><p>响应：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Last-Modified : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>ETag : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><p>请求：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">If-Modified-Since : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>If-None-Match : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><h2 id="4、协商缓存在nginx的应用"><a href="#4、协商缓存在nginx的应用" class="headerlink" title="4、协商缓存在nginx的应用"></a>4、协商缓存在nginx的应用</h2><h3 id="4-1、应用no-cache对前端的优化"><a href="#4-1、应用no-cache对前端的优化" class="headerlink" title="4.1、应用no-cache对前端的优化"></a>4.1、应用no-cache对前端的优化</h3><p>nginx提供流量分发、协议转换、静态资源代理等功能。本节以HUI前端为例，围绕静态资源代理这一功能，分析nginx何应用no-cache优化前端。</p><p>see界面可以对协商缓存进行设置，最后落地到配置文件nginx.conf，具体配置如下图所示，可以设置单个文件采用协商缓存模式如： sysconfig.js；也可以根据文件类型后缀设置协商缓存模式如：html或js。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg" alt="img"></p><p>首先在浏览器访问hui-build前端，可以看到首次访问时，静态资源的状态码是200 ok，这代表数据是从服务器获取到的。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>接着刷新界面，可以看到状态码变为304 Not Modified，nginx的日志信息也可以看到客户端是发起了一次请求到nginx获取数据，判断到数据并未发生更新返回304。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg" alt="img"></p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg" alt="img"></p><p>此时，如果对sysconfig.js进行修改，再次刷新界面，如下图所示，可以看到状态码变为200 ok，修改的内容及时返回到了客户端。</p><p>修改前：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></p><p>修改：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img"></p><p>接着刷新界面，可以看到状态码变为200 ok，而且数据已经更新：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img"></p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img"></p><p>   这样既可以保证数据的及时更新，又可以减少大量数据的传输，唯一的网络开销是进行新鲜度的再次验证。</p><h3 id="4-2、nginx源码分析If-Modified-Since与If-None-Match"><a href="#4-2、nginx源码分析If-Modified-Since与If-None-Match" class="headerlink" title="4.2、nginx源码分析If-Modified-Since与If-None-Match"></a>4.2、nginx源码分析If-Modified-Since与If-None-Match</h3><p><strong>etag的生成</strong></p><p>nginx的etag的生成方式比较简单，由last-modified与content-length转换为十六进制组合而成。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg" alt="img"></p><p>缓存请求数据时，在响应头返回给缓存。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image026.jpg" alt="img"></p><p><strong>If-Modified-Since****与If-None-Match的校验</strong></p><p>缓存向nginx验证数据新鲜度时，需要携带If-Modified-Since与If-None-Match请求头。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image028.jpg" alt="img"></p><p>nginx在判断缓存数据的新鲜度时，会先后对If-Modified-Since和If-None-Match与当前数据的last-modified和etag进行比对，只要2者有1个发生了改变，则判断本地数据发生更新，缓存中的数据已过期，就会直接返回更新后的数据，如果都没有变，则会返回304。源码与流程图如下。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image030.jpg" alt="img"></p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image032.gif" alt="基础缓存数据流程"></p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>协商缓存不只是一种简单的缓存机制，更是一种很好的理念。对于客户端与服务端数据同步、性能优化都是很好的借鉴，尤其是服务端不能主动向客户端发送请求的场景。例如当有服务以域名的形式注册到nginx时，nginx需要向DNS查询真实ip，为了避免每次请求都会向DNS查询，会对查询到的结果进行缓存，并启动定时器查询真实ip是否发生改变。而定时器的时间就类似于协商缓存的新鲜度，在实际的生产中没有完美的方案，因此需要根据具体的需求偏重来调整可靠性与性能。</p><p>本文从HTTP缓存原理出发，介绍了缓存对系统性能优化的意义，并讲解了HTTP缓存发展过程中存在冗余数据多次传输的问题，以及为了解决这个问题而出现的协商缓存机制。通过对协商缓存的原理与nginx实现协商缓存的源码分析，希望大家可以对HTTP缓存有一定的理解。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SOCKET.IO最佳实践-代理篇</title>
    <link href="/2024/02/28/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/"/>
    <url>/2024/02/28/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在传统的轮询中，客户端定期向服务器发送请求，询问是否有新的数据可用。这会导致很多不必要的空请求，尤其是在没有新数据可用的时候。而且如果使用的是HTTP&#x2F;1.0版本，每个请求&#x2F;响应都需要打开一个新连接，考虑到连接的建立、关闭、TCP慢启动机制等因素，这是一个很大的开销。因此HTTP&#x2F;1.1引入了2个头部:Connection头部和Upgrade头部，用于协议升级。</p><p>其中Connection: keep-alive可以将HTTP短链接升级为长连接，这意味着在一个 TCP 连接上可以传输多个 HTTP 请求和响应，这样就减少大量请求建立、关闭等因素的开销，并且依靠这个机制，可以实现一种长轮询的模式，进一步减少空请求的损耗。需要注意的是，HTTP&#x2F;1.0也可以使用Connection: keep-alive，但是服务端并不一定支持，因此尽可能使用HTTP&#x2F;1.1版本，同时本文后续出现的HTTP，默认指的都是HTTP&#x2F;1.1。</p><p>同样，可以使用Connection: Upgrade与Upgrade: websocket将HTTP连接升级为websocket，具体可以参考本人另外一篇文章《浅析nginx实现websocket原理》。</p><h2 id="1、HTTP-长轮询："><a href="#1、HTTP-长轮询：" class="headerlink" title="1、HTTP 长轮询："></a>1、HTTP 长轮询：</h2><p>HTTP长轮询通过使用Connection: keep-alive实现服务端消息的“推送”。具体过程如下：</p><p>1.客户端发送一个HTTP请求到服务器，但服务器不立即响应。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">GET /socket<span class="hljs-selector-class">.io</span>/?EIO=<span class="hljs-number">4</span>&amp;transport=polling&amp;t=OtBbTrW HTTP/<span class="hljs-number">1.1</span><br>Cache-Control: no-cache<br>Connection: keep-alive<br>Host: <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3001</span><br>Pragma: no-cache<br></code></pre></td></tr></table></figure><p>2.服务器保持请求打开，等待有新的数据或事件发生。</p><p>3.一旦有新的数据或事件发生，服务器立即响应请求，将数据传输给客户端。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content</span>-Type: text/plain; charset=UTF-<span class="hljs-number">8</span><br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">118</span><br>cache-control: no-store<br>Date: Wed, <span class="hljs-number">21</span> Feb <span class="hljs-number">2024</span> <span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">32</span> GMT<br>Connection: keep-alive<br>Keep-Alive: timeout=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Keep-Alive: timeout&#x3D;5 表示服务器愿意在响应后保持连接打开，等待可能的进一步请求，而这个连接将在5秒钟后自动关闭，除非另外有新的请求。</p><p>4.客户端收到响应后，立即再次发起新的HTTP请求，重复上述过程。</p><p>相比于传统轮询，HTTP长轮询减少了不必要的空请求，因为服务器只在有新数据时才会响应。并且这种方式可以降低通信的延迟，因为服务器在有数据时立即将其传输给客户端，而不需要等到下一次定期轮询。</p><p>但是服务器必须维护大量的打开连接，这可能导致服务器资源的浪费。而且在某些情况下，中间代理（如代理服务器或防火墙）可能会中断长轮询连接，导致不稳定的通信。</p><p>所以对于服务端推送消息的场景，websocket是一种更好的方式，HTTP长轮询只是提供了一种在不支持WebSocket的环境中实现实时通信的方法。</p><h2 id="2、Socket-io"><a href="#2、Socket-io" class="headerlink" title="2、Socket.io"></a>2、Socket.io</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现低延迟, 双向和基于事件的通信。Socket.IO在普通的websocket上提供一些功能，如自动重新连接、广播、HTTP长轮询回退（无法与服务端建立websocket连接，将回退为HTTP长轮询）等功能。因此一个socket.io客户端和服务端的交互过程中，可能会同时存在HTTP长轮询与websocket协议的请求。在存在代理的链路中，不当的配置会导致通信失败，本文将着重分析在多级代理中，如何正确配置使得socket.io客户端与服务端正常通信。</p><h3 id="2-1、会话id"><a href="#2-1、会话id" class="headerlink" title="2.1、会话id"></a>2.1、会话id</h3><p>在 Socket.IO 中，每个客户端连接都会被分配一个唯一的标识符，通常被称为会话id，会话id在服务端会关联客户端的连接。所有后续HTTP请求的参数中必需携带这个值，这个标识符可以用于在服务器端跟踪和识别特定的客户端连接。</p><p>通过这种标识符，服务器可以维护一个连接池，用于管理和处理来自不同客户端的实时通信。这对于实现诸如广播消息、单播消息、断线重连等功能都非常有用。</p><p>在 Socket.IO 中，连接建立时会触发一个事件（通常是 <strong>connection</strong> 事件），服务器会分配一个唯一的 sid给客户端连接，一个HTTP长轮询请求如下图所示。</p><p><img src="/img/socket-%E5%9B%BE1.png" alt="socket-图1"></p><h3 id="2-2、socket-io集群"><a href="#2-2、socket-io集群" class="headerlink" title="2.2、socket.io集群"></a>2.2、socket.io集群</h3><p>Socket.IO客户端和服务端是靠会话id一一对应的，所以客户端请求到了错误的Socket.IO服务端时，就会报错，因为服务端识别不了。</p><p>因此，当socket.io为集群时，nginx做代理，如果负载策略是轮询，那么客户端和服务端会有概率不匹配。下图的场景，client-A的请求必须路由到第二个socket.io节点，因为nginx是轮询，因此每3笔会有一笔失败，在浏览器的现象就是，刷新2次界面后，系统恢复正常。</p><p>因此，需要在nginx开启会话保持，即ip_hash，这样一个客户端的ip会固定路由到一个Socket.IO服务端，这样就不会出现不匹配的问题。</p><p><img src="/img/socket-%E5%9B%BE2.png" alt="socket-图2"></p><h2 id="3、websocket"><a href="#3、websocket" class="headerlink" title="3、websocket"></a>3、websocket</h2><p>websocket很明显是优于HTTP长轮询的，只要维持一条长连接，就可以实现全双工通信，避免了频繁的建立连接。通常Socket.IO首先会发起HTTP长轮询请求，服务端会在响应中返回upgrades 数组，表示服务器支持更好的传输协议，如下所示。然后，socket.io客户端就会将协议升级为upgrades 数组中的一种。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;sid&quot;</span>: <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span>,<br>  <span class="hljs-string">&quot;upgrades&quot;</span>: [<span class="hljs-string">&quot;websocket&quot;</span>],<br>  <span class="hljs-string">&quot;pingInterval&quot;</span>: <span class="hljs-number">25000</span>,<br>  <span class="hljs-string">&quot;pingTimeout&quot;</span>: <span class="hljs-number">20000</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>sid 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</p></li><li><p>upgrades 数组包含服务器支持的所有“更好”传输的列表</p></li><li><p>pingInterval 和 pingTimeout 值用于心跳</p></li></ul><h3 id="3-1、socket-io升级websocket的过程"><a href="#3-1、socket-io升级websocket的过程" class="headerlink" title="3.1、socket.io升级websocket的过程"></a>3.1、socket.io升级websocket的过程</h3><p>1、 最开始客户端的请求</p><p><img src="/img/socket-%E5%9B%BE3.png" alt="socket-图3"></p><p>2、服务端响应</p><p><img src="/img/socket-%E5%9B%BE4.png" alt="socket-图4"></p><p>3、客户端发送请求建立websocket连接</p><p><img src="/img/socket-%E5%9B%BE5.png" alt="socket-图5"></p><p>其中请求头为</p><p><img src="/img/socket-%E5%9B%BE6.png" alt="socket-图6"></p><p>响应头为</p><p><img src="/img/socket-%E5%9B%BE7.png" alt="socket-图7"></p><p>4、心跳</p><p>心跳间隔为25s，与”pingInterval”: 25000是一致的</p><p><img src="/img/socket-%E5%9B%BE8.png" alt="socket-图8"></p><h3 id="3-2、此websocket非常规的websocket"><a href="#3-2、此websocket非常规的websocket" class="headerlink" title="3.2、此websocket非常规的websocket"></a>3.2、此websocket非常规的websocket</h3><p>Socket.IO 可以使用 WebSocket 协议，但它为每个数据包添加了额外的元数据。所以 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p><p>我们团队提供的wss组件，虽然支持了socket.io与普通的websocket，但是同一时刻也只能支持其中的一种，即使用socket.io的客户端和websocket客户端连接wss，总有一个会失败。</p><h2 id="4、代理"><a href="#4、代理" class="headerlink" title="4、代理"></a>4、代理</h2><p>由于会话id的存在，每个携带唯一会话id的HTTP请求都必须路由到对应的socket.io服务端，尤其是socket.io服务端为多节点时。本节着重讲解如何正确配置代理节点，使得socket.io客户端与服务端可以使用HTTP长轮询与websocket进行正常通信。</p><h3 id="1、socket-io为单节点"><a href="#1、socket-io为单节点" class="headerlink" title="1、socket.io为单节点"></a>1、socket.io为单节点</h3><ul><li>HTTP长轮询</li></ul><p>socket.io为单节点时，客户端和服务端肯定是对应的，所以不管中间代理怎么路由，都没有问题。</p><ul><li>websocket</li></ul><p>中间节点都需要升级HTTP协议为websocket，如果是四层负载，那就不需要做任何改动，websocket只针对<strong>七层负载。</strong></p><h3 id="2、socket-io多节点"><a href="#2、socket-io多节点" class="headerlink" title="2、socket.io多节点"></a>2、socket.io多节点</h3><h4 id="1、一级代理"><a href="#1、一级代理" class="headerlink" title="1、一级代理"></a>1、一级代理</h4><p>1、代理为单节点</p><p><img src="/img/socket-%E5%9B%BE9.png" alt="socket-图9"></p><ul><li>HTTP长轮询</li></ul><p>由于client使用session id和socket.io端一一对应，因此需要保证同一client的请求一直路由到同一socket.io服务端，否则会报400的错误（其他服务端识别不了未知的sid)。所以nginx需要配置会话保持，即ip_hash，其他负载均衡器类似。</p><p><img src="/img/socket-%E5%9B%BE10.png" alt="socket-图10"></p><ul><li>websocket</li></ul><p>如果nginx配置了协议升级，client到nginx、nginx到socket.io的连接都是websocket协议的连接，即长连接，nginx保证了client与服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE11.png" alt="socket-图11"></p><h4 id="2、多级代理"><a href="#2、多级代理" class="headerlink" title="2、多级代理"></a>2、多级代理</h4><h5 id="1、单-单"><a href="#1、单-单" class="headerlink" title="1、单-单"></a>1、单-单</h5><p>l HTTP长轮询</p><p>如果代理是单节点-单节点，如下图。为了保证客户端与服务端一一对应，那么需要在<strong>第二个nginx配置会话保持</strong>。</p><p><img src="/img/socket-%E5%9B%BE12.png" alt="socket-图12"></p><ul><li>Websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="2、单-多"><a href="#2、单-多" class="headerlink" title="2、单-多"></a>2、单-多</h5><ul><li>HTTP长轮询</li></ul><p>如果代理节点是单节点-多节点，为了保证客户端与服务端一一对应，那么需要<strong>多级nginx都需要配置会话保持</strong>。这时我们应该发现了一个规律，<strong>只要某个节点后面的节点是集群，那么当前节点就需要配置会话保持</strong>，这其实就是HTTP长轮询在多级代理场景下的核心</p><p><img src="/img/socket-%E5%9B%BE13.png" alt="socket-图13"></p><p>深度思考二个问题：</p><p>1、上图第一个nginx真的需要配置ip_hash吗？</p><p>2、下图，哪些nginx需要配置ip_hash?</p><p>答案将会放在第5节，如果你能回答正确，那么你就真正理解了如何代理长轮询</p><p><img src="/img/socket-%E5%9B%BE14.png" alt="socket-图14"></p><ul><li>websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="3、多-多"><a href="#3、多-多" class="headerlink" title="3、多-多"></a>3、多-多</h5><p>这种场景和单-多的场景没有任何区别，因为集群前面肯定有一个单节点的负载均衡器做负载，本质也是单-多。有些人可能好奇，双活难道不是每个节点都是集群吗，整条链路如果存在单节点，这个单节点挂掉之后，整条链路随之挂掉，事实上就是这样的，所以在负载的最前面，都是用DNS做分发。</p><h5 id="4、多-单"><a href="#4、多-单" class="headerlink" title="4、多-单"></a>4、多-单</h5><p>同上，本质和单-多没有区别</p><h4 id="3、HTTP长轮询与websocket同时存在"><a href="#3、HTTP长轮询与websocket同时存在" class="headerlink" title="3、HTTP长轮询与websocket同时存在"></a>3、HTTP长轮询与websocket同时存在</h4><p>Socket.io的机制会同时存在HTTP长轮询与websocket协议的请求，所以代理节点需要<strong>同时配置会话保持与协议升级的配置</strong>。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>1、首先回答第4节的2个问题</p><p>1、第一个nginx真的需要配置ip_hash吗？</p><p>ip_hash是将某一ip的客户端，固定路由到后台的某一台服务器。所以假设client-A、client-B与某个socket.io建立了会话,，那么后续请求也需要一一对应，我们可以推测nginx-M是否设置ip_hash的路由场景</p><ul><li>nginx-M设置了ip_hash</li></ul><p>因为client-A与client-B的ip不一样，nginx-M又设置了ip_hash，所以client-A的请求都会走到nginx-A（这是假设，事实上不走A，就会走B，这里假设走A），client-B的请求都会走到nginx-B。重点来了，<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端（ip_hash的算法决定），假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong></p><ul><li>nginx-M没有设置ip_hash</li></ul><p>如果nginx-M没有设置ip_hash，client的请求，nginx-M会轮询分发到ngina-A和nginx-B，但是由于<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端，假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong>，我们发现和上面一模一样，所以结论是nginx-M是不需要设置ip_hash的。</p><p><img src="/img/socket-%E5%9B%BE15.png" alt="socket-图15"></p><p>2、哪些nginx需要配置ip_hash?</p><p>2个问题的本质是一样的，事实上，只要nginx-M、nginx-C、nginx-D设置了ip_hash就可以保证客户端和服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE16.png" alt="socket-图16"></p><p>2、结论</p><p>其实为了简单化问题，我们可以对每个nginx都设置ip_hash，但是需要注意的是，总会有一层的集群变成了”单点”，有节点总是处于空闲状态!，导致集群变成了单点</p><h2 id="6、socket-io集群同步"><a href="#6、socket-io集群同步" class="headerlink" title="6、socket.io集群同步"></a>6、socket.io集群同步</h2><p>试想，如果socket.io集群间能同步数据，那么是不是客户端可以随意对应哪个socket.io了？</p><p>答案是的</p><p>由于客户端可能连接到集群中不同的节点，为了在集群中不同的节点之间传递消息，socket.io官方以redis的发布订阅功能为基础做了消息路由分发：<strong>socket.io-redis</strong>。<strong>socket.io-redis</strong>在节点向客户端群发消息时会将该消息发布到redis的订阅队列中，让其他节点能够订阅到该消息，从而实现节点间消息推送。不过这有额外的开发工作量，目前来看，公司内部的socket.io并没有做集群的数据共享</p><h2 id="7、实际问题"><a href="#7、实际问题" class="headerlink" title="7、实际问题"></a>7、实际问题</h2><h3 id="1、实际问题-1"><a href="#1、实际问题-1" class="headerlink" title="1、实际问题 1"></a>1、实际问题 1</h3><p>1、业务背景</p><p>某系统使用socket.io做数据推送，架构如下图，打开F12，这个前端同时存在polling和websocket的请求，有了上面的经验，这个很容易，我们在Nginx，针对socket.io的请求，配置<strong>会话保持</strong>和<strong>websocket升级</strong>的配置就可以，但是有问题，这主要是业务的使用方式。</p><p><img src="/img/socket-%E5%9B%BE17.png" alt="socket-图17"></p><p>图19</p><p>2、 业务的使用</p><p>1、client首先会发送一个post请求，告知后台微服务，客户端想获取什么数据。</p><p>2、服务端组装好数据后，通过Socket.io将就绪的通知，通过websocket的请求推送到客户端。</p><p>3、客户端接收到数据就绪的通知后，再次发送一个get请求，下载数据 。</p><p>业务只是对socket.io的请求配置了ip_hash，那么试想，</p><p>1、如果客户端的websocket请求是和第一个Socket.io服务端建立的</p><p>2、post请求没有配置ip_hash，所以是轮询负载的，每2笔会有一笔发给了第二个Socket.io。</p><p>3、第二个Socket.io服务端收到了前端的请求，但是它没法通知客户端数据已经准备好了，因为没有websocket的连接，所以客户端一直不会发起下载的请求。</p><p>4、请求卡住了，导致整个系统卡住了</p><p>所以将这2个请求也配置为ip_hash，事实证明，问题解决。</p><p>3、 提问环节</p><p>本文一直没有提七层负载和四层负载的区别，刚好这里有个四层负载，那么有2个问题需要留给读者</p><p>1、上图的四层负载没有做任何改动，如果换成七层负载，需要加什么配置？</p><p>提示：对于polling的请求，上图的负载均衡器是四层和七层其实没区别（只限于这种架构，其他架构可能会有区别，具体问题具体分析），那么我们需要考虑的就是websocket协议了，可以参考另外一篇文章，《浅析nginx实现websocket原理》</p><p>2、哪个集群退化成了单点？</p><h3 id="2、实际问题-2"><a href="#2、实际问题-2" class="headerlink" title="2、实际问题 2"></a>2、实际问题 2</h3><p>为了建立一个WebSocket连接，客户端需要建立一个tcp连接并且发送一个握手协议。连接最初状态为CONNECTING，但是客户端最多有一条连接可以处于CONNECTING状态。如果多个连接尝试同时与一个相同的IP地址建立连接，客户端必须把他们进行排序。如果是web端，Chrome浏览器最多允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别。</p><p>因此某客户遇到了一个问题，使用的socket.io服务总是连接不成功，且浏览器会直接卡死，严重影响业务的正常运转。排查问题是要讲究步骤的，因此</p><p>1、首先，查看了现场的现象，发现浏览器卡死，且发送了很多socket.io的请求，刚好是6条，但是请求一直处于pending状态。</p><p>2、然后，确认了现场的架构拓扑，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">client -&gt;  F5  -&gt;  Nginx（集群） -&gt;  socket.io（集群）<br></code></pre></td></tr></table></figure><p>3、确认了F5的负载模式是7层负载，且没有配置websocket协议升级，Nginx倒是配置了会话保持（现场的实施根据部署文档进行配置），但是配置还存在问题。</p><p>4、如果确认了上面的信息，那么我们可以清晰的发现，问题解决很简单。先来解答一下异常现象</p><ul><li>为什么请求处于pengding状态？</li></ul><p>因为F5使用了7层负载，但是没有配置websocket协议升级，而客户端是同时存在polling和websocket请求的，所以客户端和F5之间的websocket请求一直是建立失败的，只是建立了HTTP1.1的连接，虽然也是长连接，但是属于HTTP，数据的传输格式不一样，报错是肯定的。但是先不要着急，现在还没到这个报错的时候，HTTP的请求如果一直没有响应，那么就是pengding的状态，所以这就是为什么请求都处于pengding的状态。</p><ul><li>浏览器为什么会卡死？</li></ul><p>如果websocket的连接建立不成功，它会一直重复发，直到浏览器的上限，6条tcp连接。</p><p>5、这个架构其实我们已经很熟了，上面也有例子，F5配置websocket协议升级，HSIAR配置会话保持+websocket协议升级即可，但是F5支不支持websocket呢？有版本限制，且配置比较复杂，客户不想研究，那么直接将7层负载变为4层负载，这样问题就解决了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>socket.io</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie属性之secure、httponly</title>
    <link href="/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/"/>
    <url>/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​Cookie是一种用于在Web浏览器和Web服务器之间传递信息的机制，具有多种属性。经常会有安全测试不了解Cookie的属性，而认为某个属性是漏洞，最常见的就是secure，作者就见过很几次漏洞报告，认为http协议下，Cookie的secure为false是一个安全漏洞，这其实是测试没有理解secure的真正作用。那么阅读本文你将得到以下几个问题的答案</p><p>1、Cookie在会话鉴权中扮演什么角色？</p><p>2、secure、httponly的作用是什么？</p><p>3、http协议secure为false，到底是不是漏洞？</p><h2 id="1、首先来了解Cookie的作用"><a href="#1、首先来了解Cookie的作用" class="headerlink" title="1、首先来了解Cookie的作用"></a>1、首先来了解Cookie的作用</h2><p>​Cookie通常被用于存储用户的会话信息、个人偏好设置和其他重要的数据。通过在浏览器中存储小型数据文件的方式，允许Web应用程序在浏览器中存储和检索数据。以下是Cookie的一些常见用途：</p><ol><li>记住用户登录状态：当用户通过用户名和密码进行登录时，服务器会创建一个Cookie，用于记录用户的登录状态。在用户下次访问网站时，Web应用程序可以读取Cookie中的信息，以确认用户已经登录，然后将其自动重定向到其上一次访问的页面。</li><li>存储用户偏好设置：Web应用程序可以使用Cookie来存储用户的偏好设置，例如语言偏好、字体大小、主题颜色等。这样，在用户再次访问网站时，他们的偏好设置就可以自动应用，提高了用户体验。</li><li>跟踪用户活动：通过Cookie，Web应用程序可以追踪用户的活动，例如他们在网站上浏览的页面、使用的功能和购物车内容等。这些信息可以用于分析用户行为、个性化推荐、广告定向等。</li><li>收集统计数据：Cookie也可以用于收集访问网站的用户数量、浏览器类型、设备类型等统计数据。这些数据可以帮助网站优化性能、改进用户体验和制定营销策略。</li></ol><p>总的来说，Cookie是Web应用程序中不可或缺的一部分，它们帮助实现了许多重要的功能，从而提高了用户体验和Web应用程序的效果。</p><p>​我们的产品基于openresty开发，作为互联网接入路由网关，具备会话鉴权的功能。登录时，网关会生成token等会话信息，设置到响应的Cookie头部，返回给浏览器，浏览器会在application存储Cookie信息，当有同域的请求发起时，浏览器会将此域的Cookie（如果有的话）携带并发往服务端进行认证；登出时，网关会设置一个空的Cookie返回给浏览器，相当于删除了application存储Cookie信息。下面为使用https协议登录时的交互：</p><ul><li>登录时</li></ul><p><img src="/img/image-20230305161709819.png" alt="image-20230305161709819"></p><ul><li>登出时：</li></ul><p><img src="/img/image-20230305161752487.png" alt="image-20230305161752487"></p><h2 id="2、Secure与HTTPOnly属性"><a href="#2、Secure与HTTPOnly属性" class="headerlink" title="2、Secure与HTTPOnly属性"></a>2、Secure与HTTPOnly属性</h2><p>​由于Cookie的特殊性质，它们也成为了网络攻击的主要目标之一。在这种情况下，secure和httponly属性成为了确保Cookie安全的重要手段。</p><ol><li>Secure属性是Cookie属性的一种，它用于确保Cookie只在通过安全协议（如HTTPS）的情况下传输。如果将Cookie设置为secure，则只有在使用HTTPS时才会将Cookie发送到服务器，即使用HTTPS协议进行登录，但是后续的请求为HTTP，这样是无法将Cookie携带到服务端的。而且即使攻击者截取了用户的Cookie，也无法使用它们进行会话劫持等攻击。</li><li>HTTPOnly属性是另一种Cookie属性，它可以防止JavaScript代码访问Cookie。JavaScript可以通过document.cookie API来访问Cookie，但是如果将Cookie设置为HTTPOnly，则它们将无法被JavaScript代码获取。这可以防止攻击者通过注入恶意脚本来窃取用户的Cookie，从而提高了Cookie的安全性。</li></ol><p>​综合起来，secure和HTTPOnly属性的结合使用可以大大提高Cookie的安全性，使其更难以被攻击者利用。在设置Cookie时，建议使用这两种属性来确保Cookie的安全性，并且仅在需要将Cookie发送到服务器时才发送它们。需要注意的是，虽然使用secure和HTTPOnly属性可以帮助保护Cookie，但它们并不是完全安全的。攻击者仍然可以使用其他手段来窃取Cookie，例如使用钓鱼攻击来欺骗用户输入他们的凭据。因此，在处理敏感信息时，建议采取其他更全面的安全措施，例如使用多因素身份验证和数据加密等技术来确保数据安全。</p><h2 id="3、结尾"><a href="#3、结尾" class="headerlink" title="3、结尾"></a>3、结尾</h2><p>回到我们的问题，http协议secure为false，到底是不是漏洞？在阅读过第2章后，读者认真思考过应该有了答案。</p><hr><p>显而易见，肯定不是漏洞，HTTP协议根本就不需要secure！！！secure只用于https，在https登录的情况下，限制Cookie被http协议的请求传输。举个实际的例子</p><ul><li>http:</li></ul><p><img src="/img/image-20230305160119214.png" alt="image-20230305160119214"></p><ul><li>https：</li></ul><p><img src="/img/image-20230305160932809.png" alt="image-20230305160932809"></p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssl双向验证— ssl_verify_depth的作用</title>
    <link href="/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关键词</strong>：根证书、中间证书、验证深度、ssl_verify_depth</p><h2 id="根证书与中间证书"><a href="#根证书与中间证书" class="headerlink" title="根证书与中间证书"></a>根证书与中间证书</h2><p>在进行ssl验证前，服务器一般会向CA申请公钥证书，即将自己的公开密钥交给CA，CA用自己的私钥向服务器的公钥数字签名并返回公钥证书，在数字签名的过程中，CA一般会用根目录颁发证书，这种证书叫做根证书。</p><p>问题是，万一根目录颁发错了证书，或者需要撤销根，这时所有根目录颁发的证书都将失效，这样代价是巨大的，因此出现了<strong>中间根</strong>，顾名思义，CA用私钥对中间根进行签名，使它可信，因此由中间根颁发的证书也是可信的，即中间证书。当发生撤销时，只需要撤销中间根颁发的证书就可以。</p><p>这里需要解释一下根证书，个人理解为客户端在验证服务器的公钥证书时，需要拿CA的公钥来解密服务器公钥证书的签名，CA的<strong>根公钥</strong>需要提前拿到手，一般内置到浏览器中，存放的地方视为根目录，存放中间证书即为中间目录。有中间证书的情况下，应该是先从中间目录取到对应<strong>中间公钥</strong>解密，然后循环此过程，直到从根目录拿到公钥验证成功，这时可以算是验证通过。</p><p>同时，在实际生产中，我们拥有私有协议，会存在私有协议的客户端，这些客户端也支持<strong>私有协议</strong>+<strong>ssl</strong>，因此这些客户端也需要内置根证书。</p><h2 id="验证深度"><a href="#验证深度" class="headerlink" title="验证深度"></a>验证深度</h2><p>在CA的证书体系中，证书从根目录出发，像一条链一样，有很多的中间根，也叫做证书链，我觉得更像一棵二叉树。</p><p>在ssl验证的过程中，直接尝试中间证书进行客户端认证是无法通过的，需要一层一层回溯验证，直到找到根。</p><p>这个验证深度就相当于当前中间证书在整棵树中的深度。</p><h2 id="ssl-verify-depth"><a href="#ssl-verify-depth" class="headerlink" title="ssl_verify_depth"></a>ssl_verify_depth</h2><p>上面已经提到了，验证需要层层回溯，向上可以回溯多少次由ssl_verify_depth决定，当<code>ssl_verify_depth = 1</code>时，回溯层数为0，即任何中间证书都不会通过验证，除非是根证书。简而言之，中间证书的深度要小于ssl_verify_depth的值，才会验证通过。</p><p>在nginx中<code>ssl_verify_depth</code>的值默认是为1的。所以如果使用了中间证书，就需要适当调整这个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">句法：    ssl_verify_depth number;<br>默认：    ssl_verify_depth <span class="hljs-number">1</span>;<br>语境：    http， server<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析nginx实现websocket原理</title>
    <link href="/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/"/>
    <url>/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​传统的HTTP协议是一种无状态的请求&#x2F;响应协议，每次请求都需要重新建立连接。在一些特殊的业务场景下，服务端需要主动发送数据到客户端，例如行情推送、监控告警推送等。然而，HTTP协议不支持双向通信，因此需要将HTTP协议“升级”为WebSocket协议。WebSocket协议可以在建立连接后保持连接状态，双方可以通过一个持久的连接通道进行实时通信。WebSocket连接在建立时通过HTTP协议进行握手，之后的数据传输就可以使用WebSocket协议进行。</p><p>Nginx作为中间层的Web服务器，支持使用多种协议与上下游进行通信，包括TCP、HTTP、WebSocket等协议，如下图所示。</p><p><img src="/img/%E5%9B%BE1.png" alt="图1"></p><h2 id="1、nginx升级http为websocket的过程"><a href="#1、nginx升级http为websocket的过程" class="headerlink" title="1、nginx升级http为websocket的过程"></a>1、nginx升级http为websocket的过程</h2><p>​HTTP&#x2F;1.1提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。具体过程如下：</p><p><img src="/img/%E5%9B%BE2.png" alt="图2"></p><p>1.客户端发起 WebSocket 连接请求到 Nginx，Nginx 作为反向代理服务器，将请求转发给上游 WebSocket 服务器。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">GET ws://<span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span>/wss/socket.io HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: <span class="hljs-number">13</span><br>Sec-WebSocket-Key: <span class="hljs-number">3</span>baOagQNXoc1Cd1dJ4pBiA==<br>Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits<br></code></pre></td></tr></table></figure><p>2.上游 WebSocket 服务器响应连接请求并完成握手协议，如果允许升级，将响应状态码101返回给 Nginx。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> Switching Protocols<br>Server:hsiar<br>Date:Wed,<span class="hljs-number">22</span> Feb <span class="hljs-number">2023</span> <span class="hljs-number">06</span>:<span class="hljs-number">23</span>:<span class="hljs-number">49</span> GMT<br>connection:upgrade<br>upgrade:websocket<br>Sec-WebSocket-accept:VVN2Pd9jkG7b8ur3otAk+Ah3bsg=<br>Sec-WebSocket-Extensions:permessage-deflate<br></code></pre></td></tr></table></figure><p>3.Nginx 收到上游 WebSocket 服务器的响应结果后，将其转发给客户端，建立起客户端与上游 WebSocket 服务器的连接。</p><p>4.客户端和上游 WebSocket 服务器之间开始进行实时数据传输。</p><p>5.当客户端或上游 WebSocket 服务器需要发送数据时，数据将通过 WebSocket 协议封装成帧（frame）并发送到对方。</p><p>6.数据通过 Nginx 进行转发时，Nginx 会根据实际情况选择合适的负载均衡算法，将数据传输到适当的上游 WebSocket 服务器。</p><p>7.上游 WebSocket 服务器收到数据后，解析数据帧并处理数据，然后将响应结果封装成帧并发送回客户端。</p><p>8.客户端收到上游 WebSocket 服务器的响应结果后，解析数据帧并处理数据，完成一次数据交互。</p><h2 id="2、nginx核心代码实现"><a href="#2、nginx核心代码实现" class="headerlink" title="2、nginx核心代码实现"></a>2、nginx核心代码实现</h2><h3 id="2-1、连接升级"><a href="#2-1、连接升级" class="headerlink" title="2.1、连接升级"></a>2.1、连接升级</h3><p>​当服务端同意升级为 WebSocket 时，会将响应状态码设置为 “101 Switching Protocols”，表示服务器正在切换协议。如下代码所示，在处理 HTTP 协议时，首先会检查连接是否已升级到另一个协议。其中，NGX_HTTP_SWITCHING_PROTOCOLS 是一个宏，值为 101。然后，会检查客户端的请求是否携带 Upgrade 头部。如果请求携带了该头部，就会将 u-&gt;upgrade 的值设为 1，表示该连接是一个升级连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查响应的状态码</span><br><span class="hljs-keyword">if</span> (u-&gt;headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) &#123;<br>                u-&gt;keepalive = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//客户端请求头是否含有upgrade头部</span><br>                <span class="hljs-keyword">if</span> (r-&gt;headers_in.upgrade) &#123;<br>                    u-&gt;upgrade = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、上下游数据处理"><a href="#2-2、上下游数据处理" class="headerlink" title="2.2、上下游数据处理"></a>2.2、上下游数据处理</h3><p>​nginx基于事件驱动模型，当有事件触发时，就会调用对应的回调函数。</p><p>下游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>    r-&gt;write_event_handler(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    r-&gt;read_event_handler(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>上游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>        u-&gt;write_event_handler(r, u);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        u-&gt;read_event_handler(r, u);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​每个连接都根据类型(http、websocket等)的不同，设置不同的回调，下面的代码展示了当连接的u-&gt;upgrade &#x3D; 1，即为websocket协议时，设置的上下游读写回调函数。当此连接再有读写事件时，就会回调下面设置的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//接收来自upstream的数据 </span><br>u-&gt;read_event_handler = ngx_http_upstream_upgraded_read_upstream;<br><span class="hljs-comment">//向upstream发送数据</span><br>u-&gt;write_event_handler = ngx_http_upstream_upgraded_write_upstream;<br><span class="hljs-comment">//接收来自客户端的数据</span><br>r-&gt;read_event_handler = ngx_http_upstream_upgraded_read_downstream;<br><span class="hljs-comment">//向客户端发送数据</span><br>r-&gt;write_event_handler = ngx_http_upstream_upgraded_write_downstream;<br></code></pre></td></tr></table></figure><p>​实际上，这四个回调函数都调用了同一个处理函数。但是，它们分别传入了不同的参数，因此函数的处理方式也不同，对应四种不同的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​此处的设计非常巧妙（部分代码），使用了不同参数复用了同一个函数。下面的核心代码展示了 Nginx 如何处理事件。</p><p>当数据来自于服务端时，from_upstream 为真，do_write 表示需要发送数据。根据下面的代码，可以看出 src 表示服务端的连接，dst 表示客户端的连接。当 do_write 为 1 且 dst 准备好写入操作（并且需要发送的数据长度不为 0）时，dst 就会发送数据；当 src 准备好读取操作时，src 就会读取数据。</p><p>比较有意思的是，当数据来自于客户端时，只需要将 dst 和 src 交换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_process_upgraded</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_uint_t</span> from_upstream, <span class="hljs-type">ngx_uint_t</span> do_write)</span><br>&#123;<br>    <span class="hljs-comment">//客户端连接</span><br>    downstream = r-&gt;connection;<br>    <span class="hljs-comment">//服务端连接</span><br>    upstream = r-&gt;upstream-&gt;peer.connection;<br>    <br>    <span class="hljs-comment">// 如果数据来自于后端服务器</span><br>    <span class="hljs-keyword">if</span> (from_upstream) &#123;<br>        src = upstream;<br>        dst = downstream;<br>        b = &amp;u-&gt;buffer;<br>    <span class="hljs-comment">// 如果数据来自于客户端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        src = downstream;<br>        dst = upstream;<br>        b = &amp;u-&gt;from_client;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        <span class="hljs-comment">// 判断是否需要发送数据</span><br>        <span class="hljs-keyword">if</span> (do_write) &#123;<br>            <span class="hljs-comment">// 获取当前要发送的数据长度</span><br>            size = b-&gt;last - b-&gt;pos;<br>            <span class="hljs-comment">// 如果要发送的数据长度不为 0，且连接已经准备好进行写操作</span><br>            <span class="hljs-keyword">if</span> (size &amp;&amp; dst-&gt;write-&gt;ready) &#123;<br>                <span class="hljs-comment">// 发送数据</span><br>                n = dst-&gt;send(dst, b-&gt;pos, size);<br>            &#125;<br>        &#125;<br>        size = b-&gt;end - b-&gt;last;<br>        <span class="hljs-comment">// 如果要接收的数据长度不为 0，且连接已经准备好读操作</span><br>        <span class="hljs-keyword">if</span> (size &amp;&amp; src-&gt;read-&gt;ready) &#123;<br>            <span class="hljs-comment">// 接收数据</span><br>            n = src-&gt;recv(src, b-&gt;last, size);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、使用实例"><a href="#3、使用实例" class="headerlink" title="3、使用实例"></a>3、使用实例</h2><p>本节将通过 Nginx 和 WebSocket 客户端&#x2F;服务端的实例，展示如何在实际业务中使用 WebSocket 进行消息推送。</p><p>首先，需要对 Nginx进行路由配置，如下图所示。即，所有以 uri 前缀为 wss 的 HTTP 客户端请求都会被升级为 WebSocket。在代理过程中，HSIAR 还需要将 Connection 和 Upgrade 头部携带给后端服务，告知后端需要将 Nginx 与后端的连接升级为 WebSocket。</p><p><img src="/img/%E5%9B%BE3.png" alt="图3"></p><p>2、建立连接的过程如下图所示，可以看到与2.1节所述过程一致</p><p><img src="/img/%E5%9B%BE4.png" alt="图4"></p><p>3、连接建立成功后，点击订阅，即接收消息的推送</p><p><img src="/img/%E5%9B%BE5.png" alt="图5"></p><p>4、后端推送消息</p><p>可以看到消息由后端成功推送到了客户端</p><p><img src="/img/%E5%9B%BE6.png" alt="图6"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>在实际的生产中，消息推送是一种常用的技术。然而，如果在 WebSocket 客户端和服务端之间的链路中加入代理，尤其是多级代理后，情况就会变得更加复杂。为了确保链路上的每一条连接都是 WebSocket 长连接，需要避免中间出现 HTTP 短链接。否则，推送就可能因连接提前断开而失败。了解该技术的原理和细节，可以帮助快速排查问题并进行修复。同时，研究 Nginx 对 WebSocket 的支持技术实现，不仅能够提高对该技术的理解，也能够为今后开发相关系统提供有益的借鉴。</p>]]></content>
    
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
