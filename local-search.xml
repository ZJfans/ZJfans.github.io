<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/"/>
    <url>/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/</url>
    
    <content type="html"><![CDATA[<p>title: Cookie属性之secure、httponly<br>typora-copy-images-to: .&#x2F;</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​Cookie是一种用于在Web浏览器和Web服务器之间传递信息的机制，具有多种属性。经常会有安全测试不了解Cookie的属性，而认为某个属性是漏洞，最常见的就是secure，作者就见过很几次漏洞报告，认为http协议下，Cookie的secure为false是一个安全漏洞，这其实是测试没有理解secure的真正作用。那么阅读本文你将得到以下几个问题的答案</p><p>1、Cookie在会话鉴权中扮演什么角色？</p><p>2、secure、httponly的作用是什么？</p><p>3、http协议secure为false，到底是不是漏洞？</p><h2 id="1、首先来了解Cookie的作用"><a href="#1、首先来了解Cookie的作用" class="headerlink" title="1、首先来了解Cookie的作用"></a>1、首先来了解Cookie的作用</h2><p>​Cookie通常被用于存储用户的会话信息、个人偏好设置和其他重要的数据。通过在浏览器中存储小型数据文件的方式，允许Web应用程序在浏览器中存储和检索数据。以下是Cookie的一些常见用途：</p><ol><li>记住用户登录状态：当用户通过用户名和密码进行登录时，服务器会创建一个Cookie，用于记录用户的登录状态。在用户下次访问网站时，Web应用程序可以读取Cookie中的信息，以确认用户已经登录，然后将其自动重定向到其上一次访问的页面。</li><li>存储用户偏好设置：Web应用程序可以使用Cookie来存储用户的偏好设置，例如语言偏好、字体大小、主题颜色等。这样，在用户再次访问网站时，他们的偏好设置就可以自动应用，提高了用户体验。</li><li>跟踪用户活动：通过Cookie，Web应用程序可以追踪用户的活动，例如他们在网站上浏览的页面、使用的功能和购物车内容等。这些信息可以用于分析用户行为、个性化推荐、广告定向等。</li><li>收集统计数据：Cookie也可以用于收集访问网站的用户数量、浏览器类型、设备类型等统计数据。这些数据可以帮助网站优化性能、改进用户体验和制定营销策略。</li></ol><p>总的来说，Cookie是Web应用程序中不可或缺的一部分，它们帮助实现了许多重要的功能，从而提高了用户体验和Web应用程序的效果。</p><p>​HSIAR作为互联网接入路由网关，具备会话鉴权的功能。登录时，HSIAR会生成token等会话信息，设置到响应的Cookie头部，返回给浏览器，浏览器会在application存储Cookie信息，当有同域的请求发起时，浏览器会将此域的Cookie（如果有的话）携带并发往服务端进行认证；登出时，HSIAR会设置一个空的Cookie返回给浏览器，相当于删除了application存储Cookie信息。下面为使用https协议登录时的交互：</p><ul><li>登录时</li></ul><p><img src="/img/image-20230305161709819.png" alt="image-20230305161709819"></p><ul><li>登出时：</li></ul><p><img src="/img/image-20230305161752487.png" alt="image-20230305161752487"></p><h2 id="2、Secure与HTTPOnly属性"><a href="#2、Secure与HTTPOnly属性" class="headerlink" title="2、Secure与HTTPOnly属性"></a>2、Secure与HTTPOnly属性</h2><p>​由于Cookie的特殊性质，它们也成为了网络攻击的主要目标之一。在这种情况下，secure和httponly属性成为了确保Cookie安全的重要手段。</p><ol><li>Secure属性是Cookie属性的一种，它用于确保Cookie只在通过安全协议（如HTTPS）的情况下传输。如果将Cookie设置为secure，则只有在使用HTTPS时才会将Cookie发送到服务器，即使用HTTPS协议进行登录，但是后续的请求为HTTP，这样是无法将Cookie携带到服务端的。而且即使攻击者截取了用户的Cookie，也无法使用它们进行会话劫持等攻击。</li><li>HTTPOnly属性是另一种Cookie属性，它可以防止JavaScript代码访问Cookie。JavaScript可以通过document.cookie API来访问Cookie，但是如果将Cookie设置为HTTPOnly，则它们将无法被JavaScript代码获取。这可以防止攻击者通过注入恶意脚本来窃取用户的Cookie，从而提高了Cookie的安全性。</li></ol><p>​综合起来，secure和HTTPOnly属性的结合使用可以大大提高Cookie的安全性，使其更难以被攻击者利用。在设置Cookie时，建议使用这两种属性来确保Cookie的安全性，并且仅在需要将Cookie发送到服务器时才发送它们。需要注意的是，虽然使用secure和HTTPOnly属性可以帮助保护Cookie，但它们并不是完全安全的。攻击者仍然可以使用其他手段来窃取Cookie，例如使用钓鱼攻击来欺骗用户输入他们的凭据。因此，在处理敏感信息时，建议采取其他更全面的安全措施，例如使用多因素身份验证和数据加密等技术来确保数据安全。</p><h2 id="3、结尾"><a href="#3、结尾" class="headerlink" title="3、结尾"></a>3、结尾</h2><p>回到我们的问题，http协议secure为false，到底是不是漏洞？在阅读过第2章后，读者认真思考过应该有了答案。</p><hr><p>显而易见，肯定不是漏洞，HTTP协议根本就不需要secure！！！secure只用于https，在https登录的情况下，限制Cookie被http协议的请求传输。举个实际的例子</p><ul><li>http:</li></ul><p><img src="/img/image-20230305160119214.png" alt="image-20230305160119214"></p><ul><li>https：</li></ul><p><img src="/img/image-20230305160932809.png" alt="image-20230305160932809"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>title: ssl双向验证— ssl_verify_depth的作用<br>typora-copy-images-to: .&#x2F;</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关键词</strong>：根证书、中间证书、验证深度、ssl_verify_depth</p><h2 id="根证书与中间证书"><a href="#根证书与中间证书" class="headerlink" title="根证书与中间证书"></a>根证书与中间证书</h2><p>在进行ssl验证前，服务器一般会向CA申请公钥证书，即将自己的公开密钥交给CA，CA用自己的私钥向服务器的公钥数字签名并返回公钥证书，在数字签名的过程中，CA一般会用根目录颁发证书，这种证书叫做根证书。</p><p>问题是，万一根目录颁发错了证书，或者需要撤销根，这时所有根目录颁发的证书都将失效，这样代价是巨大的，因此出现了<strong>中间根</strong>，顾名思义，CA用私钥对中间根进行签名，使它可信，因此由中间根颁发的证书也是可信的，即中间证书。当发生撤销时，只需要撤销中间根颁发的证书就可以。</p><p>这里需要解释一下根证书，个人理解为客户端在验证服务器的公钥证书时，需要拿CA的公钥来解密服务器公钥证书的签名，CA的<strong>根公钥</strong>需要提前拿到手，一般内置到浏览器中，存放的地方视为根目录，存放中间证书即为中间目录。有中间证书的情况下，应该是先从中间目录取到对应<strong>中间公钥</strong>解密，然后循环此过程，直到从根目录拿到公钥验证成功，这时可以算是验证通过。</p><h2 id="验证深度"><a href="#验证深度" class="headerlink" title="验证深度"></a>验证深度</h2><p>在CA的证书体系中，证书从根目录出发，像一条链一样，有很多的中间根，也叫做证书链，我觉得更像一棵二叉树。</p><p>在ssl验证的过程中，直接尝试中间证书进行客户端认证是无法通过的，需要一层一层回溯验证，直到找到根。</p><p>这个验证深度就相当于当前中间证书在整棵树中的深度。</p><h2 id="ssl-verify-depth"><a href="#ssl-verify-depth" class="headerlink" title="ssl_verify_depth"></a>ssl_verify_depth</h2><p>上面已经提到了，验证需要层层回溯，向上可以回溯多少次由ssl_verify_depth决定，当<code>ssl_verify_depth = 1</code>时，回溯层数为0，即任何中间证书都不会通过验证，除非是根证书。简而言之，中间证书的深度要小于ssl_verify_depth的值，才会验证通过。</p><p>在nginx中<code>ssl_verify_depth</code>的值默认是为1的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">句法：    ssl_verify_depth number;<br>默认：    ssl_verify_depth <span class="hljs-number">1</span>;<br>语境：    http， server<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析nginx实现websocket原理</title>
    <link href="/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/"/>
    <url>/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​传统的HTTP协议是一种无状态的请求&#x2F;响应协议，每次请求都需要重新建立连接。在一些特殊的业务场景下，服务端需要主动发送数据到客户端，例如行情推送、监控告警推送等。然而，HTTP协议不支持双向通信，因此需要将HTTP协议“升级”为WebSocket协议。WebSocket协议可以在建立连接后保持连接状态，双方可以通过一个持久的连接通道进行实时通信。WebSocket连接在建立时通过HTTP协议进行握手，之后的数据传输就可以使用WebSocket协议进行。</p><p>Nginx作为中间层的Web服务器，支持使用多种协议与上下游进行通信，包括TCP、HTTP、WebSocket等协议，如下图所示。</p><p><img src="/img/%E5%9B%BE1.png" alt="图1"></p><h2 id="1、nginx升级http为websocket的过程"><a href="#1、nginx升级http为websocket的过程" class="headerlink" title="1、nginx升级http为websocket的过程"></a>1、nginx升级http为websocket的过程</h2><p>​HTTP&#x2F;1.1提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。具体过程如下：</p><p><img src="/img/%E5%9B%BE2.png" alt="图2"></p><p>1.客户端发起 WebSocket 连接请求到 Nginx，Nginx 作为反向代理服务器，将请求转发给上游 WebSocket 服务器。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">GET ws://<span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span>/wss/socket.io HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: <span class="hljs-number">13</span><br>Sec-WebSocket-Key: <span class="hljs-number">3</span>baOagQNXoc1Cd1dJ4pBiA==<br>Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits<br></code></pre></td></tr></table></figure><p>2.上游 WebSocket 服务器响应连接请求并完成握手协议，如果允许升级，将响应状态码101返回给 Nginx。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> Switching Protocols<br>Server:hsiar<br>Date:Wed,<span class="hljs-number">22</span> Feb <span class="hljs-number">2023</span> <span class="hljs-number">06</span>:<span class="hljs-number">23</span>:<span class="hljs-number">49</span> GMT<br>connection:upgrade<br>upgrade:websocket<br>Sec-WebSocket-accept:VVN2Pd9jkG7b8ur3otAk+Ah3bsg=<br>Sec-WebSocket-Extensions:permessage-deflate<br></code></pre></td></tr></table></figure><p>3.Nginx 收到上游 WebSocket 服务器的响应结果后，将其转发给客户端，建立起客户端与上游 WebSocket 服务器的连接。</p><p>4.客户端和上游 WebSocket 服务器之间开始进行实时数据传输。</p><p>5.当客户端或上游 WebSocket 服务器需要发送数据时，数据将通过 WebSocket 协议封装成帧（frame）并发送到对方。</p><p>6.数据通过 Nginx 进行转发时，Nginx 会根据实际情况选择合适的负载均衡算法，将数据传输到适当的上游 WebSocket 服务器。</p><p>7.上游 WebSocket 服务器收到数据后，解析数据帧并处理数据，然后将响应结果封装成帧并发送回客户端。</p><p>8.客户端收到上游 WebSocket 服务器的响应结果后，解析数据帧并处理数据，完成一次数据交互。</p><h2 id="2、nginx核心代码实现"><a href="#2、nginx核心代码实现" class="headerlink" title="2、nginx核心代码实现"></a>2、nginx核心代码实现</h2><h3 id="2-1、连接升级"><a href="#2-1、连接升级" class="headerlink" title="2.1、连接升级"></a>2.1、连接升级</h3><p>​当服务端同意升级为 WebSocket 时，会将响应状态码设置为 “101 Switching Protocols”，表示服务器正在切换协议。如下代码所示，在处理 HTTP 协议时，首先会检查连接是否已升级到另一个协议。其中，NGX_HTTP_SWITCHING_PROTOCOLS 是一个宏，值为 101。然后，会检查客户端的请求是否携带 Upgrade 头部。如果请求携带了该头部，就会将 u-&gt;upgrade 的值设为 1，表示该连接是一个升级连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查响应的状态码</span><br><span class="hljs-keyword">if</span> (u-&gt;headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) &#123;<br>                u-&gt;keepalive = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//客户端请求头是否含有upgrade头部</span><br>                <span class="hljs-keyword">if</span> (r-&gt;headers_in.upgrade) &#123;<br>                    u-&gt;upgrade = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、上下游数据处理"><a href="#2-2、上下游数据处理" class="headerlink" title="2.2、上下游数据处理"></a>2.2、上下游数据处理</h3><p>​nginx基于事件驱动模型，当有事件触发时，就会调用对应的回调函数。</p><p>下游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>    r-&gt;write_event_handler(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    r-&gt;read_event_handler(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>上游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>        u-&gt;write_event_handler(r, u);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        u-&gt;read_event_handler(r, u);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​每个连接都根据类型(http、websocket等)的不同，设置不同的回调，下面的代码展示了当连接的u-&gt;upgrade &#x3D; 1，即为websocket协议时，设置的上下游读写回调函数。当此连接再有读写事件时，就会回调下面设置的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//接收来自upstream的数据 </span><br>u-&gt;read_event_handler = ngx_http_upstream_upgraded_read_upstream;<br><span class="hljs-comment">//向upstream发送数据</span><br>u-&gt;write_event_handler = ngx_http_upstream_upgraded_write_upstream;<br><span class="hljs-comment">//接收来自客户端的数据</span><br>r-&gt;read_event_handler = ngx_http_upstream_upgraded_read_downstream;<br><span class="hljs-comment">//向客户端发送数据</span><br>r-&gt;write_event_handler = ngx_http_upstream_upgraded_write_downstream;<br></code></pre></td></tr></table></figure><p>​实际上，这四个回调函数都调用了同一个处理函数。但是，它们分别传入了不同的参数，因此函数的处理方式也不同，对应四种不同的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​此处的设计非常巧妙（部分代码），使用了不同参数复用了同一个函数。下面的核心代码展示了 Nginx 如何处理事件。</p><p>当数据来自于服务端时，from_upstream 为真，do_write 表示需要发送数据。根据下面的代码，可以看出 src 表示服务端的连接，dst 表示客户端的连接。当 do_write 为 1 且 dst 准备好写入操作（并且需要发送的数据长度不为 0）时，dst 就会发送数据；当 src 准备好读取操作时，src 就会读取数据。</p><p>比较有意思的是，当数据来自于客户端时，只需要将 dst 和 src 交换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_process_upgraded</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_uint_t</span> from_upstream, <span class="hljs-type">ngx_uint_t</span> do_write)</span><br>&#123;<br>    <span class="hljs-comment">//客户端连接</span><br>    downstream = r-&gt;connection;<br>    <span class="hljs-comment">//服务端连接</span><br>    upstream = r-&gt;upstream-&gt;peer.connection;<br>    <br>    <span class="hljs-comment">// 如果数据来自于后端服务器</span><br>    <span class="hljs-keyword">if</span> (from_upstream) &#123;<br>        src = upstream;<br>        dst = downstream;<br>        b = &amp;u-&gt;buffer;<br>    <span class="hljs-comment">// 如果数据来自于客户端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        src = downstream;<br>        dst = upstream;<br>        b = &amp;u-&gt;from_client;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        <span class="hljs-comment">// 判断是否需要发送数据</span><br>        <span class="hljs-keyword">if</span> (do_write) &#123;<br>            <span class="hljs-comment">// 获取当前要发送的数据长度</span><br>            size = b-&gt;last - b-&gt;pos;<br>            <span class="hljs-comment">// 如果要发送的数据长度不为 0，且连接已经准备好进行写操作</span><br>            <span class="hljs-keyword">if</span> (size &amp;&amp; dst-&gt;write-&gt;ready) &#123;<br>                <span class="hljs-comment">// 发送数据</span><br>                n = dst-&gt;send(dst, b-&gt;pos, size);<br>            &#125;<br>        &#125;<br>        size = b-&gt;end - b-&gt;last;<br>        <span class="hljs-comment">// 如果要接收的数据长度不为 0，且连接已经准备好读操作</span><br>        <span class="hljs-keyword">if</span> (size &amp;&amp; src-&gt;read-&gt;ready) &#123;<br>            <span class="hljs-comment">// 接收数据</span><br>            n = src-&gt;recv(src, b-&gt;last, size);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、使用实例"><a href="#3、使用实例" class="headerlink" title="3、使用实例"></a>3、使用实例</h2><p>本节将通过 HSIAR（基于 Nginx 开发）和 WebSocket 客户端&#x2F;服务端的实例，展示如何在实际业务中使用 WebSocket 进行消息推送。</p><p>首先，需要对 HSIAR 进行路由配置，如下图所示。即，所有以 uri 前缀为 wss 的 HTTP 客户端请求都会被升级为 WebSocket。在代理过程中，HSIAR 还需要将 Connection 和 Upgrade 头部携带给后端服务，告知后端需要将 Nginx 与后端的连接升级为 WebSocket。</p><p><img src="/img/%E5%9B%BE3.png" alt="图3"></p><p>2、建立连接的过程如下图所示，可以看到与2.1节所述过程一致</p><p><img src="/img/%E5%9B%BE4.png" alt="图4"></p><p>3、连接建立成功后，点击订阅，即接收消息的推送</p><p><img src="/img/%E5%9B%BE5.png" alt="图5"></p><p>4、后端推送消息</p><p>可以看到消息由后端成功推送到了客户端</p><p><img src="/img/%E5%9B%BE6.png" alt="图6"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>在实际的生产中，消息推送是一种常用的技术。然而，如果在 WebSocket 客户端和服务端之间的链路中加入代理，尤其是多级代理后，情况就会变得更加复杂。为了确保链路上的每一条连接都是 WebSocket 长连接，需要避免中间出现 HTTP 短链接。否则，推送就可能因连接提前断开而失败。了解该技术的原理和细节，可以帮助快速排查问题并进行修复。同时，研究 Nginx 对 WebSocket 的支持技术实现，不仅能够提高对该技术的理解，也能够为今后开发相关系统提供有益的借鉴。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
