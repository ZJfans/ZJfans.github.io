<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>openresty---lua调用c原理分析</title>
    <link href="/2024/03/11/openresty---lua%E8%B0%83%E7%94%A8c%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2024/03/11/openresty---lua%E8%B0%83%E7%94%A8c%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="openresty—lua调用c模块原理分析"><a href="#openresty—lua调用c模块原理分析" class="headerlink" title="openresty—lua调用c模块原理分析"></a>openresty—lua调用c模块原理分析</h1><h2 id="1、lua基础"><a href="#1、lua基础" class="headerlink" title="1、lua基础"></a>1、lua基础</h2><h3 id="1、lua虚拟机"><a href="#1、lua虚拟机" class="headerlink" title="1、lua虚拟机"></a>1、lua虚拟机</h3><p><code>lua</code>是解释型语言，需要虚拟机对象。不同的<code>lua</code>虚拟机之间的工作是线程安全的，因为一切和虚拟机相关的内存操作都被关联到虚拟机对象中，而没有利用任何其它共享变量。<code>lua</code>的虚拟机核心部分，没有任何的系统调用，是一个纯粹的黑盒子，正确的使用<code>lua</code>，不会对系统造成任何干扰。这其中最关键的一点是，<code>lua</code>让用户自行定义内存管理器，在创建<code>lua</code>虚拟机时传入，这保证了<code>lua</code>的整个运行状态是用户可控的。</p><h3 id="2、状态机"><a href="#2、状态机" class="headerlink" title="2、状态机"></a>2、状态机</h3><p><code>global_State</code>：全局状态机</p><p><code>lua_State</code>：协程状态机</p><p>从<code>lua</code>的使用者的角度看，<code>global_State</code>是不可见的。我们无法用公开的API取到它的指针，也不需要引用它。<code>global_State</code>里面有对主线程的引用，有注册表管理所有全局数据，有全局字符串表，有内存管理函数，有<code>GC</code>需要的把所有对象串联起来的相关信息，以及一切<code>lua</code>在工作时需要的工作内存。<br>通过<code>lua_newstate</code>创建一个新的<code>lua</code>虚拟机时，第一块申请的内存将用来保存主线程和这个全局状态机。<code>lua</code>的实现尽可能的避免内存碎片，同时也减少内存分配和释放的次数。它采用了一个小技巧，利用一个<code>LG</code>结构，把主线程<code>lua_State</code>和<code>global_State</code>分配在一起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LX</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined ( luaI_EXTRASPACE )</span><br><span class="hljs-type">char</span> buff [ luaI_EXTRASPACE ];<br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>lua_State l;<br>&#125; LX;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LG</span> &#123;</span><br>LX l;<br>global_State g;<br>&#125; LG;<br></code></pre></td></tr></table></figure><p><code>lua_newstate</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_API lua_State * <span class="hljs-title function_">lua_newstate</span> <span class="hljs-params">( lua_Alloc f, <span class="hljs-type">void</span> *ud)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    lua_State *L;    <span class="hljs-comment">//创建一个主线程状态机</span><br>    global_State *g; <span class="hljs-comment">//创建一个全局状态机</span><br>    LG *l = cast (LG *, (*f)(ud , <span class="hljs-literal">NULL</span> , lua_TTHREAD , <span class="hljs-keyword">sizeof</span> (LG)));  <span class="hljs-comment">//申请内存</span><br>    ................................................................................<br><span class="hljs-keyword">return</span> L; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、version"><a href="#3、version" class="headerlink" title="3、version"></a>3、version</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">luaL_checkversion</span> <span class="hljs-params">(lua_State *L)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_API <span class="hljs-type">const</span> lua_Number * <span class="hljs-title function_">lua_version</span> <span class="hljs-params">( lua_State *L)</span> &#123;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> lua_Number version = lua_VERSION_NUM ;<br><span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> ) <span class="hljs-keyword">return</span> &amp; version ;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> G(L) -&gt; version ;<br>&#125;<br></code></pre></td></tr></table></figure><p>检查调用它的内核是否是创建这个 <code>lua</code> 状态机的内核。以及调用它的代码是否使用了相同的 <code>lua</code> 版本。同时也检查调用它的内核与创建该 <code>lua</code> 状态机的内核是否使用了同一片地址空间。</p><ol><li><strong>检查调用它的内核是否是创建这个 <code>lua</code> 状态机的内核</strong>：假设你正在编写一个 <code>lua</code> 插件，这个插件将被加载到不同的 <code>lua</code> 程序中。这些程序可能使用了不同版本的 <code>lua</code> 内核。在这种情况下，你的插件需要确保它能在所有这些程序中正常工作。你可以在插件的初始化代码中调用 <code>luaL_checkversion</code> 来确保插件被加载的 <code>lua</code> 程序使用的是和插件编译时相同版本的 <code>lua</code> 内核。</li><li><strong>调用它的代码是否使用了相同的 <code>lua</code> 版本</strong>：假设你正在维护一个 <code>lua</code> 库，这个库被不同的项目使用，而这些项目可能使用了不同版本的<code>lua</code>。在这种情况下，你需要确保你的库在所有这些项目中都能正常工作。你可以在库的初始化代码中调用 <code>luaL_checkversion</code> 来确保使用库的项目使用的是和库编译时相同版本的 <code>lua</code>。</li><li><strong>检查调用它的内核与创建该 lua 状态机的内核是否使用了同一片地址空间</strong>：这通常发生在你的 <code>lua</code> 代码需要和其他语言（如 <code>C</code> 或 <code>C++</code>）的代码交互时。例如，你的 <code>lua</code> 代码调用了一个 <code>C</code> 函数，这个 <code>C</code> 函数创建了一个新的 <code>lua</code> 状态机，并尝试在这个新的状态机上执行一些 <code>lua</code> 代码。在这种情况下，你需要确保这个新的状态机和原来的状态机在同一片地址空间，否则可能会导致内存错误。你可以在 C 函数中调用 <code>luaL_checkversion</code> 来进行这个检查。</li></ol><h3 id="4、元表"><a href="#4、元表" class="headerlink" title="4、元表"></a>4、元表</h3><p><code>lua</code>语言的元表类似于<code>c++</code>的类与对象，c++的每个类都可以绑定成员函数、成员变量，还可以对成员方法进行重载等等，通过实例化一个对象，可以对对象进行一系列的操作。c++是面向对象的语言，当有一个函数需要共用，又不想对类进行继承，可以使用static关键字，定义为一个全局的函数。从这些外在表现的方面看，c++和lua其实很像，但是显然lua更加轻量</p><p>lua 中的每一个值都可以绑定一个元表。这个元表是一个普通的table，它可以定义与该值相关的某些操作。你可以通过设置元表中特定域的值来改变Lua 值的行为。比如当一个非数字型的值作为加法操作的操作数时，Lua 会检查该值是否绑定了元表并且元表设置了域“__add”的值为一个函数，如果是，那么Lua 就会调用这个函数来进行该值的加法操作。</p><p>每个table 和full userdata 类型的值都可以有自己单独的元表（但多个table 和userdata可以共享一个元表）。其它的每一种类型对应地只能绑定一个元表。也就是说，<strong>所有的数字类型只能绑定同一个元表</strong>，<strong>所有的字符串类型只能绑定同一个元表</strong>，等等。除了字符串类型的值默认有一个元表外，其它的值默认是没有元表的。</p><p>一个元表控制了一个对象的算术、比较、连接，取长度操作和索引操作的行为。原理可以去看《lua官方文档》，这里主要关注2个有意思的元方法，索引和赋值</p><ul><li><p>index:索引操作。当使用一个不存于table 中的键去索引table 中的内容时会尝试调用此元方法。（当索引操作作用于的对象不是一个table 时，那么所有键都是不存在的，所以元方法一定会被尝试调用。）</p></li><li><p>newindex: table 赋值操作table[key] &#x3D; value。使用一个不存在于table 中的键来给table 中的域赋值时会尝试调用此元方法。</p></li></ul><p><code>index：</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gettable_event</span> <span class="hljs-params">(table, key)</span></span><br><span class="hljs-keyword">local</span> h<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">table</span>) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> v = <span class="hljs-built_in">rawget</span>(<span class="hljs-built_in">table</span>, key)<br><span class="hljs-comment">-- 如果键存在，返回原始的值</span><br><span class="hljs-keyword">if</span> v ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> v <span class="hljs-keyword">end</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__index</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__index</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(···)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(h) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">return</span> (h(<span class="hljs-built_in">table</span>, key)) <span class="hljs-comment">-- 调用元方法</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> h[key] <span class="hljs-comment">-- 或者把元方法当作一个table 来使用</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><code>newindex：</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">settable_event</span> <span class="hljs-params">(table, key, value)</span></span><br><span class="hljs-keyword">local</span> h<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(<span class="hljs-built_in">table</span>) == <span class="hljs-string">&quot;table&quot;</span> <span class="hljs-keyword">then</span><br><span class="hljs-keyword">local</span> v = <span class="hljs-built_in">rawget</span>(<span class="hljs-built_in">table</span>, key)<br><span class="hljs-comment">-- 如果键存在，那就做原始赋值</span><br><span class="hljs-keyword">if</span> v ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">rawset</span>(<span class="hljs-built_in">table</span>, key, value); <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__newindex</span><br><span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">rawset</span>(<span class="hljs-built_in">table</span>, key, value); <span class="hljs-keyword">return</span> <span class="hljs-keyword">end</span><br><span class="hljs-keyword">else</span><br>h = metatable(<span class="hljs-built_in">table</span>).<span class="hljs-built_in">__newindex</span><br>    <span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br><span class="hljs-built_in">error</span>(···)<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(h) == <span class="hljs-string">&quot;function&quot;</span> <span class="hljs-keyword">then</span><br>h(<span class="hljs-built_in">table</span>, key,value) <span class="hljs-comment">-- 调用元方法</span><br><span class="hljs-keyword">else</span> h[key] = value   <span class="hljs-comment">--或者把元方法当作一个table 来使用</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="2、请求与lua-state的关系"><a href="#2、请求与lua-state的关系" class="headerlink" title="2、请求与lua_state的关系"></a>2、请求与lua_state的关系</h2><h3 id="1、lua-State是什么"><a href="#1、lua-State是什么" class="headerlink" title="1、lua_State是什么"></a>1、lua_State是什么</h3><p>在 <code>lua</code> 中，<code>lua_State</code> 是一个代表 lua 解释器状态的结构体指针，它包含了 lua 解释器的所有状态信息，例如当前的全局环境、栈状态等。可以把<code>lua_State</code> 理解为 lua 的一个线程或者执行环境。</p><p>在 lua 中，每个线程都有自己的独立的执行栈，局部变量，错误处理函数等。这些都被封装在 <code>lua_State</code> 结构体中。当在 lua 中创建一个新的线程（或者协程）时，lua 会为这个线程创建一个新的 <code>lua_State</code>。这个 <code>lua_State</code> 包含了这个线程的所有状态信息，使得这个线程可以独立于其他线程运行。这是 lua 中线程和协程实现的基础，也是 lua 能够支持并发编程的关键。</p><h3 id="2、openresty的协程"><a href="#2、openresty的协程" class="headerlink" title="2、openresty的协程"></a>2、openresty的协程</h3><p>lua 的协程（<code>coroutine</code>）是一种用户级的线程，它们不同于操作系统的线程，切换由程序自身控制，因此开销小，使用灵活。</p><p>在 OpenResty 中，lua 协程用于实现非阻塞 I&#x2F;O。当一个请求需要进行 I&#x2F;O 操作（如访问数据库）时，当前的 lua 协程会挂起，将控制权交给其他的协程。等到 I&#x2F;O 操作完成后，原来的协程再恢复执行。这样，即使 I&#x2F;O 操作是阻塞的，也不会影响到整个程序的执行。</p><h3 id="3、请求与协程的关系"><a href="#3、请求与协程的关系" class="headerlink" title="3、请求与协程的关系"></a>3、请求与协程的关系</h3><p>在 OpenResty 中，每个 worker 进程使用一个 lua VM（lua 虚拟机），并创建一个新的 <code>lua_State</code>（即主线程）来执行 lua 代码。当请求被分配到 worker 时，将在这个 lua VM 中创建一个协程，协程之间数据隔离，每个协程都具有独立的全局变量。</p><p>具体来讲，对于每个请求，Openresty都会创建一个协程来处理，<code>co = ngx_http_lua_new_thread(r, L, &amp;co_ref);</code> 而这个创建的协程是系统协程，是主协程，用户无法控制它。而用户通过<code>ngx.thread.spawn</code>创建的协程是通过 <code>ngx_http_lua_coroutine_create_helper</code>创建出来的，用户创建的协程是主协程的子协程。并通过<code>ngx_http_lua_co_ctx_s</code>保存协程的相关信息。协程通过 <code>ngx_http_lua_run_thread</code> 函数来运行与调度，当前待执行的协程为 <code>ngx_http_lua_ctx_t-&gt;cur_co_ctx</code> 。</p><p>当 lua 代码调用 I&#x2F;O 操作等异步接口时，<code>ngx_lua</code> 会挂起当前协程（并保护上下文数据），而不阻塞 worker 进程]。I&#x2F;O 等异步操作完成时，<code>ngx_lua</code> 会恢复上下文，程序继续执行。这些操作对用户程序都是透明的，使得每个请求都在一个独立的 lua 线程中处理，各个请求之间互不影响，可以并发处理大量的请求，从而提高了系统的吞吐量。</p><h2 id="3、源码分析"><a href="#3、源码分析" class="headerlink" title="3、源码分析"></a>3、源码分析</h2><h3 id="1、lua与c模块的交互"><a href="#1、lua与c模块的交互" class="headerlink" title="1、lua与c模块的交互"></a>1、lua与c模块的交互</h3><p>1、预加载的注册方式，通常自己实现一个模块，采用这种方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_lua_add_package_preload<br><br>    <br><span class="hljs-comment">//在OpenResty（基于Nginx的扩展）中，ngx_http_lua_add_package_preload 是一个用于预加载 lua 模块的函数。这个函数的主要作用是将 lua 模块预加载到 Nginx 工作进程的全局环境中，从而避免在每次请求时重新加载 lua 模块。</span><br><span class="hljs-comment">//具体而言，ngx_http_lua_add_package_preload 用于将 lua 模块与一个预定义的路径关联，以便在需要时可以快速地加载。这对于提高性能和减少模块加载时间非常有用，特别是在处理大量并发请求时。</span><br><span class="hljs-comment">//原型如下：</span><br>    <br><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_http_lua_add_package_preload</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *package, lua_CFunction func)</span>;<br><br><span class="hljs-comment">//cf: ngx_conf_t 结构，用于获取配置信息。</span><br><span class="hljs-comment">//package: lua 模块的名称，通常是点分隔的路径，例如 &quot;resty.foo&quot;。</span><br><span class="hljs-comment">//func: 一个 lua C 函数，用于加载并返回 lua 模块。这个函数在第一次加载模块时被调用，并且加载成功后，其返回值会被缓存，以便后续请求可以直接使用。</span><br></code></pre></td></tr></table></figure><p>如 <code>ngx_http_lua_upstream_module</code> 模块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_upstream_init</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (ngx_http_lua_add_package_preload(cf, <span class="hljs-string">&quot;ngx.upstream&quot;</span>,<br>                                         ngx_http_lua_upstream_create_module)<br>        != NGX_OK)<br>    &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>ngx_http_lua_add_package_preload</code>具体实现为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_add_package_preload</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *package,</span><br><span class="hljs-params">    lua_CFunction func)</span><br>&#123;<br>    lua_State                     *L;<br>    <span class="hljs-type">ngx_http_lua_main_conf_t</span>      *lmcf;<br>    <span class="hljs-type">ngx_http_lua_preload_hook_t</span>   *hook;<br><br>    lmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_lua_module);<br><br>    L = lmcf-&gt;lua;<br>    <br><span class="hljs-comment">//lua_getglobal(L, &quot;package&quot;): 获取全局变量 &quot;package&quot;。</span><br><span class="hljs-comment">//lua_getfield(L, -1, &quot;preload&quot;): 获取 &quot;package&quot; 表中的 &quot;preload&quot; 字段，这是一个用于存放预加载函数的表。</span><br><span class="hljs-comment">//lua_pushcfunction(L, func): 将 C 函数推入 lua 栈。</span><br><span class="hljs-comment">//lua_setfield(L, -2, package): 将 C 函数设置为 &quot;preload&quot; 表中的字段，字段名为 lua 模块的名称。</span><br><span class="hljs-comment">//lua_pop(L, 2): 弹出栈上的两个元素，即 &quot;package&quot; 表和 &quot;preload&quot; 表。</span><br><br><span class="hljs-comment">//很重要！！！！！*******//相当于建立了一个ngx.upstream的表，里面preload存放对应的函数----ngx_http_lua_upstream_module</span><br><br><br>    <span class="hljs-keyword">if</span> (L) &#123;<br>        lua_getglobal(L, <span class="hljs-string">&quot;package&quot;</span>);<br>        lua_getfield(L, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;preload&quot;</span>);<br>        lua_pushcfunction(L, func);<br>        lua_setfield(L, <span class="hljs-number">-2</span>, package);<br>        lua_pop(L, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* we always register preload_hooks since we always create new Lua VMs</span><br><span class="hljs-comment">     * when lua code cache is off. */</span><br><br>    <span class="hljs-keyword">if</span> (lmcf-&gt;preload_hooks == <span class="hljs-literal">NULL</span>) &#123;<br>        lmcf-&gt;preload_hooks =<br>            ngx_array_create(cf-&gt;pool, <span class="hljs-number">4</span>,<br>                             <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_http_lua_preload_hook_t</span>));<br><br>        <span class="hljs-keyword">if</span> (lmcf-&gt;preload_hooks == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    hook = ngx_array_push(lmcf-&gt;preload_hooks);<br>    <span class="hljs-keyword">if</span> (hook == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    hook-&gt;package = (u_char *) package;<br>    hook-&gt;loader = func;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ngx_http_lua_upstream_create_module</code>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">ngx_http_lua_upstream_create_module</span><span class="hljs-params">(lua_State * L)</span><br>&#123;<br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_upstreams);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_upstreams&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_servers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_servers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_primary_peers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_primary_peers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_get_backup_peers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_backup_peers&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_set_peer_down);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;set_peer_down&quot;</span>);<br><br>    lua_pushcfunction(L, ngx_http_lua_upstream_current_upstream_name);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;current_upstream_name&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、非预加载的注册方式，openresty官方内置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span>  <span class="hljs-title function_">ngx_http_lua_inject_xxx_api</span><span class="hljs-params">(lua_State *L)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>如：<code>ngx_http_lua_inject_resp_header_api</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_lua_inject_resp_header_api</span><span class="hljs-params">(lua_State *L)</span><br>&#123;   <span class="hljs-comment">//创建一个新的lua表，并将其推入lua堆栈。这个表将用于存储HTTP响应头的键值对</span><br>    lua_newtable(L);    <span class="hljs-comment">/* .header */</span><br>    <span class="hljs-comment">//创建一个新的lua表，并设置它的元表。元表是一个普通的lua表，它定义了一些特殊的操作，比如当在表中查找一个不存在的键时，会通过元表的__index元方法来获取值。在这里，我们为.header表创建了一个元表。</span><br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">/* metatable for .header */</span><br>    <br>    <span class="hljs-comment">//将C函数ngx_http_lua_ngx_header_get推入堆栈，并将它作为值与键__index关联起来。这样，当在.header表中查找一个不存在的键时，将会调用ngx_http_lua_ngx_header_get函数来获取相应的值。</span><br>    lua_pushcfunction(L, ngx_http_lua_ngx_header_get);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__index&quot;</span>);<br>    <br>    <span class="hljs-comment">//将C函数ngx_http_lua_ngx_header_set推入堆栈，并将它作为值与键__newindex关联起来。这样，当在.header表中设置一个不存在的键时，将会调用ngx_http_lua_ngx_header_set函数来设置相应的值。</span><br>    lua_pushcfunction(L, ngx_http_lua_ngx_header_set);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    <br>    <span class="hljs-comment">//将刚刚创建的元表设置为.header表的元表，从而实现了对HTTP响应头的读写操作。</span><br>    lua_setmetatable(L, <span class="hljs-number">-2</span>);<br>    <br>    <span class="hljs-comment">//将.header表保存在全局环境中，命名为header，这样在lua脚本中可以通过ngx.header来访问和操作HTTP响应头。</span><br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;header&quot;</span>);<br><br>    lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">/* .resp */</span><br><br>    lua_pushcfunction(L, ngx_http_lua_ngx_resp_get_headers);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;get_headers&quot;</span>);<br>    <br>    <span class="hljs-comment">//ngx.resp</span><br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;resp&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>openresty在nginx的配置阶段统一注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_lua_inject_ngx_api</span><span class="hljs-params">(lua_State *L, <span class="hljs-type">ngx_http_lua_main_conf_t</span> *lmcf,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>)</span><br>&#123;<br>    lua_createtable(L, <span class="hljs-number">0</span> <span class="hljs-comment">/* narr */</span>, <span class="hljs-number">115</span> <span class="hljs-comment">/* nrec */</span>);    <span class="hljs-comment">/* ngx.* */</span><br><br>    lua_pushcfunction(L, ngx_http_lua_get_raw_phase_context);<br>    lua_setfield(L, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;_phase_ctx&quot;</span>);<br><br>    ngx_http_lua_inject_arg_api(L);<br><br>    ngx_http_lua_inject_http_consts(L);<br>    ngx_http_lua_inject_core_consts(L);<br><br>    ngx_http_lua_inject_resp_header_api(L);   <span class="hljs-comment">//注册到线程中</span><br>    <br>    .......................................<br></code></pre></td></tr></table></figure><p>将lua与c代码关联起来，这样就可以在lua中调用ngx.header，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">local cookie = &#123;&#125;<br>ngx.header[<span class="hljs-string">&quot;Set-cookie&quot;</span>] = cookie<br></code></pre></td></tr></table></figure><p>3、关于__index</p><p>当尝试从表中获取不存在的值时，那么就会调用  <code>ngx_http_lua_ngx_header_get</code></p><p>在lua中，<code>__index</code> 是一种特殊的元方法（metamethod），用于表的访问控制。当你尝试从一个表中获取一个不存在的键时，lua会在表的元表中查找是否定义了<code>__index</code>元方法。如果找到了<code>__index</code>元方法，lua会调用它，并将表本身和要访问的键作为参数传递给该元方法。</p><p>在这段代码中，我们创建了一个名为 <code>.header</code> 的新表，并为该表创建了一个元表。然后，我们通过 <code>lua_setfield(L, -2, &quot;__index&quot;)</code> 将名为 <code>__index</code> 的 C 函数（<code>ngx_http_lua_ngx_header_get</code>）与该元表中的 <code>__index</code> 键关联起来。这样，当在 <code>.header</code> 表中查找一个不存在的键时，lua 就会调用 <code>ngx_http_lua_ngx_header_get</code> 函数来获取相应的值。</p><p>换句话说，这个代码片段通过设置 <code>__index</code> 元方法，为 <code>.header</code> 表提供了一种自定义的行为：当访问 <code>.header</code> 表中不存在的键时，会调用 <code>ngx_http_lua_ngx_header_get</code> 函数进行处理。这在某种程度上实现了对 <code>.header</code> 表的动态访问控制。</p><h3 id="2、协程"><a href="#2、协程" class="headerlink" title="2、协程"></a>2、协程</h3><ol><li>nginx master初始化时，会创建一个lua_state，并初始化一个cached_lua_threads。      </li><li>master在fork   work时，每个work会拥有各自的lua_state，即主协程</li><li>主协程会维护cached_lua_threads，存放这个work（也就是这个lua_state主协程）创建出的所有协程，可以重复使用。 </li><li>当有请求时，先检查         请求是否在这个虚拟机处理   &amp;&amp;  协程队列是否为空 。    </li><li>如果满足条件，那么从队列取一个协程，绑定该请求的上下文    </li><li>如果不满足条件，说明此时没有主协程，或者没有可用的协程了，那就新建协程</li></ol><p>1、master进程初始化虚拟机，创建lua_state</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化ngx_http_lua_module模块              //初始化虚拟机,lmcf-&gt;lua为创建成功的虚拟机实例</span><br>ngx_http_lua_init               -&gt;         rc = ngx_http_lua_init_vm(&amp;lmcf-&gt;lua, <span class="hljs-literal">NULL</span>, cf-&gt;cycle, cf-&gt;pool, lmcf, cf-&gt;<span class="hljs-built_in">log</span>,<span class="hljs-literal">NULL</span>); <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_http_lua_init_vm</span><span class="hljs-params">(lua_State **new_vm, lua_State *parent_vm,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_cycle_t</span> *cycle, <span class="hljs-type">ngx_pool_t</span> *pool, <span class="hljs-type">ngx_http_lua_main_conf_t</span> *lmcf,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>, <span class="hljs-type">ngx_pool_cleanup_t</span> **pcln)</span><br>&#123;<br>    ..............................................<br><br>    <span class="hljs-comment">/* create new lua VM instance */</span><br>    L = ngx_http_lua_new_state(parent_vm, cycle, lmcf, <span class="hljs-built_in">log</span>);  <span class="hljs-comment">//创建lua_state</span><br>    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    .....................................<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化协程队列</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化配置                                       //初始化队列</span><br>ngx_http_lua_init_main_conf          -&gt;           ngx_queue_init(&amp;lmcf-&gt;cached_lua_threads);<br></code></pre></td></tr></table></figure><p>2、lmcf-&gt;cached_lua_threads</p><p><code>lmcf-&gt;cached_lua_threads</code> 是一个队列，用于缓存 <strong>lua</strong> 协程（线程）。</p><ol><li>这个队列是在 <strong>Nginx</strong> 的 <strong>lua</strong> 模块中使用的，用于管理 <strong>lua</strong> 协程的生命周期。</li><li>具体作用包括但不限于：<ul><li>缓存已经创建的 <strong>lua</strong> 协程，以便在请求处理过程中重复使用。</li><li>避免频繁地创建和销毁协程，提高性能和效率。</li></ul></li><li>当需要执行 <strong>lua</strong> 脚本时，可以从这个队列中获取一个已经存在的协程，而不必每次都重新创建。</li></ol><p><code>lmcf-&gt;cached_lua_threads</code> 是一个用于缓存 <strong>lua</strong> 协程的队列，以优化请求处理性能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_State *<br><span class="hljs-title function_">ngx_http_lua_new_thread</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r, lua_State *L, <span class="hljs-type">int</span> *ref)</span><br>&#123;<br>    ................................<br><br>    lmcf = ngx_http_get_module_main_conf(r, ngx_http_lua_module);<br><br>    <span class="hljs-keyword">if</span> (L == lmcf-&gt;lua &amp;&amp; !ngx_queue_empty(&amp;lmcf-&gt;cached_lua_threads)) &#123;   <span class="hljs-comment">//L和lmcf-&gt;lua有可能不相等吗   &amp;&amp;  协程队列不为空</span><br>        q = ngx_queue_head(&amp;lmcf-&gt;cached_lua_threads);<br>        tref = ngx_queue_data(q, <span class="hljs-type">ngx_http_lua_thread_ref_t</span>, <span class="hljs-built_in">queue</span>);<br>    &#125; <span class="hljs-keyword">else</span>   <span class="hljs-comment">//走到这里，说明  协程队列为空 </span><br>    &#123;<br>        lua_pushlightuserdata(L, ngx_http_lua_lightudata_mask(<br>                              coroutines_key));<br>        lua_rawget(L, lua_REGISTRYINDEX); <span class="hljs-comment">//从主协程获取线程队列</span><br>        co = lua_newthread(L);    <span class="hljs-comment">//新创建协程</span><br>        lua_pushvalue(L, <span class="hljs-number">-1</span>);     <span class="hljs-comment">//新创建的协程推入栈中</span><br>        co_ref = luaL_ref(L, <span class="hljs-number">-3</span>);   <span class="hljs-comment">//新协程的引用存储在注册表</span><br><br>        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, ngx_cycle-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                       <span class="hljs-string">&quot;lua ref lua thread %p (ref %d)&quot;</span>, co, co_ref);<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> OPENRESTY_luaJIT      <span class="hljs-comment">//如果是jit，设置全局变量</span></span><br>        <span class="hljs-keyword">if</span> (set_globals) &#123;<br>            lua_createtable(co, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* the new globals table */</span><br><br>            <span class="hljs-comment">/* co stack: global_tb */</span><br><br>            lua_createtable(co, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">/* the metatable */</span><br>            ngx_http_lua_get_globals_table(co);<br>            lua_setfield(co, <span class="hljs-number">-2</span>, <span class="hljs-string">&quot;__index&quot;</span>);<br>            lua_setmetatable(co, <span class="hljs-number">-2</span>);<br><br>            <span class="hljs-comment">/* co stack: global_tb */</span><br><br>            ngx_http_lua_set_globals_table(co);<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    ................................<br></code></pre></td></tr></table></figure><p>3、请求与协程创建关联的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_http_lua_content_by_chunk(lua_State *L, <span class="hljs-type">ngx_http_request_t</span> *r)<br>&#123;<br>     ................................<br><br>    <span class="hljs-comment">/*  &#123;&#123;&#123; new coroutine to handle request */</span><br>    co = ngx_http_lua_new_thread(r, L, &amp;co_ref);   <span class="hljs-comment">//主线程的创建</span><br><br>    <span class="hljs-keyword">if</span> (co == <span class="hljs-literal">NULL</span>) &#123;<br>        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                      <span class="hljs-string">&quot;lua: failed to create new coroutine to handle request&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;<br>    &#125; <br>   ....................................<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h2><p>1、L和lmcf-&gt;lua有可能不相等吗？</p><ol><li><strong>多线程环境</strong>：如果你的应用程序在多线程环境中运行，每个线程可能有自己的 Lua 解释器状态。在这种情况下，如果 <code>L</code> 被设置为当前线程的 Lua 解释器状态，而 <code>lmcf-&gt;lua</code> 仍然引用主线程的 Lua 解释器状态，那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li><li><strong>Lua 解释器状态切换</strong>：在某些复杂的应用程序中，可能需要动态地切换 Lua 解释器状态。例如，一个请求可能需要在多个 Lua 解释器状态之间切换。在这种情况下，如果 <code>L</code> 被设置为当前需要的 Lua 解释器状态，而 <code>lmcf-&gt;lua</code> 仍然引用之前的 Lua 解释器状态，那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li><li><strong>Lua 解释器状态重新分配</strong>：如果 <code>L</code> 指向的 Lua 解释器状态被重新分配（例如，由于内存管理或垃圾收集），那么 <code>L == lmcf-&gt;lua</code> 就不会成立。</li></ol><p>以目前的认识来看，上述3种情况不会发生，这取决于openresty框架怎么设置L和lmcf-&gt;lua</p><blockquote><p>1、《lua源码剖析-云风》<br>2、<a href="https://segmentfault.com/a/1190000038878724">https://segmentfault.com/a/1190000038878724</a><br>3、openresty-1.25.3.1</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>lua虚拟机</tag>
      
      <tag>global_State</tag>
      
      <tag>lua_State</tag>
      
      <tag>元表</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协商缓存在nginx的应用与实践</title>
    <link href="/2024/03/06/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/03/06/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%9C%A8nginx%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>缓存是一个高效减轻网络与服务器压力的机制，具有减少冗余数据传输、缓解网络瓶颈以及降低时延等优点。通常客户端在请求数据时，会发送请求到原始服务器获取，重复的数据可能会在网络中多次传输，但是如果有缓存，客户端就可以直接从缓存中获取数据，减少重复的流量。例如在浏览器首次请求某些静态资源时，状态码会是200 ok，但是刷新页面，状态码就会变为200 ok ( from memory cache)，这是因为浏览器对这些资源进行了缓存，客户端的数据并不是发送请求到原始服务器获取的，而是从缓存中获取的。</p><p><img src="/img/%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="缓存流程图"></p><p>但是问题也是显而易见的，如果原始服务器的数据发生了改变，而缓存并没有及时更新数据，在客户端请求时返回了过期的数据，这就会导致了数据的不准确。已缓存的数据应当与原始服务器的数据保持一致，更准确的来说，是缓存返回的数据应当与原始服务器的数据保持一致。那么如何在缓存的基础上，避免这个问题呢？事实上，HTTP协议是提供了多种机制来保证数据一致性的。</p><h2 id="2、“使用期”与“新鲜度“"><a href="#2、“使用期”与“新鲜度“" class="headerlink" title="2、“使用期”与“新鲜度“"></a>2、“使用期”与“新鲜度“</h2><p>使用期是指数据在服务器响应返回后的总时间，可以简单理解为数据在缓存使用的时间，从服务器将数据发出去开始计时；新鲜度是指数据在服务器响应发出去后，缓存可以使用的时间。如果使用期小于新鲜度，说明数据是“新鲜的”，缓存可以继续使用。反之，缓存需要判断数据是否发生了更新，是否需要重新拉取数据，如何更新这取决于服务端采用的HTTP缓存策略。</p><p><strong>使用期：</strong></p><p>服务器用HTTP协议的响应头部date表示发送数据时的时间，如果客户端与服务端使用同样的、完全精确的时钟，已缓存数据的使用期（data_age）就可以是当前时间（current_time）减去服务器发送数据时（Date_header_value）的时间。</p><p>data_age &#x3D; current_time – date_header_value</p><p>但是并不是所有的计算机都实现了时钟同步，当服务器和客户端的时钟不同步时，使用期可能是很大或者甚至是负的，如果是负的，就需要将其设置为零。</p><p>data_age &#x3D; max(0，current_time – date_header_value)</p><p>date_header_value的值代表着原始服务器发出数据的时间，所以在经过代理时，一定不能进行修改。</p><p><strong>新鲜度：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Expires : Fri, <span class="hljs-number">09</span> Sep <span class="hljs-number">2022</span>, <span class="hljs-number">05</span>:<span class="hljs-number">27</span>:<span class="hljs-number">57</span> GMT<br><br>Cache-Control : max-age=<span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>服务器用HTTP&#x2F;1.0+的Expires或HTTP&#x2F;1.1的Cache-Control:max-age响应头部指定数据的过期时间。Expires指定的是绝对时间，即数据到这个时间就过期了。而Cache-Control:max-age指定的是相对时间，表示缓存收到数据后可以在缓存存活的时间。由于Expires依靠于时钟的准确性，因此目前更多的使用后者。</p><p>通过比对使用期与新鲜度，缓存可以判断当前存储的数据是否足够新鲜，如果足够新鲜，则直接返回缓存中的数据，不然就只能重新从原始服务器拉取数据。但是数据在缓存中已经过期，而原始服务器中并未发生更新，缓存依旧需要发送请求获取数据，这会消耗大量不必要的网络资源。对于网络传输而言，应当遵守以最小数据量传输而保证最大信息量传输的原则，因此为了减少冗余数据的传输，HTTP协议提供了协商缓存机制，用以减少数据的传输。</p><p><img src="/img/%E4%BD%BF%E7%94%A8%E6%9C%9F%E4%B8%8E%E6%96%B0%E9%B2%9C%E5%BA%A6.png" alt="使用期与新鲜度"></p><h2 id="3、协商缓存：no-store、no-cache与must-revalidate"><a href="#3、协商缓存：no-store、no-cache与must-revalidate" class="headerlink" title="3、协商缓存：no-store、no-cache与must-revalidate"></a>3、协商缓存：no-store、no-cache与must-revalidate</h2><figure class="highlight https"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs https">HTTP/1.0:<br><br>    Pragma: no-cache<br><br>HTTP/1.1:<br><br>    Cache-Control: no-store<br><br>    Cache-Control: no-cache<br><br>    Cache-Control: must-revalidate<br></code></pre></td></tr></table></figure><p>服务器可以通过no-store来禁止缓存对数据进行存储，因此每次客户端请求数据时，缓存都需要发送请求到原始服务器获取，这样就可以保证客户端获取数据的新鲜度。</p><p>no-cache与no-store不同，no-cache允许缓存对数据进行存储，缓存需要在原始服务器验证新鲜度之后，才能将数据返回给客户端。通常，如果数据发生了更新，原始服务器会返回更新后的数据；反之，会返回304，表示缓存的数据并没有发生改变，可以把缓存的数据返回给客户端。</p><p>而must-revalidate与no-cache类似，同样允许缓存对数据进行存储。如果缓存的数据过期，则must-revalidate与no-cache的行为一致；但是如果数据未过期，则可以直接返回给客户端数据而无需验证。因此must-revalidate通常需要与Expires、max-age进行配合使用。例如：</p><p><img src="/img/cache-%E5%9B%BE3.png" alt="cache-图3"></p><p>现在让我们总结一下这3种缓存机制的特点：</p><p>no-store：缓存不可以存储数据，每次请求都需要到服务器获取数据，因此可以保证数据的新鲜度，但是大量冗余数据的传输，会增大网络与服务器的压力，降低系统的整体性能。</p><p>no-cache：缓存可以存储数据，每次请求都需要到服务器进行新鲜度的验证，因此可以保证数据的新鲜度。相比于no-store，减少了大量数据的传输。</p><p>must-revalidate：缓存可以存储数据，如果数据过期，则需要到服务器进行新鲜度的验证，反之，则可以直接返回给客户端数据。相比于no-cache，减少一定数量的新鲜度验证请求，进一步减少网络与服务器的压力，但是不能保证数据的新鲜度，有一定时间的误差，这取决于新鲜度的设置。</p><p>3种机制各有优劣，应该根据具体的业务需求选择合适的缓存机制，但整体来看，no-cache适合绝大部分的场景。 </p><h3 id="3-1、no-cache验证新鲜度：if-modified-since与if-none-match"><a href="#3-1、no-cache验证新鲜度：if-modified-since与if-none-match" class="headerlink" title="3.1、no-cache验证新鲜度：if-modified-since与if-none-match"></a>3.1、no-cache验证新鲜度：if-modified-since与if-none-match</h3><p>当原始服务器采用no-cache缓存模式时，缓存请求数据，服务器的响应会返回响应头Last-Modified与Etag。Last-Modified表示原始服务器修改该数据的最后时间，Etag是一个字符串，不同的系统生成方式也是不同的。缓存在验证新鲜度时，会将这2个值通过2个请求头If-Modified-Since与If-None-Match传送到原始服务器，而原始服务器通过比对这2个值，就可以判断缓存的数据与本地数据是否一致，也就可以决定是否需要返回数据。</p><p>响应：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Last-Modified : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>ETag : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><p>请求：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">If-Modified-Since : Tue,<span class="hljs-number">06</span> Sep <span class="hljs-number">2022</span> <span class="hljs-number">03</span>:<span class="hljs-number">09</span>:<span class="hljs-number">17</span> GMT<br><br>If-None-Match : “<span class="hljs-number">6316</span>b9dd-<span class="hljs-number">2</span>b1ce”<br></code></pre></td></tr></table></figure><h2 id="4、协商缓存在nginx的应用"><a href="#4、协商缓存在nginx的应用" class="headerlink" title="4、协商缓存在nginx的应用"></a>4、协商缓存在nginx的应用</h2><h3 id="4-1、应用no-cache对前端的优化"><a href="#4-1、应用no-cache对前端的优化" class="headerlink" title="4.1、应用no-cache对前端的优化"></a>4.1、应用no-cache对前端的优化</h3><p>nginx提供流量分发、协议转换、静态资源代理等功能。本节以HUI前端为例，围绕静态资源代理这一功能，分析nginx何应用no-cache优化前端。</p><p>see界面可以对协商缓存进行设置，最后落地到配置文件nginx.conf，具体配置如下图所示，可以设置单个文件采用协商缓存模式如： sysconfig.js；也可以根据文件类型后缀设置协商缓存模式如：html或js。</p><p><img src="/E:/Nginx\博客\ZJfans.github.io\source\img\clip_image008.jpg" alt="img"></p><p>首先在浏览器访问hui-build前端，可以看到首次访问时，静态资源的状态码是200 ok，这代表数据是从服务器获取到的。</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg" alt="img"></p><p>接着刷新界面，可以看到状态码变为304 Not Modified，nginx的日志信息也可以看到客户端是发起了一次请求到nginx获取数据，判断到数据并未发生更新返回304。</p><p><img src="/E:/Nginx\博客\ZJfans.github.io\source\img\cache-图6.jpg" alt="img"></p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg" alt="img"></p><p>此时，如果对sysconfig.js进行修改，再次刷新界面，如下图所示，可以看到状态码变为200 ok，修改的内容及时返回到了客户端。</p><p>修改前：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg" alt="img"></p><p>修改：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg" alt="img"></p><p>接着刷新界面，可以看到状态码变为200 ok，而且数据已经更新：</p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg" alt="img"></p><p><img src="file:///C:/Users/ZHANGJ~1/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg" alt="img"></p><p>   这样既可以保证数据的及时更新，又可以减少大量数据的传输，唯一的网络开销是进行新鲜度的再次验证。</p><h3 id="4-2、nginx源码分析If-Modified-Since与If-None-Match"><a href="#4-2、nginx源码分析If-Modified-Since与If-None-Match" class="headerlink" title="4.2、nginx源码分析If-Modified-Since与If-None-Match"></a>4.2、nginx源码分析If-Modified-Since与If-None-Match</h3><p><strong>etag的生成</strong></p><p>nginx的etag的生成方式比较简单，由last-modified与content-length转换为十六进制组合而成。</p><p><img src="/img/cache-%E5%9B%BE12.png" alt="cache-图12"></p><p>缓存请求数据时，在响应头返回给缓存。</p><p><img src="/img/cache-%E5%9B%BE13.png" alt="cache-图13"></p><p><strong>If-Modified-Since</strong>与<strong>If-None-Match</strong>的校验</p><p>缓存向nginx验证数据新鲜度时，需要携带If-Modified-Since与If-None-Match请求头。</p><p><img src="/img/cache-%E5%9B%BE14.png" alt="cache-图14"></p><p>nginx在判断缓存数据的新鲜度时，会先后对If-Modified-Since和If-None-Match与当前数据的last-modified和etag进行比对，只要2者有1个发生了改变，则判断本地数据发生更新，缓存中的数据已过期，就会直接返回更新后的数据，如果都没有变，则会返回304。源码与流程图如下。</p><p><img src="/img/cache-%E5%9B%BE15.png" alt="cache-图15"></p><p><img src="/img/cache-%E5%9B%BE16.png" alt="cache-图16"></p><h2 id="5、实践出真知"><a href="#5、实践出真知" class="headerlink" title="5、实践出真知"></a>5、实践出真知</h2><h3 id="5-1、抓包分析-协商缓存验证新鲜度"><a href="#5-1、抓包分析-协商缓存验证新鲜度" class="headerlink" title="5.1、抓包分析-协商缓存验证新鲜度"></a>5.1、抓包分析-协商缓存验证新鲜度</h3><p>1、首先用nginx代理一个js文件，浏览器第一次请求资源时，状态码为200 ok，刷线界面，状态码变为304，如下图</p><p><img src="/img/cache-17.png" alt="cache-17"></p><p>为了兼容http1.0，pragma也设置了no-cache</p><p><img src="/img/cache-18.png" alt="cache-18"></p><p><img src="/img/cache-19.png" alt="cache-19"></p><p>2、抓包查看第一次请求的网络包，可以看到服务端返回了静态资源的数据</p><p><img src="/img/cache-20.png" alt="cache-20"></p><p>3、查看第二次请求，可以看到服务端没有返回任何静态资源，只有响应头这些数据</p><p><img src="/source/img%5Ccache-21.png" alt="cache-21"></p><p>4、符合协商缓存的现象</p><p>当请求的If-Modified-Since、If-None-Match与服务端不一致时，服务端会返回静态资源</p><p><img src="/img/cache-22.png" alt="cache-22"></p><p>但是当请求的If-Modified-Since、If-None-Match与服务端一致时，服务端验证新鲜度足够，就只会返回304</p><p><img src="/img/cache-23.png" alt="cache-23"></p><p>5、结论</p><p>协商缓存模式下，客户端会对每个已经缓存的资源额外进行一次新鲜度验证，对于网络来说，这是一种开销。但是既要保证资源的新鲜度，又要尽量提高性能，这是很好的策略，毕竟没有完美的人，自然也就没有完美的策略。对于静态资源长时间不发生改变的场景，很明显no-cache不适用，不如使用must-revalidate。</p><h3 id="5-2、特殊请求不生效"><a href="#5-2、特殊请求不生效" class="headerlink" title="5.2、特殊请求不生效"></a>5.2、特殊请求不生效</h3><p>在测试的过程中，一个页面会请求很多静态资源，但是总有几个不会触发协商缓存。</p><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>协商缓存不只是一种简单的缓存机制，更是一种很好的理念。对于客户端与服务端数据同步、性能优化都是很好的借鉴，尤其是服务端不能主动向客户端发送请求的场景。例如当有服务以域名的形式注册到nginx时，nginx需要向DNS查询真实ip，为了避免每次请求都会向DNS查询，会对查询到的结果进行缓存，并启动定时器查询真实ip是否发生改变。而定时器的时间就类似于协商缓存的新鲜度，在实际的生产中没有完美的方案，因此需要根据具体的需求偏重来调整可靠性与性能。</p><p>本文从HTTP缓存原理出发，介绍了缓存对系统性能优化的意义，并讲解了HTTP缓存发展过程中存在冗余数据多次传输的问题，以及为了解决这个问题而出现的协商缓存机制。通过对协商缓存的原理与nginx实现协商缓存的源码分析，希望大家可以对HTTP缓存有一定的理解。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>协商缓存</tag>
      
      <tag>no cache nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SOCKET.IO最佳实践-代理篇</title>
    <link href="/2024/02/28/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/"/>
    <url>/2024/02/28/SOCKET.IO%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E4%BB%A3%E7%90%86%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在传统的轮询中，客户端定期向服务器发送请求，询问是否有新的数据可用。这会导致很多不必要的空请求，尤其是在没有新数据可用的时候。而且如果使用的是HTTP&#x2F;1.0版本，每个请求&#x2F;响应都需要打开一个新连接，考虑到连接的建立、关闭、TCP慢启动机制等因素，这是一个很大的开销。因此HTTP&#x2F;1.1引入了2个头部:Connection头部和Upgrade头部，用于协议升级。</p><p>其中Connection: keep-alive可以将HTTP短链接升级为长连接，这意味着在一个 TCP 连接上可以传输多个 HTTP 请求和响应，这样就减少大量请求建立、关闭等因素的开销，并且依靠这个机制，可以实现一种长轮询的模式，进一步减少空请求的损耗。需要注意的是，HTTP&#x2F;1.0也可以使用Connection: keep-alive，但是服务端并不一定支持，因此尽可能使用HTTP&#x2F;1.1版本，同时本文后续出现的HTTP，默认指的都是HTTP&#x2F;1.1。</p><p>同样，可以使用Connection: Upgrade与Upgrade: websocket将HTTP连接升级为websocket，具体可以参考本人另外一篇文章《浅析nginx实现websocket原理》。</p><h2 id="1、HTTP-长轮询："><a href="#1、HTTP-长轮询：" class="headerlink" title="1、HTTP 长轮询："></a>1、HTTP 长轮询：</h2><p>HTTP长轮询通过使用Connection: keep-alive实现服务端消息的“推送”。具体过程如下：</p><p>1.客户端发送一个HTTP请求到服务器，但服务器不立即响应。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">GET /socket<span class="hljs-selector-class">.io</span>/?EIO=<span class="hljs-number">4</span>&amp;transport=polling&amp;t=OtBbTrW HTTP/<span class="hljs-number">1.1</span><br>Cache-Control: no-cache<br>Connection: keep-alive<br>Host: <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3001</span><br>Pragma: no-cache<br></code></pre></td></tr></table></figure><p>2.服务器保持请求打开，等待有新的数据或事件发生。</p><p>3.一旦有新的数据或事件发生，服务器立即响应请求，将数据传输给客户端。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content</span>-Type: text/plain; charset=UTF-<span class="hljs-number">8</span><br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">118</span><br>cache-control: no-store<br>Date: Wed, <span class="hljs-number">21</span> Feb <span class="hljs-number">2024</span> <span class="hljs-number">12</span>:<span class="hljs-number">13</span>:<span class="hljs-number">32</span> GMT<br>Connection: keep-alive<br>Keep-Alive: timeout=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>Keep-Alive: timeout&#x3D;5 表示服务器愿意在响应后保持连接打开，等待可能的进一步请求，而这个连接将在5秒钟后自动关闭，除非另外有新的请求。</p><p>4.客户端收到响应后，立即再次发起新的HTTP请求，重复上述过程。</p><p>相比于传统轮询，HTTP长轮询减少了不必要的空请求，因为服务器只在有新数据时才会响应。并且这种方式可以降低通信的延迟，因为服务器在有数据时立即将其传输给客户端，而不需要等到下一次定期轮询。</p><p>但是服务器必须维护大量的打开连接，这可能导致服务器资源的浪费。而且在某些情况下，中间代理（如代理服务器或防火墙）可能会中断长轮询连接，导致不稳定的通信。</p><p>所以对于服务端推送消息的场景，websocket是一种更好的方式，HTTP长轮询只是提供了一种在不支持WebSocket的环境中实现实时通信的方法。</p><h2 id="2、Socket-io"><a href="#2、Socket-io" class="headerlink" title="2、Socket.io"></a>2、Socket.io</h2><p>Socket.IO 是一个库，可以在客户端和服务器之间实现低延迟, 双向和基于事件的通信。Socket.IO在普通的websocket上提供一些功能，如自动重新连接、广播、HTTP长轮询回退（无法与服务端建立websocket连接，将回退为HTTP长轮询）等功能。因此一个socket.io客户端和服务端的交互过程中，可能会同时存在HTTP长轮询与websocket协议的请求。在存在代理的链路中，不当的配置会导致通信失败，本文将着重分析在多级代理中，如何正确配置使得socket.io客户端与服务端正常通信。</p><h3 id="2-1、会话id"><a href="#2-1、会话id" class="headerlink" title="2.1、会话id"></a>2.1、会话id</h3><p>在 Socket.IO 中，每个客户端连接都会被分配一个唯一的标识符，通常被称为会话id，会话id在服务端会关联客户端的连接。所有后续HTTP请求的参数中必需携带这个值，这个标识符可以用于在服务器端跟踪和识别特定的客户端连接。</p><p>通过这种标识符，服务器可以维护一个连接池，用于管理和处理来自不同客户端的实时通信。这对于实现诸如广播消息、单播消息、断线重连等功能都非常有用。</p><p>在 Socket.IO 中，连接建立时会触发一个事件（通常是 <strong>connection</strong> 事件），服务器会分配一个唯一的 sid给客户端连接，一个HTTP长轮询请求如下图所示。</p><p><img src="/img/socket-%E5%9B%BE1.png" alt="socket-图1"></p><h3 id="2-2、socket-io集群"><a href="#2-2、socket-io集群" class="headerlink" title="2.2、socket.io集群"></a>2.2、socket.io集群</h3><p>Socket.IO客户端和服务端是靠会话id一一对应的，所以客户端请求到了错误的Socket.IO服务端时，就会报错，因为服务端识别不了。</p><p>因此，当socket.io为集群时，nginx做代理，如果负载策略是轮询，那么客户端和服务端会有概率不匹配。下图的场景，client-A的请求必须路由到第二个socket.io节点，因为nginx是轮询，因此每3笔会有一笔失败，在浏览器的现象就是，刷新2次界面后，系统恢复正常。</p><p>因此，需要在nginx开启会话保持，即ip_hash，这样一个客户端的ip会固定路由到一个Socket.IO服务端，这样就不会出现不匹配的问题。</p><p><img src="/img/socket-%E5%9B%BE2.png" alt="socket-图2"></p><h2 id="3、websocket"><a href="#3、websocket" class="headerlink" title="3、websocket"></a>3、websocket</h2><p>websocket很明显是优于HTTP长轮询的，只要维持一条长连接，就可以实现全双工通信，避免了频繁的建立连接。通常Socket.IO首先会发起HTTP长轮询请求，服务端会在响应中返回upgrades 数组，表示服务器支持更好的传输协议，如下所示。然后，socket.io客户端就会将协议升级为upgrades 数组中的一种。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;sid&quot;</span>: <span class="hljs-string">&quot;FSDjX-WRwSA4zTZMALqx&quot;</span>,<br>  <span class="hljs-string">&quot;upgrades&quot;</span>: [<span class="hljs-string">&quot;websocket&quot;</span>],<br>  <span class="hljs-string">&quot;pingInterval&quot;</span>: <span class="hljs-number">25000</span>,<br>  <span class="hljs-string">&quot;pingTimeout&quot;</span>: <span class="hljs-number">20000</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>sid 是会话的ID，它必须包含在sid所有后续HTTP请求的查询参数中</p></li><li><p>upgrades 数组包含服务器支持的所有“更好”传输的列表</p></li><li><p>pingInterval 和 pingTimeout 值用于心跳</p></li></ul><h3 id="3-1、socket-io升级websocket的过程"><a href="#3-1、socket-io升级websocket的过程" class="headerlink" title="3.1、socket.io升级websocket的过程"></a>3.1、socket.io升级websocket的过程</h3><p>1、 最开始客户端的请求</p><p><img src="/img/socket-%E5%9B%BE3.png" alt="socket-图3"></p><p>2、服务端响应</p><p><img src="/img/socket-%E5%9B%BE4.png" alt="socket-图4"></p><p>3、客户端发送请求建立websocket连接</p><p><img src="/img/socket-%E5%9B%BE5.png" alt="socket-图5"></p><p>其中请求头为</p><p><img src="/img/socket-%E5%9B%BE6.png" alt="socket-图6"></p><p>响应头为</p><p><img src="/img/socket-%E5%9B%BE7.png" alt="socket-图7"></p><p>4、心跳</p><p>心跳间隔为25s，与”pingInterval”: 25000是一致的</p><p><img src="/img/socket-%E5%9B%BE8.png" alt="socket-图8"></p><h3 id="3-2、此websocket非常规的websocket"><a href="#3-2、此websocket非常规的websocket" class="headerlink" title="3.2、此websocket非常规的websocket"></a>3.2、此websocket非常规的websocket</h3><p>Socket.IO 可以使用 WebSocket 协议，但它为每个数据包添加了额外的元数据。所以 WebSocket 客户端将无法成功连接到 Socket.IO 服务器，而 Socket.IO 客户端也将无法连接到普通 WebSocket 服务器。</p><p>我们团队提供的wss组件，虽然支持了socket.io与普通的websocket，但是同一时刻也只能支持其中的一种，即使用socket.io的客户端和websocket客户端连接wss，总有一个会失败。</p><h2 id="4、代理"><a href="#4、代理" class="headerlink" title="4、代理"></a>4、代理</h2><p>由于会话id的存在，每个携带唯一会话id的HTTP请求都必须路由到对应的socket.io服务端，尤其是socket.io服务端为多节点时。本节着重讲解如何正确配置代理节点，使得socket.io客户端与服务端可以使用HTTP长轮询与websocket进行正常通信。</p><h3 id="1、socket-io为单节点"><a href="#1、socket-io为单节点" class="headerlink" title="1、socket.io为单节点"></a>1、socket.io为单节点</h3><ul><li>HTTP长轮询</li></ul><p>socket.io为单节点时，客户端和服务端肯定是对应的，所以不管中间代理怎么路由，都没有问题。</p><ul><li>websocket</li></ul><p>中间节点都需要升级HTTP协议为websocket，如果是四层负载，那就不需要做任何改动，websocket只针对<strong>七层负载。</strong></p><h3 id="2、socket-io多节点"><a href="#2、socket-io多节点" class="headerlink" title="2、socket.io多节点"></a>2、socket.io多节点</h3><h4 id="1、一级代理"><a href="#1、一级代理" class="headerlink" title="1、一级代理"></a>1、一级代理</h4><p>1、代理为单节点</p><p><img src="/img/socket-%E5%9B%BE9.png" alt="socket-图9"></p><ul><li>HTTP长轮询</li></ul><p>由于client使用session id和socket.io端一一对应，因此需要保证同一client的请求一直路由到同一socket.io服务端，否则会报400的错误（其他服务端识别不了未知的sid)。所以nginx需要配置会话保持，即ip_hash，其他负载均衡器类似。</p><p><img src="/img/socket-%E5%9B%BE10.png" alt="socket-图10"></p><ul><li>websocket</li></ul><p>如果nginx配置了协议升级，client到nginx、nginx到socket.io的连接都是websocket协议的连接，即长连接，nginx保证了client与服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE11.png" alt="socket-图11"></p><h4 id="2、多级代理"><a href="#2、多级代理" class="headerlink" title="2、多级代理"></a>2、多级代理</h4><h5 id="1、单-单"><a href="#1、单-单" class="headerlink" title="1、单-单"></a>1、单-单</h5><p>l HTTP长轮询</p><p>如果代理是单节点-单节点，如下图。为了保证客户端与服务端一一对应，那么需要在<strong>第二个nginx配置会话保持</strong>。</p><p><img src="/img/socket-%E5%9B%BE12.png" alt="socket-图12"></p><ul><li>Websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="2、单-多"><a href="#2、单-多" class="headerlink" title="2、单-多"></a>2、单-多</h5><ul><li>HTTP长轮询</li></ul><p>如果代理节点是单节点-多节点，为了保证客户端与服务端一一对应，那么需要<strong>多级nginx都需要配置会话保持</strong>。这时我们应该发现了一个规律，<strong>只要某个节点后面的节点是集群，那么当前节点就需要配置会话保持</strong>，这其实就是HTTP长轮询在多级代理场景下的核心</p><p><img src="/img/socket-%E5%9B%BE13.png" alt="socket-图13"></p><p>深度思考二个问题：</p><p>1、上图第一个nginx真的需要配置ip_hash吗？</p><p>2、下图，哪些nginx需要配置ip_hash?</p><p>答案将会放在第5节，如果你能回答正确，那么你就真正理解了如何代理长轮询</p><p><img src="/img/socket-%E5%9B%BE14.png" alt="socket-图14"></p><ul><li>websocket</li></ul><p>毫无疑问，如果每个nginx都配置了websocket协议升级，将不会出现任何问题</p><h5 id="3、多-多"><a href="#3、多-多" class="headerlink" title="3、多-多"></a>3、多-多</h5><p>这种场景和单-多的场景没有任何区别，因为集群前面肯定有一个单节点的负载均衡器做负载，本质也是单-多。有些人可能好奇，双活难道不是每个节点都是集群吗，整条链路如果存在单节点，这个单节点挂掉之后，整条链路随之挂掉，事实上就是这样的，所以在负载的最前面，都是用DNS做分发。</p><h5 id="4、多-单"><a href="#4、多-单" class="headerlink" title="4、多-单"></a>4、多-单</h5><p>同上，本质和单-多没有区别</p><h4 id="3、HTTP长轮询与websocket同时存在"><a href="#3、HTTP长轮询与websocket同时存在" class="headerlink" title="3、HTTP长轮询与websocket同时存在"></a>3、HTTP长轮询与websocket同时存在</h4><p>Socket.io的机制会同时存在HTTP长轮询与websocket协议的请求，所以代理节点需要<strong>同时配置会话保持与协议升级的配置</strong>。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>1、首先回答第4节的2个问题</p><p>1、第一个nginx真的需要配置ip_hash吗？</p><p>ip_hash是将某一ip的客户端，固定路由到后台的某一台服务器。所以假设client-A、client-B与某个socket.io建立了会话,，那么后续请求也需要一一对应，我们可以推测nginx-M是否设置ip_hash的路由场景</p><ul><li>nginx-M设置了ip_hash</li></ul><p>因为client-A与client-B的ip不一样，nginx-M又设置了ip_hash，所以client-A的请求都会走到nginx-A（这是假设，事实上不走A，就会走B，这里假设走A），client-B的请求都会走到nginx-B。重点来了，<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端（ip_hash的算法决定），假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong></p><ul><li>nginx-M没有设置ip_hash</li></ul><p>如果nginx-M没有设置ip_hash，client的请求，nginx-M会轮询分发到ngina-A和nginx-B，但是由于<strong>nginx-M的ip是固定的，所以对于nginx-A和nginx-B而言，一样的ip，他们都会路由到同一个服务端，假设都路由到了socket.io-A，因此socket.io-B其实一直是空闲的！</strong>，我们发现和上面一模一样，所以结论是nginx-M是不需要设置ip_hash的。</p><p><img src="/img/socket-%E5%9B%BE15.png" alt="socket-图15"></p><p>2、哪些nginx需要配置ip_hash?</p><p>2个问题的本质是一样的，事实上，只要nginx-M、nginx-C、nginx-D设置了ip_hash就可以保证客户端和服务端一一对应</p><p><img src="/img/socket-%E5%9B%BE16.png" alt="socket-图16"></p><p>2、结论</p><p>其实为了简单化问题，我们可以对每个nginx都设置ip_hash，但是需要注意的是，总会有一层的集群变成了”单点”，有节点总是处于空闲状态!，导致集群变成了单点</p><h2 id="6、socket-io集群同步"><a href="#6、socket-io集群同步" class="headerlink" title="6、socket.io集群同步"></a>6、socket.io集群同步</h2><p>试想，如果socket.io集群间能同步数据，那么是不是客户端可以随意对应哪个socket.io了？</p><p>答案是的</p><p>由于客户端可能连接到集群中不同的节点，为了在集群中不同的节点之间传递消息，socket.io官方以redis的发布订阅功能为基础做了消息路由分发：<strong>socket.io-redis</strong>。<strong>socket.io-redis</strong>在节点向客户端群发消息时会将该消息发布到redis的订阅队列中，让其他节点能够订阅到该消息，从而实现节点间消息推送。不过这有额外的开发工作量，目前来看，公司内部的socket.io并没有做集群的数据共享</p><h2 id="7、实际问题"><a href="#7、实际问题" class="headerlink" title="7、实际问题"></a>7、实际问题</h2><h3 id="1、实际问题-1"><a href="#1、实际问题-1" class="headerlink" title="1、实际问题 1"></a>1、实际问题 1</h3><p>1、业务背景</p><p>某系统使用socket.io做数据推送，架构如下图，打开F12，这个前端同时存在polling和websocket的请求，有了上面的经验，这个很容易，我们在Nginx，针对socket.io的请求，配置<strong>会话保持</strong>和<strong>websocket升级</strong>的配置就可以，但是有问题，这主要是业务的使用方式。</p><p><img src="/img/socket-%E5%9B%BE17.png" alt="socket-图17"></p><p>图19</p><p>2、 业务的使用</p><p>1、client首先会发送一个post请求，告知后台微服务，客户端想获取什么数据。</p><p>2、服务端组装好数据后，通过Socket.io将就绪的通知，通过websocket的请求推送到客户端。</p><p>3、客户端接收到数据就绪的通知后，再次发送一个get请求，下载数据 。</p><p>业务只是对socket.io的请求配置了ip_hash，那么试想，</p><p>1、如果客户端的websocket请求是和第一个Socket.io服务端建立的</p><p>2、post请求没有配置ip_hash，所以是轮询负载的，每2笔会有一笔发给了第二个Socket.io。</p><p>3、第二个Socket.io服务端收到了前端的请求，但是它没法通知客户端数据已经准备好了，因为没有websocket的连接，所以客户端一直不会发起下载的请求。</p><p>4、请求卡住了，导致整个系统卡住了</p><p>所以将这2个请求也配置为ip_hash，事实证明，问题解决。</p><p>3、 提问环节</p><p>本文一直没有提七层负载和四层负载的区别，刚好这里有个四层负载，那么有2个问题需要留给读者</p><p>1、上图的四层负载没有做任何改动，如果换成七层负载，需要加什么配置？</p><p>提示：对于polling的请求，上图的负载均衡器是四层和七层其实没区别（只限于这种架构，其他架构可能会有区别，具体问题具体分析），那么我们需要考虑的就是websocket协议了，可以参考另外一篇文章，《浅析nginx实现websocket原理》</p><p>2、哪个集群退化成了单点？</p><h3 id="2、实际问题-2"><a href="#2、实际问题-2" class="headerlink" title="2、实际问题 2"></a>2、实际问题 2</h3><p>为了建立一个WebSocket连接，客户端需要建立一个tcp连接并且发送一个握手协议。连接最初状态为CONNECTING，但是客户端最多有一条连接可以处于CONNECTING状态。如果多个连接尝试同时与一个相同的IP地址建立连接，客户端必须把他们进行排序。如果是web端，Chrome浏览器最多允许对同一个域名Host建立6个TCP连接，不同的浏览器有所区别。</p><p>因此某客户遇到了一个问题，使用的socket.io服务总是连接不成功，且浏览器会直接卡死，严重影响业务的正常运转。排查问题是要讲究步骤的，因此</p><p>1、首先，查看了现场的现象，发现浏览器卡死，且发送了很多socket.io的请求，刚好是6条，但是请求一直处于pending状态。</p><p>2、然后，确认了现场的架构拓扑，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">client -&gt;  F5  -&gt;  Nginx（集群） -&gt;  socket.io（集群）<br></code></pre></td></tr></table></figure><p>3、确认了F5的负载模式是7层负载，且没有配置websocket协议升级，Nginx倒是配置了会话保持（现场的实施根据部署文档进行配置），但是配置还存在问题。</p><p>4、如果确认了上面的信息，那么我们可以清晰的发现，问题解决很简单。先来解答一下异常现象</p><ul><li>为什么请求处于pengding状态？</li></ul><p>因为F5使用了7层负载，但是没有配置websocket协议升级，而客户端是同时存在polling和websocket请求的，所以客户端和F5之间的websocket请求一直是建立失败的，只是建立了HTTP1.1的连接，虽然也是长连接，但是属于HTTP，数据的传输格式不一样，报错是肯定的。但是先不要着急，现在还没到这个报错的时候，HTTP的请求如果一直没有响应，那么就是pengding的状态，所以这就是为什么请求都处于pengding的状态。</p><ul><li>浏览器为什么会卡死？</li></ul><p>如果websocket的连接建立不成功，它会一直重复发，直到浏览器的上限，6条tcp连接。</p><p>5、这个架构其实我们已经很熟了，上面也有例子，F5配置websocket协议升级，HSIAR配置会话保持+websocket协议升级即可，但是F5支不支持websocket呢？有版本限制，且配置比较复杂，客户不想研究，那么直接将7层负载变为4层负载，这样问题就解决了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>socket.io</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cookie属性之secure、httponly</title>
    <link href="/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/"/>
    <url>/2024/02/28/Cookie%E5%B1%9E%E6%80%A7%E4%B9%8Bsecure%E3%80%81httponly/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​Cookie是一种用于在Web浏览器和Web服务器之间传递信息的机制，具有多种属性。经常会有安全测试不了解Cookie的属性，而认为某个属性是漏洞，最常见的就是secure，作者就见过很几次漏洞报告，认为http协议下，Cookie的secure为false是一个安全漏洞，这其实是测试没有理解secure的真正作用。那么阅读本文你将得到以下几个问题的答案</p><p>1、Cookie在会话鉴权中扮演什么角色？</p><p>2、secure、httponly的作用是什么？</p><p>3、http协议secure为false，到底是不是漏洞？</p><h2 id="1、首先来了解Cookie的作用"><a href="#1、首先来了解Cookie的作用" class="headerlink" title="1、首先来了解Cookie的作用"></a>1、首先来了解Cookie的作用</h2><p>​Cookie通常被用于存储用户的会话信息、个人偏好设置和其他重要的数据。通过在浏览器中存储小型数据文件的方式，允许Web应用程序在浏览器中存储和检索数据。以下是Cookie的一些常见用途：</p><ol><li>记住用户登录状态：当用户通过用户名和密码进行登录时，服务器会创建一个Cookie，用于记录用户的登录状态。在用户下次访问网站时，Web应用程序可以读取Cookie中的信息，以确认用户已经登录，然后将其自动重定向到其上一次访问的页面。</li><li>存储用户偏好设置：Web应用程序可以使用Cookie来存储用户的偏好设置，例如语言偏好、字体大小、主题颜色等。这样，在用户再次访问网站时，他们的偏好设置就可以自动应用，提高了用户体验。</li><li>跟踪用户活动：通过Cookie，Web应用程序可以追踪用户的活动，例如他们在网站上浏览的页面、使用的功能和购物车内容等。这些信息可以用于分析用户行为、个性化推荐、广告定向等。</li><li>收集统计数据：Cookie也可以用于收集访问网站的用户数量、浏览器类型、设备类型等统计数据。这些数据可以帮助网站优化性能、改进用户体验和制定营销策略。</li></ol><p>总的来说，Cookie是Web应用程序中不可或缺的一部分，它们帮助实现了许多重要的功能，从而提高了用户体验和Web应用程序的效果。</p><p>​我们的产品基于openresty开发，作为互联网接入路由网关，具备会话鉴权的功能。登录时，网关会生成token等会话信息，设置到响应的Cookie头部，返回给浏览器，浏览器会在application存储Cookie信息，当有同域的请求发起时，浏览器会将此域的Cookie（如果有的话）携带并发往服务端进行认证；登出时，网关会设置一个空的Cookie返回给浏览器，相当于删除了application存储Cookie信息。下面为使用https协议登录时的交互：</p><ul><li>登录时</li></ul><p><img src="/img/image-20230305161709819.png" alt="image-20230305161709819"></p><ul><li>登出时：</li></ul><p><img src="/img/image-20230305161752487.png" alt="image-20230305161752487"></p><h2 id="2、Secure与HTTPOnly属性"><a href="#2、Secure与HTTPOnly属性" class="headerlink" title="2、Secure与HTTPOnly属性"></a>2、Secure与HTTPOnly属性</h2><p>​由于Cookie的特殊性质，它们也成为了网络攻击的主要目标之一。在这种情况下，secure和httponly属性成为了确保Cookie安全的重要手段。</p><ol><li>Secure属性是Cookie属性的一种，它用于确保Cookie只在通过安全协议（如HTTPS）的情况下传输。如果将Cookie设置为secure，则只有在使用HTTPS时才会将Cookie发送到服务器，即使用HTTPS协议进行登录，但是后续的请求为HTTP，这样是无法将Cookie携带到服务端的。而且即使攻击者截取了用户的Cookie，也无法使用它们进行会话劫持等攻击。</li><li>HTTPOnly属性是另一种Cookie属性，它可以防止JavaScript代码访问Cookie。JavaScript可以通过document.cookie API来访问Cookie，但是如果将Cookie设置为HTTPOnly，则它们将无法被JavaScript代码获取。这可以防止攻击者通过注入恶意脚本来窃取用户的Cookie，从而提高了Cookie的安全性。</li></ol><p>​综合起来，secure和HTTPOnly属性的结合使用可以大大提高Cookie的安全性，使其更难以被攻击者利用。在设置Cookie时，建议使用这两种属性来确保Cookie的安全性，并且仅在需要将Cookie发送到服务器时才发送它们。需要注意的是，虽然使用secure和HTTPOnly属性可以帮助保护Cookie，但它们并不是完全安全的。攻击者仍然可以使用其他手段来窃取Cookie，例如使用钓鱼攻击来欺骗用户输入他们的凭据。因此，在处理敏感信息时，建议采取其他更全面的安全措施，例如使用多因素身份验证和数据加密等技术来确保数据安全。</p><h2 id="3、结尾"><a href="#3、结尾" class="headerlink" title="3、结尾"></a>3、结尾</h2><p>回到我们的问题，http协议secure为false，到底是不是漏洞？在阅读过第2章后，读者认真思考过应该有了答案。</p><hr><p>显而易见，肯定不是漏洞，HTTP协议根本就不需要secure！！！secure只用于https，在https登录的情况下，限制Cookie被http协议的请求传输。举个实际的例子</p><ul><li>http:</li></ul><p><img src="/img/image-20230305160119214.png" alt="image-20230305160119214"></p><ul><li>https：</li></ul><p><img src="/img/image-20230305160932809.png" alt="image-20230305160932809"></p>]]></content>
    
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssl双向验证— ssl_verify_depth的作用</title>
    <link href="/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2024/02/28/ssl%E5%8F%8C%E5%90%91%E9%AA%8C%E8%AF%81%E2%80%94%20ssl_verify_depth%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>关键词</strong>：根证书、中间证书、验证深度、ssl_verify_depth</p><h2 id="根证书与中间证书"><a href="#根证书与中间证书" class="headerlink" title="根证书与中间证书"></a>根证书与中间证书</h2><p>在进行ssl验证前，服务器一般会向CA申请公钥证书，即将自己的公开密钥交给CA，CA用自己的私钥向服务器的公钥数字签名并返回公钥证书，在数字签名的过程中，CA一般会用根目录颁发证书，这种证书叫做根证书。</p><p>问题是，万一根目录颁发错了证书，或者需要撤销根，这时所有根目录颁发的证书都将失效，这样代价是巨大的，因此出现了<strong>中间根</strong>，顾名思义，CA用私钥对中间根进行签名，使它可信，因此由中间根颁发的证书也是可信的，即中间证书。当发生撤销时，只需要撤销中间根颁发的证书就可以。</p><p>这里需要解释一下根证书，个人理解为客户端在验证服务器的公钥证书时，需要拿CA的公钥来解密服务器公钥证书的签名，CA的<strong>根公钥</strong>需要提前拿到手，一般内置到浏览器中，存放的地方视为根目录，存放中间证书即为中间目录。有中间证书的情况下，应该是先从中间目录取到对应<strong>中间公钥</strong>解密，然后循环此过程，直到从根目录拿到公钥验证成功，这时可以算是验证通过。</p><p>同时，在实际生产中，我们拥有私有协议，会存在私有协议的客户端，这些客户端也支持<strong>私有协议</strong>+<strong>ssl</strong>，因此这些客户端也需要内置根证书。</p><h2 id="验证深度"><a href="#验证深度" class="headerlink" title="验证深度"></a>验证深度</h2><p>在CA的证书体系中，证书从根目录出发，像一条链一样，有很多的中间根，也叫做证书链，我觉得更像一棵二叉树。</p><p>在ssl验证的过程中，直接尝试中间证书进行客户端认证是无法通过的，需要一层一层回溯验证，直到找到根。</p><p>这个验证深度就相当于当前中间证书在整棵树中的深度。</p><h2 id="ssl-verify-depth"><a href="#ssl-verify-depth" class="headerlink" title="ssl_verify_depth"></a>ssl_verify_depth</h2><p>上面已经提到了，验证需要层层回溯，向上可以回溯多少次由ssl_verify_depth决定，当<code>ssl_verify_depth = 1</code>时，回溯层数为0，即任何中间证书都不会通过验证，除非是根证书。简而言之，中间证书的深度要小于ssl_verify_depth的值，才会验证通过。</p><p>在nginx中<code>ssl_verify_depth</code>的值默认是为1的。所以如果使用了中间证书，就需要适当调整这个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">句法：    ssl_verify_depth number;<br>默认：    ssl_verify_depth <span class="hljs-number">1</span>;<br>语境：    http， server<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>证书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析nginx实现websocket原理</title>
    <link href="/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/"/>
    <url>/2024/02/27/%E6%B5%85%E6%9E%90nginx%E5%AE%9E%E7%8E%B0websocket%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​传统的HTTP协议是一种无状态的请求&#x2F;响应协议，每次请求都需要重新建立连接。在一些特殊的业务场景下，服务端需要主动发送数据到客户端，例如行情推送、监控告警推送等。然而，HTTP协议不支持双向通信，因此需要将HTTP协议“升级”为WebSocket协议。WebSocket协议可以在建立连接后保持连接状态，双方可以通过一个持久的连接通道进行实时通信。WebSocket连接在建立时通过HTTP协议进行握手，之后的数据传输就可以使用WebSocket协议进行。</p><p>Nginx作为中间层的Web服务器，支持使用多种协议与上下游进行通信，包括TCP、HTTP、WebSocket等协议，如下图所示。</p><p><img src="/img/%E5%9B%BE1.png" alt="图1"></p><h2 id="1、nginx升级http为websocket的过程"><a href="#1、nginx升级http为websocket的过程" class="headerlink" title="1、nginx升级http为websocket的过程"></a>1、nginx升级http为websocket的过程</h2><p>​HTTP&#x2F;1.1提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。具体过程如下：</p><p><img src="/img/%E5%9B%BE2.png" alt="图2"></p><p>1.客户端发起 WebSocket 连接请求到 Nginx，Nginx 作为反向代理服务器，将请求转发给上游 WebSocket 服务器。客户端发送的请求类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">GET ws://<span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span>/wss/socket.io HTTP/<span class="hljs-number">1.1</span><br>Host: <span class="hljs-number">10.40</span>.<span class="hljs-number">2.63</span>:<span class="hljs-number">58088</span><br>Connection: Upgrade<br>Upgrade: websocket<br>Sec-WebSocket-Version: <span class="hljs-number">13</span><br>Sec-WebSocket-Key: <span class="hljs-number">3</span>baOagQNXoc1Cd1dJ4pBiA==<br>Sec-WebSocket-Extensions:permessage-deflate;client_max_window_bits<br></code></pre></td></tr></table></figure><p>2.上游 WebSocket 服务器响应连接请求并完成握手协议，如果允许升级，将响应状态码101返回给 Nginx。服务端的响应类似于下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">101</span> Switching Protocols<br>Server:hsiar<br>Date:Wed,<span class="hljs-number">22</span> Feb <span class="hljs-number">2023</span> <span class="hljs-number">06</span>:<span class="hljs-number">23</span>:<span class="hljs-number">49</span> GMT<br>connection:upgrade<br>upgrade:websocket<br>Sec-WebSocket-accept:VVN2Pd9jkG7b8ur3otAk+Ah3bsg=<br>Sec-WebSocket-Extensions:permessage-deflate<br></code></pre></td></tr></table></figure><p>3.Nginx 收到上游 WebSocket 服务器的响应结果后，将其转发给客户端，建立起客户端与上游 WebSocket 服务器的连接。</p><p>4.客户端和上游 WebSocket 服务器之间开始进行实时数据传输。</p><p>5.当客户端或上游 WebSocket 服务器需要发送数据时，数据将通过 WebSocket 协议封装成帧（frame）并发送到对方。</p><p>6.数据通过 Nginx 进行转发时，Nginx 会根据实际情况选择合适的负载均衡算法，将数据传输到适当的上游 WebSocket 服务器。</p><p>7.上游 WebSocket 服务器收到数据后，解析数据帧并处理数据，然后将响应结果封装成帧并发送回客户端。</p><p>8.客户端收到上游 WebSocket 服务器的响应结果后，解析数据帧并处理数据，完成一次数据交互。</p><h2 id="2、nginx核心代码实现"><a href="#2、nginx核心代码实现" class="headerlink" title="2、nginx核心代码实现"></a>2、nginx核心代码实现</h2><h3 id="2-1、连接升级"><a href="#2-1、连接升级" class="headerlink" title="2.1、连接升级"></a>2.1、连接升级</h3><p>​当服务端同意升级为 WebSocket 时，会将响应状态码设置为 “101 Switching Protocols”，表示服务器正在切换协议。如下代码所示，在处理 HTTP 协议时，首先会检查连接是否已升级到另一个协议。其中，NGX_HTTP_SWITCHING_PROTOCOLS 是一个宏，值为 101。然后，会检查客户端的请求是否携带 Upgrade 头部。如果请求携带了该头部，就会将 u-&gt;upgrade 的值设为 1，表示该连接是一个升级连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//检查响应的状态码</span><br><span class="hljs-keyword">if</span> (u-&gt;headers_in.status_n == NGX_HTTP_SWITCHING_PROTOCOLS) &#123;<br>                u-&gt;keepalive = <span class="hljs-number">0</span>;<br>                <span class="hljs-comment">//客户端请求头是否含有upgrade头部</span><br>                <span class="hljs-keyword">if</span> (r-&gt;headers_in.upgrade) &#123;<br>                    u-&gt;upgrade = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、上下游数据处理"><a href="#2-2、上下游数据处理" class="headerlink" title="2.2、上下游数据处理"></a>2.2、上下游数据处理</h3><p>​nginx基于事件驱动模型，当有事件触发时，就会调用对应的回调函数。</p><p>下游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>    r-&gt;write_event_handler(r);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    r-&gt;read_event_handler(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>上游：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ev-&gt;write) &#123;<br>        u-&gt;write_event_handler(r, u);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        u-&gt;read_event_handler(r, u);<br>    &#125;<br></code></pre></td></tr></table></figure><p>​每个连接都根据类型(http、websocket等)的不同，设置不同的回调，下面的代码展示了当连接的u-&gt;upgrade &#x3D; 1，即为websocket协议时，设置的上下游读写回调函数。当此连接再有读写事件时，就会回调下面设置的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//接收来自upstream的数据 </span><br>u-&gt;read_event_handler = ngx_http_upstream_upgraded_read_upstream;<br><span class="hljs-comment">//向upstream发送数据</span><br>u-&gt;write_event_handler = ngx_http_upstream_upgraded_write_upstream;<br><span class="hljs-comment">//接收来自客户端的数据</span><br>r-&gt;read_event_handler = ngx_http_upstream_upgraded_read_downstream;<br><span class="hljs-comment">//向客户端发送数据</span><br>r-&gt;write_event_handler = ngx_http_upstream_upgraded_write_downstream;<br></code></pre></td></tr></table></figure><p>​实际上，这四个回调函数都调用了同一个处理函数。但是，它们分别传入了不同的参数，因此函数的处理方式也不同，对应四种不同的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_upstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_http_upstream_t</span> *u)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_read_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_upgraded_write_downstream</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r)</span><br>&#123;<br>    ngx_http_upstream_process_upgraded(r, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​此处的设计非常巧妙（部分代码），使用了不同参数复用了同一个函数。下面的核心代码展示了 Nginx 如何处理事件。</p><p>当数据来自于服务端时，from_upstream 为真，do_write 表示需要发送数据。根据下面的代码，可以看出 src 表示服务端的连接，dst 表示客户端的连接。当 do_write 为 1 且 dst 准备好写入操作（并且需要发送的数据长度不为 0）时，dst 就会发送数据；当 src 准备好读取操作时，src 就会读取数据。</p><p>比较有意思的是，当数据来自于客户端时，只需要将 dst 和 src 交换即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_http_upstream_process_upgraded</span><span class="hljs-params">(<span class="hljs-type">ngx_http_request_t</span> *r,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_uint_t</span> from_upstream, <span class="hljs-type">ngx_uint_t</span> do_write)</span><br>&#123;<br>    <span class="hljs-comment">//客户端连接</span><br>    downstream = r-&gt;connection;<br>    <span class="hljs-comment">//服务端连接</span><br>    upstream = r-&gt;upstream-&gt;peer.connection;<br>    <br>    <span class="hljs-comment">// 如果数据来自于后端服务器</span><br>    <span class="hljs-keyword">if</span> (from_upstream) &#123;<br>        src = upstream;<br>        dst = downstream;<br>        b = &amp;u-&gt;buffer;<br>    <span class="hljs-comment">// 如果数据来自于客户端</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        src = downstream;<br>        dst = upstream;<br>        b = &amp;u-&gt;from_client;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        <span class="hljs-comment">// 判断是否需要发送数据</span><br>        <span class="hljs-keyword">if</span> (do_write) &#123;<br>            <span class="hljs-comment">// 获取当前要发送的数据长度</span><br>            size = b-&gt;last - b-&gt;pos;<br>            <span class="hljs-comment">// 如果要发送的数据长度不为 0，且连接已经准备好进行写操作</span><br>            <span class="hljs-keyword">if</span> (size &amp;&amp; dst-&gt;write-&gt;ready) &#123;<br>                <span class="hljs-comment">// 发送数据</span><br>                n = dst-&gt;send(dst, b-&gt;pos, size);<br>            &#125;<br>        &#125;<br>        size = b-&gt;end - b-&gt;last;<br>        <span class="hljs-comment">// 如果要接收的数据长度不为 0，且连接已经准备好读操作</span><br>        <span class="hljs-keyword">if</span> (size &amp;&amp; src-&gt;read-&gt;ready) &#123;<br>            <span class="hljs-comment">// 接收数据</span><br>            n = src-&gt;recv(src, b-&gt;last, size);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、使用实例"><a href="#3、使用实例" class="headerlink" title="3、使用实例"></a>3、使用实例</h2><p>本节将通过 Nginx 和 WebSocket 客户端&#x2F;服务端的实例，展示如何在实际业务中使用 WebSocket 进行消息推送。</p><p>首先，需要对 Nginx进行路由配置，如下图所示。即，所有以 uri 前缀为 wss 的 HTTP 客户端请求都会被升级为 WebSocket。在代理过程中，HSIAR 还需要将 Connection 和 Upgrade 头部携带给后端服务，告知后端需要将 Nginx 与后端的连接升级为 WebSocket。</p><p><img src="/img/%E5%9B%BE3.png" alt="图3"></p><p>2、建立连接的过程如下图所示，可以看到与2.1节所述过程一致</p><p><img src="/img/%E5%9B%BE4.png" alt="图4"></p><p>3、连接建立成功后，点击订阅，即接收消息的推送</p><p><img src="/img/%E5%9B%BE5.png" alt="图5"></p><p>4、后端推送消息</p><p>可以看到消息由后端成功推送到了客户端</p><p><img src="/img/%E5%9B%BE6.png" alt="图6"></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>在实际的生产中，消息推送是一种常用的技术。然而，如果在 WebSocket 客户端和服务端之间的链路中加入代理，尤其是多级代理后，情况就会变得更加复杂。为了确保链路上的每一条连接都是 WebSocket 长连接，需要避免中间出现 HTTP 短链接。否则，推送就可能因连接提前断开而失败。了解该技术的原理和细节，可以帮助快速排查问题并进行修复。同时，研究 Nginx 对 WebSocket 的支持技术实现，不仅能够提高对该技术的理解，也能够为今后开发相关系统提供有益的借鉴。</p>]]></content>
    
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
